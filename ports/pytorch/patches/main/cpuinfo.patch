diff --git a/CMakeLists.txt b/CMakeLists.txt
index bd9f77f..354100a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -108,7 +108,7 @@ IF(NOT CMAKE_SYSTEM_NAME)
       "Target operating system is not specified. "
       "cpuinfo will compile, but cpuinfo_initialize() will always fail.")
   SET(CPUINFO_SUPPORTED_PLATFORM FALSE)
-ELSEIF(NOT CMAKE_SYSTEM_NAME MATCHES "^(Windows|WindowsStore|CYGWIN|MSYS|Darwin|Linux|Android|FreeBSD)$")
+ELSEIF(NOT CMAKE_SYSTEM_NAME MATCHES "^(Windows|WindowsStore|CYGWIN|MSYS|Darwin|Linux|Android|FreeBSD|QNX)$")
   IF(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.14" AND NOT IS_APPLE_OS)
     MESSAGE(WARNING
       "Target operating system \"${CMAKE_SYSTEM_NAME}\" is not supported in cpuinfo. "
@@ -160,7 +160,27 @@ ENDIF()
 # ---[ cpuinfo library
 SET(CPUINFO_SRCS src/api.c src/cache.c src/init.c src/log.c)
 
-IF(CPUINFO_SUPPORTED_PLATFORM)
+IF(QNX)
+  LIST(APPEND CPUINFO_SRCS
+  src/qnx/api.c
+  src/arm/uarch.c
+  )
+  IF(CPUINFO_TARGET_PROCESSOR MATCHES "^(i[3-6]86|AMD64|x86(_64)?)$")
+    LIST(APPEND CPUINFO_SRCS
+      src/x86/init.c
+      src/x86/info.c
+      src/x86/vendor.c
+      src/x86/uarch.c
+      src/x86/name.c
+      src/x86/topology.c
+      src/x86/isa.c
+      src/x86/cache/init.c
+      src/x86/cache/descriptor.c
+      src/x86/cache/deterministic.c)
+  ENDIF()
+ENDIF()
+
+IF(CPUINFO_SUPPORTED_PLATFORM AND NOT QNX)
   IF(NOT CMAKE_SYSTEM_NAME STREQUAL "Emscripten" AND (CPUINFO_TARGET_PROCESSOR MATCHES "^(i[3-6]86|AMD64|x86(_64)?)$" OR IOS_ARCH MATCHES "^(i386|x86_64)$"))
     LIST(APPEND CPUINFO_SRCS
       src/x86/init.c
@@ -250,6 +270,9 @@ IF(CPUINFO_SUPPORTED_PLATFORM)
   ENDIF()
 ENDIF()
 
+IF(QNX)
+  SET(CPUINFO_LIBRARY_TYPE "static")
+ENDIF()
 IF(CPUINFO_LIBRARY_TYPE STREQUAL "default")
   ADD_LIBRARY(cpuinfo ${CPUINFO_SRCS})
 ELSEIF(CPUINFO_LIBRARY_TYPE STREQUAL "shared")
@@ -807,7 +830,7 @@ IF(CPUINFO_SUPPORTED_PLATFORM AND CPUINFO_BUILD_MOCK_TESTS)
 ENDIF()
 
 # ---[ cpuinfo unit tests
-IF(CPUINFO_SUPPORTED_PLATFORM AND CPUINFO_BUILD_UNIT_TESTS)
+IF(CPUINFO_SUPPORTED_PLATFORM AND CPUINFO_BUILD_UNIT_TESTS AND NOT QNX)
   ADD_EXECUTABLE(init-test test/init.cc)
   CPUINFO_TARGET_ENABLE_CXX11(init-test)
   CPUINFO_TARGET_RUNTIME_LIBRARY(init-test)
@@ -830,7 +853,7 @@ IF(CPUINFO_SUPPORTED_PLATFORM AND CPUINFO_BUILD_UNIT_TESTS)
     ADD_TEST(NAME brand-string-test COMMAND brand-string-test)
   ENDIF()
 
-  IF(CMAKE_SYSTEM_NAME STREQUAL "Android" AND CMAKE_SYSTEM_PROCESSOR MATCHES "^(armv[5-8].*|aarch64)$")
+  IF(CMAKE_SYSTEM_NAME MATCHES "Android|QNX" AND CMAKE_SYSTEM_PROCESSOR MATCHES "^(armv[5-8].*|aarch64)$")
     ADD_LIBRARY(android_properties_interface STATIC test/name/android-properties-interface.c)
     CPUINFO_TARGET_ENABLE_C99(android_properties_interface)
     CPUINFO_TARGET_RUNTIME_LIBRARY(android_properties_interface)
diff --git a/include/cpuinfo.h b/include/cpuinfo.h
index 387611c..fe8b9d0 100644
--- a/include/cpuinfo.h
+++ b/include/cpuinfo.h
@@ -3,18 +3,18 @@
 #define CPUINFO_H
 
 #ifndef __cplusplus
-#include <stdbool.h>
+	#include <stdbool.h>
 #endif
 
 #ifdef __APPLE__
-#include <TargetConditionals.h>
+	#include <TargetConditionals.h>
 #endif
 
 #include <stdint.h>
 
 /* Identify architecture and define corresponding macro */
 
-#if defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__) || defined(_M_IX86)
+#if defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__) || defined(_M_IX86) || defined(__X86__)
 #define CPUINFO_ARCH_X86 1
 #endif
 
@@ -22,7 +22,7 @@
 #define CPUINFO_ARCH_X86_64 1
 #endif
 
-#if defined(__arm__) || defined(_M_ARM)
+#if defined(__arm__) || defined(_M_ARM) || defined(__ARM__)
 #define CPUINFO_ARCH_ARM 1
 #endif
 
@@ -120,11 +120,9 @@ struct cpuinfo_cache {
 	/** Line size in bytes */
 	uint32_t line_size;
 	/**
-	 * Binary characteristics of the cache (unified cache, inclusive cache,
-	 * cache with complex indexing).
+	 * Binary characteristics of the cache (unified cache, inclusive cache, cache with complex indexing).
 	 *
-	 * @see CPUINFO_CACHE_UNIFIED, CPUINFO_CACHE_INCLUSIVE,
-	 * CPUINFO_CACHE_COMPLEX_INDEXING
+	 * @see CPUINFO_CACHE_UNIFIED, CPUINFO_CACHE_INCLUSIVE, CPUINFO_CACHE_COMPLEX_INDEXING
 	 */
 	uint32_t flags;
 	/** Index of the first logical processor that shares this cache */
@@ -153,95 +151,72 @@ struct cpuinfo_tlb {
 
 /** Vendor of processor core design */
 enum cpuinfo_vendor {
-	/** Processor vendor is not known to the library, or the library failed
-	   to get vendor information from the OS. */
+	/** Processor vendor is not known to the library, or the library failed to get vendor information from the OS. */
 	cpuinfo_vendor_unknown = 0,
 
 	/* Active vendors of modern CPUs */
 
 	/**
-	 * Intel Corporation. Vendor of x86, x86-64, IA64, and ARM processor
-	 * microarchitectures.
+	 * Intel Corporation. Vendor of x86, x86-64, IA64, and ARM processor microarchitectures.
 	 *
-	 * Sold its ARM design subsidiary in 2006. The last ARM processor design
-	 * was released in 2004.
+	 * Sold its ARM design subsidiary in 2006. The last ARM processor design was released in 2004.
 	 */
-	cpuinfo_vendor_intel = 1,
-	/** Advanced Micro Devices, Inc. Vendor of x86 and x86-64 processor
-	   microarchitectures. */
-	cpuinfo_vendor_amd = 2,
-	/** ARM Holdings plc. Vendor of ARM and ARM64 processor
-	   microarchitectures. */
-	cpuinfo_vendor_arm = 3,
-	/** Qualcomm Incorporated. Vendor of ARM and ARM64 processor
-	   microarchitectures. */
+	cpuinfo_vendor_intel    = 1,
+	/** Advanced Micro Devices, Inc. Vendor of x86 and x86-64 processor microarchitectures. */
+	cpuinfo_vendor_amd      = 2,
+	/** ARM Holdings plc. Vendor of ARM and ARM64 processor microarchitectures. */
+	cpuinfo_vendor_arm      = 3,
+	/** Qualcomm Incorporated. Vendor of ARM and ARM64 processor microarchitectures. */
 	cpuinfo_vendor_qualcomm = 4,
 	/** Apple Inc. Vendor of ARM and ARM64 processor microarchitectures. */
-	cpuinfo_vendor_apple = 5,
-	/** Samsung Electronics Co., Ltd. Vendir if ARM64 processor
-	   microarchitectures. */
-	cpuinfo_vendor_samsung = 6,
-	/** Nvidia Corporation. Vendor of ARM64-compatible processor
-	   microarchitectures. */
-	cpuinfo_vendor_nvidia = 7,
-	/** MIPS Technologies, Inc. Vendor of MIPS processor microarchitectures.
-	 */
-	cpuinfo_vendor_mips = 8,
-	/** International Business Machines Corporation. Vendor of PowerPC
-	   processor microarchitectures. */
-	cpuinfo_vendor_ibm = 9,
-	/** Ingenic Semiconductor. Vendor of MIPS processor microarchitectures.
-	 */
-	cpuinfo_vendor_ingenic = 10,
+	cpuinfo_vendor_apple    = 5,
+	/** Samsung Electronics Co., Ltd. Vendir if ARM64 processor microarchitectures. */
+	cpuinfo_vendor_samsung  = 6,
+	/** Nvidia Corporation. Vendor of ARM64-compatible processor microarchitectures. */
+	cpuinfo_vendor_nvidia   = 7,
+	/** MIPS Technologies, Inc. Vendor of MIPS processor microarchitectures. */
+	cpuinfo_vendor_mips     = 8,
+	/** International Business Machines Corporation. Vendor of PowerPC processor microarchitectures. */
+	cpuinfo_vendor_ibm      = 9,
+	/** Ingenic Semiconductor. Vendor of MIPS processor microarchitectures. */
+	cpuinfo_vendor_ingenic  = 10,
 	/**
-	 * VIA Technologies, Inc. Vendor of x86 and x86-64 processor
-	 * microarchitectures.
+	 * VIA Technologies, Inc. Vendor of x86 and x86-64 processor microarchitectures.
 	 *
-	 * Processors are designed by Centaur Technology, a subsidiary of VIA
-	 * Technologies.
+	 * Processors are designed by Centaur Technology, a subsidiary of VIA Technologies.
 	 */
-	cpuinfo_vendor_via = 11,
+	cpuinfo_vendor_via      = 11,
 	/** Cavium, Inc. Vendor of ARM64 processor microarchitectures. */
-	cpuinfo_vendor_cavium = 12,
+	cpuinfo_vendor_cavium   = 12,
 	/** Broadcom, Inc. Vendor of ARM processor microarchitectures. */
 	cpuinfo_vendor_broadcom = 13,
-	/** Applied Micro Circuits Corporation (APM). Vendor of ARM64 processor
-	   microarchitectures. */
-	cpuinfo_vendor_apm = 14,
+	/** Applied Micro Circuits Corporation (APM). Vendor of ARM64 processor microarchitectures. */
+	cpuinfo_vendor_apm      = 14,
 	/**
-	 * Huawei Technologies Co., Ltd. Vendor of ARM64 processor
-	 * microarchitectures.
+	 * Huawei Technologies Co., Ltd. Vendor of ARM64 processor microarchitectures.
 	 *
 	 * Processors are designed by HiSilicon, a subsidiary of Huawei.
 	 */
-	cpuinfo_vendor_huawei = 15,
+	cpuinfo_vendor_huawei   = 15,
 	/**
-	 * Hygon (Chengdu Haiguang Integrated Circuit Design Co., Ltd), Vendor
-	 * of x86-64 processor microarchitectures.
+	 * Hygon (Chengdu Haiguang Integrated Circuit Design Co., Ltd), Vendor of x86-64 processor microarchitectures.
 	 *
 	 * Processors are variants of AMD cores.
 	 */
-	cpuinfo_vendor_hygon = 16,
-	/** SiFive, Inc. Vendor of RISC-V processor microarchitectures. */
-	cpuinfo_vendor_sifive = 17,
+	cpuinfo_vendor_hygon    = 16,
 
 	/* Active vendors of embedded CPUs */
 
-	/** Texas Instruments Inc. Vendor of ARM processor microarchitectures.
-	 */
+	/** Texas Instruments Inc. Vendor of ARM processor microarchitectures. */
 	cpuinfo_vendor_texas_instruments = 30,
-	/** Marvell Technology Group Ltd. Vendor of ARM processor
-	 * microarchitectures.
-	 */
-	cpuinfo_vendor_marvell = 31,
-	/** RDC Semiconductor Co., Ltd. Vendor of x86 processor
-	   microarchitectures. */
-	cpuinfo_vendor_rdc = 32,
+	/** Marvell Technology Group Ltd. Vendor of ARM processor microarchitectures. */
+	cpuinfo_vendor_marvell           = 31,
+	/** RDC Semiconductor Co., Ltd. Vendor of x86 processor microarchitectures. */
+	cpuinfo_vendor_rdc               = 32,
 	/** DM&P Electronics Inc. Vendor of x86 processor microarchitectures. */
-	cpuinfo_vendor_dmp = 33,
-	/** Motorola, Inc. Vendor of PowerPC and ARM processor
-	   microarchitectures. */
-	cpuinfo_vendor_motorola = 34,
+	cpuinfo_vendor_dmp               = 33,
+	/** Motorola, Inc. Vendor of PowerPC and ARM processor microarchitectures. */
+	cpuinfo_vendor_motorola          = 34,
 
 	/* Defunct CPU vendors */
 
@@ -249,8 +224,7 @@ enum cpuinfo_vendor {
 	 * Transmeta Corporation. Vendor of x86 processor microarchitectures.
 	 *
 	 * Now defunct. The last processor design was released in 2004.
-	 * Transmeta processors implemented VLIW ISA and used binary translation
-	 * to execute x86 code.
+	 * Transmeta processors implemented VLIW ISA and used binary translation to execute x86 code.
 	 */
 	cpuinfo_vendor_transmeta = 50,
 	/**
@@ -258,144 +232,133 @@ enum cpuinfo_vendor {
 	 *
 	 * Now defunct. The last processor design was released in 1996.
 	 */
-	cpuinfo_vendor_cyrix = 51,
+	cpuinfo_vendor_cyrix     = 51,
 	/**
 	 * Rise Technology. Vendor of x86 processor microarchitectures.
 	 *
 	 * Now defunct. The last processor design was released in 1999.
 	 */
-	cpuinfo_vendor_rise = 52,
+	cpuinfo_vendor_rise      = 52,
 	/**
 	 * National Semiconductor. Vendor of x86 processor microarchitectures.
 	 *
-	 * Sold its x86 design subsidiary in 1999. The last processor design was
-	 * released in 1998.
+	 * Sold its x86 design subsidiary in 1999. The last processor design was released in 1998.
 	 */
-	cpuinfo_vendor_nsc = 53,
+	cpuinfo_vendor_nsc       = 53,
 	/**
-	 * Silicon Integrated Systems. Vendor of x86 processor
-	 * microarchitectures.
+	 * Silicon Integrated Systems. Vendor of x86 processor microarchitectures.
 	 *
-	 * Sold its x86 design subsidiary in 2001. The last processor design was
-	 * released in 2001.
+	 * Sold its x86 design subsidiary in 2001. The last processor design was released in 2001.
 	 */
-	cpuinfo_vendor_sis = 54,
+	cpuinfo_vendor_sis       = 54,
 	/**
 	 * NexGen. Vendor of x86 processor microarchitectures.
 	 *
 	 * Now defunct. The last processor design was released in 1994.
-	 * NexGen designed the first x86 microarchitecture which decomposed x86
-	 * instructions into simple microoperations.
+	 * NexGen designed the first x86 microarchitecture which decomposed x86 instructions into simple microoperations.
 	 */
-	cpuinfo_vendor_nexgen = 55,
+	cpuinfo_vendor_nexgen    = 55,
 	/**
-	 * United Microelectronics Corporation. Vendor of x86 processor
-	 * microarchitectures.
+	 * United Microelectronics Corporation. Vendor of x86 processor microarchitectures.
 	 *
-	 * Ceased x86 in the early 1990s. The last processor design was released
-	 * in 1991. Designed U5C and U5D processors. Both are 486 level.
+	 * Ceased x86 in the early 1990s. The last processor design was released in 1991.
+	 * Designed U5C and U5D processors. Both are 486 level.
 	 */
-	cpuinfo_vendor_umc = 56,
+	cpuinfo_vendor_umc       = 56,
 	/**
-	 * Digital Equipment Corporation. Vendor of ARM processor
-	 * microarchitecture.
+	 * Digital Equipment Corporation. Vendor of ARM processor microarchitecture.
 	 *
-	 * Sold its ARM designs in 1997. The last processor design was released
-	 * in 1997.
+	 * Sold its ARM designs in 1997. The last processor design was released in 1997.
 	 */
-	cpuinfo_vendor_dec = 57,
+	cpuinfo_vendor_dec       = 57,
 };
 
 /**
  * Processor microarchitecture
  *
- * Processors with different microarchitectures often have different instruction
- * performance characteristics, and may have dramatically different pipeline
- * organization.
+ * Processors with different microarchitectures often have different instruction performance characteristics,
+ * and may have dramatically different pipeline organization.
  */
 enum cpuinfo_uarch {
-	/** Microarchitecture is unknown, or the library failed to get
-	   information about the microarchitecture from OS */
+	/** Microarchitecture is unknown, or the library failed to get information about the microarchitecture from OS */
 	cpuinfo_uarch_unknown = 0,
 
 	/** Pentium and Pentium MMX microarchitecture. */
-	cpuinfo_uarch_p5 = 0x00100100,
+	cpuinfo_uarch_p5    = 0x00100100,
 	/** Intel Quark microarchitecture. */
 	cpuinfo_uarch_quark = 0x00100101,
 
 	/** Pentium Pro, Pentium II, and Pentium III. */
-	cpuinfo_uarch_p6 = 0x00100200,
+	cpuinfo_uarch_p6           = 0x00100200,
 	/** Pentium M. */
-	cpuinfo_uarch_dothan = 0x00100201,
+	cpuinfo_uarch_dothan       = 0x00100201,
 	/** Intel Core microarchitecture. */
-	cpuinfo_uarch_yonah = 0x00100202,
+	cpuinfo_uarch_yonah        = 0x00100202,
 	/** Intel Core 2 microarchitecture on 65 nm process. */
-	cpuinfo_uarch_conroe = 0x00100203,
+	cpuinfo_uarch_conroe       = 0x00100203,
 	/** Intel Core 2 microarchitecture on 45 nm process. */
-	cpuinfo_uarch_penryn = 0x00100204,
-	/** Intel Nehalem and Westmere microarchitectures (Core i3/i5/i7 1st
-	   gen). */
-	cpuinfo_uarch_nehalem = 0x00100205,
+	cpuinfo_uarch_penryn       = 0x00100204,
+	/** Intel Nehalem and Westmere microarchitectures (Core i3/i5/i7 1st gen). */
+	cpuinfo_uarch_nehalem      = 0x00100205,
 	/** Intel Sandy Bridge microarchitecture (Core i3/i5/i7 2nd gen). */
 	cpuinfo_uarch_sandy_bridge = 0x00100206,
 	/** Intel Ivy Bridge microarchitecture (Core i3/i5/i7 3rd gen). */
-	cpuinfo_uarch_ivy_bridge = 0x00100207,
+	cpuinfo_uarch_ivy_bridge   = 0x00100207,
 	/** Intel Haswell microarchitecture (Core i3/i5/i7 4th gen). */
-	cpuinfo_uarch_haswell = 0x00100208,
+	cpuinfo_uarch_haswell      = 0x00100208,
 	/** Intel Broadwell microarchitecture. */
-	cpuinfo_uarch_broadwell = 0x00100209,
-	/** Intel Sky Lake microarchitecture (14 nm, including
-	   Kaby/Coffee/Whiskey/Amber/Comet/Cascade/Cooper Lake). */
-	cpuinfo_uarch_sky_lake = 0x0010020A,
+	cpuinfo_uarch_broadwell    = 0x00100209,
+	/** Intel Sky Lake microarchitecture (14 nm, including Kaby/Coffee/Whiskey/Amber/Comet/Cascade/Cooper Lake). */
+	cpuinfo_uarch_sky_lake     = 0x0010020A,
 	/** DEPRECATED (Intel Kaby Lake microarchitecture). */
-	cpuinfo_uarch_kaby_lake = 0x0010020A,
+	cpuinfo_uarch_kaby_lake    = 0x0010020A,
 	/** Intel Palm Cove microarchitecture (10 nm, Cannon Lake). */
-	cpuinfo_uarch_palm_cove = 0x0010020B,
+	cpuinfo_uarch_palm_cove    = 0x0010020B,
 	/** Intel Sunny Cove microarchitecture (10 nm, Ice Lake). */
-	cpuinfo_uarch_sunny_cove = 0x0010020C,
+	cpuinfo_uarch_sunny_cove   = 0x0010020C,
 
 	/** Pentium 4 with Willamette, Northwood, or Foster cores. */
 	cpuinfo_uarch_willamette = 0x00100300,
 	/** Pentium 4 with Prescott and later cores. */
-	cpuinfo_uarch_prescott = 0x00100301,
+	cpuinfo_uarch_prescott   = 0x00100301,
 
 	/** Intel Atom on 45 nm process. */
-	cpuinfo_uarch_bonnell = 0x00100400,
+	cpuinfo_uarch_bonnell       = 0x00100400,
 	/** Intel Atom on 32 nm process. */
-	cpuinfo_uarch_saltwell = 0x00100401,
+	cpuinfo_uarch_saltwell      = 0x00100401,
 	/** Intel Silvermont microarchitecture (22 nm out-of-order Atom). */
-	cpuinfo_uarch_silvermont = 0x00100402,
+	cpuinfo_uarch_silvermont    = 0x00100402,
 	/** Intel Airmont microarchitecture (14 nm out-of-order Atom). */
-	cpuinfo_uarch_airmont = 0x00100403,
+	cpuinfo_uarch_airmont       = 0x00100403,
 	/** Intel Goldmont microarchitecture (Denverton, Apollo Lake). */
-	cpuinfo_uarch_goldmont = 0x00100404,
+	cpuinfo_uarch_goldmont      = 0x00100404,
 	/** Intel Goldmont Plus microarchitecture (Gemini Lake). */
 	cpuinfo_uarch_goldmont_plus = 0x00100405,
 
 	/** Intel Knights Ferry HPC boards. */
-	cpuinfo_uarch_knights_ferry = 0x00100500,
+	cpuinfo_uarch_knights_ferry   = 0x00100500,
 	/** Intel Knights Corner HPC boards (aka Xeon Phi). */
-	cpuinfo_uarch_knights_corner = 0x00100501,
+	cpuinfo_uarch_knights_corner  = 0x00100501,
 	/** Intel Knights Landing microarchitecture (second-gen MIC). */
 	cpuinfo_uarch_knights_landing = 0x00100502,
 	/** Intel Knights Hill microarchitecture (third-gen MIC). */
-	cpuinfo_uarch_knights_hill = 0x00100503,
+	cpuinfo_uarch_knights_hill    = 0x00100503,
 	/** Intel Knights Mill Xeon Phi. */
-	cpuinfo_uarch_knights_mill = 0x00100504,
+	cpuinfo_uarch_knights_mill    = 0x00100504,
 
 	/** Intel/Marvell XScale series. */
 	cpuinfo_uarch_xscale = 0x00100600,
 
 	/** AMD K5. */
-	cpuinfo_uarch_k5 = 0x00200100,
+	cpuinfo_uarch_k5        = 0x00200100,
 	/** AMD K6 and alike. */
-	cpuinfo_uarch_k6 = 0x00200101,
+	cpuinfo_uarch_k6        = 0x00200101,
 	/** AMD Athlon and Duron. */
-	cpuinfo_uarch_k7 = 0x00200102,
+	cpuinfo_uarch_k7        = 0x00200102,
 	/** AMD Athlon 64, Opteron 64. */
-	cpuinfo_uarch_k8 = 0x00200103,
+	cpuinfo_uarch_k8        = 0x00200103,
 	/** AMD Family 10h (Barcelona, Istambul, Magny-Cours). */
-	cpuinfo_uarch_k10 = 0x00200104,
+	cpuinfo_uarch_k10       = 0x00200104,
 	/**
 	 * AMD Bulldozer microarchitecture
 	 * Zambezi FX-series CPUs, Zurich, Valencia and Interlagos Opteron CPUs.
@@ -403,47 +366,46 @@ enum cpuinfo_uarch {
 	cpuinfo_uarch_bulldozer = 0x00200105,
 	/**
 	 * AMD Piledriver microarchitecture
-	 * Vishera FX-series CPUs, Trinity and Richland APUs, Delhi, Seoul, Abu
-	 * Dhabi Opteron CPUs.
+	 * Vishera FX-series CPUs, Trinity and Richland APUs, Delhi, Seoul, Abu Dhabi Opteron CPUs.
 	 */
-	cpuinfo_uarch_piledriver = 0x00200106,
+	cpuinfo_uarch_piledriver  = 0x00200106,
 	/** AMD Steamroller microarchitecture (Kaveri APUs). */
 	cpuinfo_uarch_steamroller = 0x00200107,
 	/** AMD Excavator microarchitecture (Carizzo APUs). */
-	cpuinfo_uarch_excavator = 0x00200108,
+	cpuinfo_uarch_excavator   = 0x00200108,
 	/** AMD Zen microarchitecture (12/14 nm Ryzen and EPYC CPUs). */
-	cpuinfo_uarch_zen = 0x00200109,
+	cpuinfo_uarch_zen         = 0x00200109,
 	/** AMD Zen 2 microarchitecture (7 nm Ryzen and EPYC CPUs). */
-	cpuinfo_uarch_zen2 = 0x0020010A,
+	cpuinfo_uarch_zen2        = 0x0020010A,
 	/** AMD Zen 3 microarchitecture. */
-	cpuinfo_uarch_zen3 = 0x0020010B,
+	cpuinfo_uarch_zen3        = 0x0020010B,
 	/** AMD Zen 4 microarchitecture. */
-	cpuinfo_uarch_zen4 = 0x0020010C,
+	cpuinfo_uarch_zen4        = 0x0020010C,
 
 	/** NSC Geode and AMD Geode GX and LX. */
-	cpuinfo_uarch_geode = 0x00200200,
+	cpuinfo_uarch_geode  = 0x00200200,
 	/** AMD Bobcat mobile microarchitecture. */
 	cpuinfo_uarch_bobcat = 0x00200201,
 	/** AMD Jaguar mobile microarchitecture. */
 	cpuinfo_uarch_jaguar = 0x00200202,
 	/** AMD Puma mobile microarchitecture. */
-	cpuinfo_uarch_puma = 0x00200203,
+	cpuinfo_uarch_puma   = 0x00200203,
 
 	/** ARM7 series. */
-	cpuinfo_uarch_arm7 = 0x00300100,
+	cpuinfo_uarch_arm7  = 0x00300100,
 	/** ARM9 series. */
-	cpuinfo_uarch_arm9 = 0x00300101,
+	cpuinfo_uarch_arm9  = 0x00300101,
 	/** ARM 1136, ARM 1156, ARM 1176, or ARM 11MPCore. */
 	cpuinfo_uarch_arm11 = 0x00300102,
 
 	/** ARM Cortex-A5. */
-	cpuinfo_uarch_cortex_a5 = 0x00300205,
+	cpuinfo_uarch_cortex_a5  = 0x00300205,
 	/** ARM Cortex-A7. */
-	cpuinfo_uarch_cortex_a7 = 0x00300207,
+	cpuinfo_uarch_cortex_a7  = 0x00300207,
 	/** ARM Cortex-A8. */
-	cpuinfo_uarch_cortex_a8 = 0x00300208,
+	cpuinfo_uarch_cortex_a8  = 0x00300208,
 	/** ARM Cortex-A9. */
-	cpuinfo_uarch_cortex_a9 = 0x00300209,
+	cpuinfo_uarch_cortex_a9  = 0x00300209,
 	/** ARM Cortex-A12. */
 	cpuinfo_uarch_cortex_a12 = 0x00300212,
 	/** ARM Cortex-A15. */
@@ -452,131 +414,124 @@ enum cpuinfo_uarch {
 	cpuinfo_uarch_cortex_a17 = 0x00300217,
 
 	/** ARM Cortex-A32. */
-	cpuinfo_uarch_cortex_a32 = 0x00300332,
+	cpuinfo_uarch_cortex_a32   = 0x00300332,
 	/** ARM Cortex-A35. */
-	cpuinfo_uarch_cortex_a35 = 0x00300335,
+	cpuinfo_uarch_cortex_a35   = 0x00300335,
 	/** ARM Cortex-A53. */
-	cpuinfo_uarch_cortex_a53 = 0x00300353,
-	/** ARM Cortex-A55 revision 0 (restricted dual-issue capabilities
-	   compared to revision 1+). */
+	cpuinfo_uarch_cortex_a53   = 0x00300353,
+	/** ARM Cortex-A55 revision 0 (restricted dual-issue capabilities compared to revision 1+). */
 	cpuinfo_uarch_cortex_a55r0 = 0x00300354,
 	/** ARM Cortex-A55. */
-	cpuinfo_uarch_cortex_a55 = 0x00300355,
+	cpuinfo_uarch_cortex_a55   = 0x00300355,
 	/** ARM Cortex-A57. */
-	cpuinfo_uarch_cortex_a57 = 0x00300357,
+	cpuinfo_uarch_cortex_a57   = 0x00300357,
 	/** ARM Cortex-A65. */
-	cpuinfo_uarch_cortex_a65 = 0x00300365,
+	cpuinfo_uarch_cortex_a65   = 0x00300365,
 	/** ARM Cortex-A72. */
-	cpuinfo_uarch_cortex_a72 = 0x00300372,
+	cpuinfo_uarch_cortex_a72   = 0x00300372,
 	/** ARM Cortex-A73. */
-	cpuinfo_uarch_cortex_a73 = 0x00300373,
+	cpuinfo_uarch_cortex_a73   = 0x00300373,
 	/** ARM Cortex-A75. */
-	cpuinfo_uarch_cortex_a75 = 0x00300375,
+	cpuinfo_uarch_cortex_a75   = 0x00300375,
 	/** ARM Cortex-A76. */
-	cpuinfo_uarch_cortex_a76 = 0x00300376,
+	cpuinfo_uarch_cortex_a76   = 0x00300376,
 	/** ARM Cortex-A77. */
-	cpuinfo_uarch_cortex_a77 = 0x00300377,
+	cpuinfo_uarch_cortex_a77   = 0x00300377,
 	/** ARM Cortex-A78. */
-	cpuinfo_uarch_cortex_a78 = 0x00300378,
+	cpuinfo_uarch_cortex_a78   = 0x00300378,
 
 	/** ARM Neoverse N1. */
-	cpuinfo_uarch_neoverse_n1 = 0x00300400,
+	cpuinfo_uarch_neoverse_n1  = 0x00300400,
 	/** ARM Neoverse E1. */
-	cpuinfo_uarch_neoverse_e1 = 0x00300401,
+	cpuinfo_uarch_neoverse_e1  = 0x00300401,
 	/** ARM Neoverse V1. */
-	cpuinfo_uarch_neoverse_v1 = 0x00300402,
+	cpuinfo_uarch_neoverse_v1  = 0x00300402,
 	/** ARM Neoverse N2. */
-	cpuinfo_uarch_neoverse_n2 = 0x00300403,
+	cpuinfo_uarch_neoverse_n2  = 0x00300403,
 	/** ARM Neoverse V2. */
-	cpuinfo_uarch_neoverse_v2 = 0x00300404,
+	cpuinfo_uarch_neoverse_v2  = 0x00300404,
 
 	/** ARM Cortex-X1. */
-	cpuinfo_uarch_cortex_x1 = 0x00300501,
+	cpuinfo_uarch_cortex_x1    = 0x00300501,
 	/** ARM Cortex-X2. */
-	cpuinfo_uarch_cortex_x2 = 0x00300502,
+	cpuinfo_uarch_cortex_x2    = 0x00300502,
 	/** ARM Cortex-X3. */
-	cpuinfo_uarch_cortex_x3 = 0x00300503,
-	/** ARM Cortex-X4. */
-	cpuinfo_uarch_cortex_x4 = 0x00300504,
+	cpuinfo_uarch_cortex_x3    = 0x00300503,
 
 	/** ARM Cortex-A510. */
-	cpuinfo_uarch_cortex_a510 = 0x00300551,
-	/** ARM Cortex-A520. */
-	cpuinfo_uarch_cortex_a520 = 0x00300552,
+	cpuinfo_uarch_cortex_a510  = 0x00300551,
 	/** ARM Cortex-A710. */
-	cpuinfo_uarch_cortex_a710 = 0x00300571,
+	cpuinfo_uarch_cortex_a710  = 0x00300571,
 	/** ARM Cortex-A715. */
-	cpuinfo_uarch_cortex_a715 = 0x00300572,
-	/** ARM Cortex-A720. */
-	cpuinfo_uarch_cortex_a720 = 0x00300573,
+	cpuinfo_uarch_cortex_a715  = 0x00300572,
 
 	/** Qualcomm Scorpion. */
 	cpuinfo_uarch_scorpion = 0x00400100,
 	/** Qualcomm Krait. */
-	cpuinfo_uarch_krait = 0x00400101,
+	cpuinfo_uarch_krait    = 0x00400101,
 	/** Qualcomm Kryo. */
-	cpuinfo_uarch_kryo = 0x00400102,
+	cpuinfo_uarch_kryo     = 0x00400102,
 	/** Qualcomm Falkor. */
-	cpuinfo_uarch_falkor = 0x00400103,
+	cpuinfo_uarch_falkor   = 0x00400103,
 	/** Qualcomm Saphira. */
-	cpuinfo_uarch_saphira = 0x00400104,
+	cpuinfo_uarch_saphira  = 0x00400104,
 
 	/** Nvidia Denver. */
-	cpuinfo_uarch_denver = 0x00500100,
+	cpuinfo_uarch_denver   = 0x00500100,
 	/** Nvidia Denver 2. */
-	cpuinfo_uarch_denver2 = 0x00500101,
+	cpuinfo_uarch_denver2  = 0x00500101,
 	/** Nvidia Carmel. */
-	cpuinfo_uarch_carmel = 0x00500102,
+	cpuinfo_uarch_carmel   = 0x00500102,
 
 	/** Samsung Exynos M1 (Exynos 8890 big cores). */
 	cpuinfo_uarch_exynos_m1 = 0x00600100,
 	/** Samsung Exynos M2 (Exynos 8895 big cores). */
 	cpuinfo_uarch_exynos_m2 = 0x00600101,
 	/** Samsung Exynos M3 (Exynos 9810 big cores). */
-	cpuinfo_uarch_exynos_m3 = 0x00600102,
+	cpuinfo_uarch_exynos_m3  = 0x00600102,
 	/** Samsung Exynos M4 (Exynos 9820 big cores). */
-	cpuinfo_uarch_exynos_m4 = 0x00600103,
+	cpuinfo_uarch_exynos_m4  = 0x00600103,
 	/** Samsung Exynos M5 (Exynos 9830 big cores). */
-	cpuinfo_uarch_exynos_m5 = 0x00600104,
+	cpuinfo_uarch_exynos_m5  = 0x00600104,
 
 	/* Deprecated synonym for Cortex-A76 */
 	cpuinfo_uarch_cortex_a76ae = 0x00300376,
 	/* Deprecated names for Exynos. */
 	cpuinfo_uarch_mongoose_m1 = 0x00600100,
 	cpuinfo_uarch_mongoose_m2 = 0x00600101,
-	cpuinfo_uarch_meerkat_m3 = 0x00600102,
-	cpuinfo_uarch_meerkat_m4 = 0x00600103,
+	cpuinfo_uarch_meerkat_m3  = 0x00600102,
+	cpuinfo_uarch_meerkat_m4  = 0x00600103,
 
 	/** Apple A6 and A6X processors. */
-	cpuinfo_uarch_swift = 0x00700100,
+	cpuinfo_uarch_swift     = 0x00700100,
 	/** Apple A7 processor. */
-	cpuinfo_uarch_cyclone = 0x00700101,
+	cpuinfo_uarch_cyclone   = 0x00700101,
 	/** Apple A8 and A8X processor. */
-	cpuinfo_uarch_typhoon = 0x00700102,
+	cpuinfo_uarch_typhoon   = 0x00700102,
 	/** Apple A9 and A9X processor. */
-	cpuinfo_uarch_twister = 0x00700103,
+	cpuinfo_uarch_twister   = 0x00700103,
 	/** Apple A10 and A10X processor. */
 	cpuinfo_uarch_hurricane = 0x00700104,
 	/** Apple A11 processor (big cores). */
-	cpuinfo_uarch_monsoon = 0x00700105,
+	cpuinfo_uarch_monsoon   = 0x00700105,
 	/** Apple A11 processor (little cores). */
-	cpuinfo_uarch_mistral = 0x00700106,
+	cpuinfo_uarch_mistral   = 0x00700106,
 	/** Apple A12 processor (big cores). */
-	cpuinfo_uarch_vortex = 0x00700107,
+	cpuinfo_uarch_vortex    = 0x00700107,
 	/** Apple A12 processor (little cores). */
-	cpuinfo_uarch_tempest = 0x00700108,
+	cpuinfo_uarch_tempest   = 0x00700108,
 	/** Apple A13 processor (big cores). */
 	cpuinfo_uarch_lightning = 0x00700109,
 	/** Apple A13 processor (little cores). */
-	cpuinfo_uarch_thunder = 0x0070010A,
+	cpuinfo_uarch_thunder   = 0x0070010A,
 	/** Apple A14 / M1 processor (big cores). */
 	cpuinfo_uarch_firestorm = 0x0070010B,
 	/** Apple A14 / M1 processor (little cores). */
-	cpuinfo_uarch_icestorm = 0x0070010C,
+	cpuinfo_uarch_icestorm  = 0x0070010C,
 	/** Apple A15 / M2 processor (big cores). */
 	cpuinfo_uarch_avalanche = 0x0070010D,
 	/** Apple A15 / M2 processor (little cores). */
-	cpuinfo_uarch_blizzard = 0x0070010E,
+	cpuinfo_uarch_blizzard  = 0x0070010E,
 
 	/** Cavium ThunderX. */
 	cpuinfo_uarch_thunderx = 0x00800100,
@@ -613,20 +568,17 @@ struct cpuinfo_processor {
 #if defined(__linux__)
 	/**
 	 * Linux-specific ID for the logical processor:
-	 * - Linux kernel exposes information about this logical processor in
-	 * /sys/devices/system/cpu/cpu<linux_id>/
+	 * - Linux kernel exposes information about this logical processor in /sys/devices/system/cpu/cpu<linux_id>/
 	 * - Bit <linux_id> in the cpu_set_t identifies this logical processor
 	 */
 	int linux_id;
 #endif
 #if defined(_WIN32) || defined(__CYGWIN__)
-	/** Windows-specific ID for the group containing the logical processor.
-	 */
+	/** Windows-specific ID for the group containing the logical processor. */
 	uint16_t windows_group_id;
 	/**
 	 * Windows-specific ID of the logical processor within its group:
-	 * - Bit <windows_processor_id> in the KAFFINITY mask identifies this
-	 * logical processor within its group.
+	 * - Bit <windows_processor_id> in the KAFFINITY mask identifies this logical processor within its group.
 	 */
 	uint16_t windows_processor_id;
 #endif
@@ -865,30 +817,42 @@ struct cpuinfo_x86_isa {
 extern struct cpuinfo_x86_isa cpuinfo_isa;
 #endif
 
-static inline bool cpuinfo_has_x86_rdtsc(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.rdtsc;
-#endif
-#else
-	return false;
+#ifdef __QNXNTO__
+	#include <sys/neutrino.h>
+	#include <inttypes.h>
+	#include <stdio.h>
+	#include <stdlib.h>
+	#include <sys/syspage.h>
 #endif
+
+static inline bool cpuinfo_has_x86_rdtsc(void) {
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.rdtsc;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_rdtscp(void) {
 #if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & X86_64_CPU_RDTSC) != 0);
+#else
 	return cpuinfo_isa.rdtscp;
+#endif
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_x86_rdpid(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.rdpid;
 #else
 	return false;
@@ -896,7 +860,7 @@ static inline bool cpuinfo_has_x86_rdpid(void) {
 }
 
 static inline bool cpuinfo_has_x86_clzero(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.clzero;
 #else
 	return false;
@@ -904,7 +868,7 @@ static inline bool cpuinfo_has_x86_clzero(void) {
 }
 
 static inline bool cpuinfo_has_x86_mwait(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.mwait;
 #else
 	return false;
@@ -912,7 +876,7 @@ static inline bool cpuinfo_has_x86_mwait(void) {
 }
 
 static inline bool cpuinfo_has_x86_mwaitx(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.mwaitx;
 #else
 	return false;
@@ -921,7 +885,11 @@ static inline bool cpuinfo_has_x86_mwaitx(void) {
 
 static inline bool cpuinfo_has_x86_fxsave(void) {
 #if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & X86_64_CPU_FXSR) != 0);
+#else
 	return cpuinfo_isa.fxsave;
+#endif
 #else
 	return false;
 #endif
@@ -929,56 +897,60 @@ static inline bool cpuinfo_has_x86_fxsave(void) {
 
 static inline bool cpuinfo_has_x86_xsave(void) {
 #if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & X86_64_CPU_XSAVE) != 0);
+#else
 	return cpuinfo_isa.xsave;
+#endif
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_x86_fpu(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.fpu;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.fpu;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_mmx(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.mmx;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.mmx;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_mmx_plus(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.mmx_plus;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.mmx_plus;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_3dnow(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.three_d_now;
 #else
 	return false;
@@ -986,7 +958,7 @@ static inline bool cpuinfo_has_x86_3dnow(void) {
 }
 
 static inline bool cpuinfo_has_x86_3dnow_plus(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.three_d_now_plus;
 #else
 	return false;
@@ -994,21 +966,21 @@ static inline bool cpuinfo_has_x86_3dnow_plus(void) {
 }
 
 static inline bool cpuinfo_has_x86_3dnow_geode(void) {
-#if CPUINFO_ARCH_X86_64
-	return false;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return false;
-#else
-	return cpuinfo_isa.three_d_now_geode;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return false;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return false;
+		#else
+			return cpuinfo_isa.three_d_now_geode;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_prefetch(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.prefetch;
 #else
 	return false;
@@ -1016,7 +988,7 @@ static inline bool cpuinfo_has_x86_prefetch(void) {
 }
 
 static inline bool cpuinfo_has_x86_prefetchw(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.prefetchw;
 #else
 	return false;
@@ -1024,7 +996,7 @@ static inline bool cpuinfo_has_x86_prefetchw(void) {
 }
 
 static inline bool cpuinfo_has_x86_prefetchwt1(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.prefetchwt1;
 #else
 	return false;
@@ -1032,49 +1004,49 @@ static inline bool cpuinfo_has_x86_prefetchwt1(void) {
 }
 
 static inline bool cpuinfo_has_x86_daz(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.daz;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.daz;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_sse(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.sse;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.sse;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_sse2(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-#if defined(__ANDROID__)
-	return true;
-#else
-	return cpuinfo_isa.sse2;
-#endif
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		#if defined(__ANDROID__)
+			return true;
+		#else
+			return cpuinfo_isa.sse2;
+		#endif
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_sse3(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 #if defined(__ANDROID__)
 	return true;
 #else
@@ -1086,7 +1058,7 @@ static inline bool cpuinfo_has_x86_sse3(void) {
 }
 
 static inline bool cpuinfo_has_x86_ssse3(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 #if defined(__ANDROID__)
 	return true;
 #else
@@ -1098,7 +1070,7 @@ static inline bool cpuinfo_has_x86_ssse3(void) {
 }
 
 static inline bool cpuinfo_has_x86_sse4_1(void) {
-#if CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 #if defined(__ANDROID__)
 	return true;
 #else
@@ -1112,7 +1084,7 @@ static inline bool cpuinfo_has_x86_sse4_1(void) {
 }
 
 static inline bool cpuinfo_has_x86_sse4_2(void) {
-#if CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 #if defined(__ANDROID__)
 	return true;
 #else
@@ -1126,7 +1098,7 @@ static inline bool cpuinfo_has_x86_sse4_2(void) {
 }
 
 static inline bool cpuinfo_has_x86_sse4a(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.sse4a;
 #else
 	return false;
@@ -1134,7 +1106,7 @@ static inline bool cpuinfo_has_x86_sse4a(void) {
 }
 
 static inline bool cpuinfo_has_x86_misaligned_sse(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.misaligned_sse;
 #else
 	return false;
@@ -1143,14 +1115,18 @@ static inline bool cpuinfo_has_x86_misaligned_sse(void) {
 
 static inline bool cpuinfo_has_x86_avx(void) {
 #if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & X86_64_CPU_AVX) != 0);
+#else
 	return cpuinfo_isa.avx;
+#endif
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_x86_avxvnni(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avxvnni;
 #else
 	return false;
@@ -1158,15 +1134,17 @@ static inline bool cpuinfo_has_x86_avxvnni(void) {
 }
 
 static inline bool cpuinfo_has_x86_fma3(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.fma3;
+#elif defined(__QNXNTO__) && CPUINFO_ARCH_X86_64
+	return true;
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_x86_fma4(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.fma4;
 #else
 	return false;
@@ -1174,7 +1152,7 @@ static inline bool cpuinfo_has_x86_fma4(void) {
 }
 
 static inline bool cpuinfo_has_x86_xop(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.xop;
 #else
 	return false;
@@ -1182,7 +1160,7 @@ static inline bool cpuinfo_has_x86_xop(void) {
 }
 
 static inline bool cpuinfo_has_x86_f16c(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.f16c;
 #else
 	return false;
@@ -1190,15 +1168,17 @@ static inline bool cpuinfo_has_x86_f16c(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx2(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx2;
+#elif defined(__QNXNTO__) && CPUINFO_ARCH_X86_64
+	return true;
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_x86_avx512f(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512f;
 #else
 	return false;
@@ -1206,7 +1186,7 @@ static inline bool cpuinfo_has_x86_avx512f(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512pf(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512pf;
 #else
 	return false;
@@ -1214,7 +1194,7 @@ static inline bool cpuinfo_has_x86_avx512pf(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512er(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512er;
 #else
 	return false;
@@ -1222,7 +1202,7 @@ static inline bool cpuinfo_has_x86_avx512er(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512cd(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512cd;
 #else
 	return false;
@@ -1230,7 +1210,7 @@ static inline bool cpuinfo_has_x86_avx512cd(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512dq(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512dq;
 #else
 	return false;
@@ -1238,7 +1218,7 @@ static inline bool cpuinfo_has_x86_avx512dq(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512bw(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512bw;
 #else
 	return false;
@@ -1246,7 +1226,7 @@ static inline bool cpuinfo_has_x86_avx512bw(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vl(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vl;
 #else
 	return false;
@@ -1254,7 +1234,7 @@ static inline bool cpuinfo_has_x86_avx512vl(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512ifma(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512ifma;
 #else
 	return false;
@@ -1262,7 +1242,7 @@ static inline bool cpuinfo_has_x86_avx512ifma(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vbmi(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vbmi;
 #else
 	return false;
@@ -1270,7 +1250,7 @@ static inline bool cpuinfo_has_x86_avx512vbmi(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vbmi2(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vbmi2;
 #else
 	return false;
@@ -1278,7 +1258,7 @@ static inline bool cpuinfo_has_x86_avx512vbmi2(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512bitalg(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512bitalg;
 #else
 	return false;
@@ -1286,7 +1266,7 @@ static inline bool cpuinfo_has_x86_avx512bitalg(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vpopcntdq(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vpopcntdq;
 #else
 	return false;
@@ -1294,7 +1274,7 @@ static inline bool cpuinfo_has_x86_avx512vpopcntdq(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vnni(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vnni;
 #else
 	return false;
@@ -1302,7 +1282,7 @@ static inline bool cpuinfo_has_x86_avx512vnni(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512bf16(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512bf16;
 #else
 	return false;
@@ -1310,7 +1290,7 @@ static inline bool cpuinfo_has_x86_avx512bf16(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512fp16(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512fp16;
 #else
 	return false;
@@ -1318,7 +1298,7 @@ static inline bool cpuinfo_has_x86_avx512fp16(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512vp2intersect(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512vp2intersect;
 #else
 	return false;
@@ -1326,7 +1306,7 @@ static inline bool cpuinfo_has_x86_avx512vp2intersect(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512_4vnniw(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512_4vnniw;
 #else
 	return false;
@@ -1334,7 +1314,7 @@ static inline bool cpuinfo_has_x86_avx512_4vnniw(void) {
 }
 
 static inline bool cpuinfo_has_x86_avx512_4fmaps(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx512_4fmaps;
 #else
 	return false;
@@ -1362,7 +1342,7 @@ static inline bool cpuinfo_has_x86_avx512_4fmaps(void) {
  *    /accelerator-engines/advanced-matrix-extensions/overview.html
  */
 static inline bool cpuinfo_has_x86_amx_bf16(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.amx_bf16;
 #else
 	return false;
@@ -1370,7 +1350,7 @@ static inline bool cpuinfo_has_x86_amx_bf16(void) {
 }
 
 static inline bool cpuinfo_has_x86_amx_tile(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.amx_tile;
 #else
 	return false;
@@ -1378,7 +1358,7 @@ static inline bool cpuinfo_has_x86_amx_tile(void) {
 }
 
 static inline bool cpuinfo_has_x86_amx_int8(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.amx_int8;
 #else
 	return false;
@@ -1386,7 +1366,7 @@ static inline bool cpuinfo_has_x86_amx_int8(void) {
 }
 
 static inline bool cpuinfo_has_x86_amx_fp16(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.amx_fp16;
 #else
 	return false;
@@ -1398,7 +1378,7 @@ static inline bool cpuinfo_has_x86_amx_fp16(void) {
  * Supported Platfroms: Sierra Forest, Arrow Lake, Lunar Lake
  */
 static inline bool cpuinfo_has_x86_avx_vnni_int8(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx_vnni_int8;
 #else
 	return false;
@@ -1410,7 +1390,7 @@ static inline bool cpuinfo_has_x86_avx_vnni_int8(void) {
  * Supported Platfroms: Arrow Lake, Lunar Lake
  */
 static inline bool cpuinfo_has_x86_avx_vnni_int16(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx_vnni_int16;
 #else
 	return false;
@@ -1426,7 +1406,7 @@ static inline bool cpuinfo_has_x86_avx_vnni_int16(void) {
  * Supported Platforms: Sierra Forest, Arrow Lake, Lunar Lake
  */
 static inline bool cpuinfo_has_x86_avx_ne_convert(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.avx_ne_convert;
 #else
 	return false;
@@ -1434,7 +1414,7 @@ static inline bool cpuinfo_has_x86_avx_ne_convert(void) {
 }
 
 static inline bool cpuinfo_has_x86_hle(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.hle;
 #else
 	return false;
@@ -1442,7 +1422,7 @@ static inline bool cpuinfo_has_x86_hle(void) {
 }
 
 static inline bool cpuinfo_has_x86_rtm(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.rtm;
 #else
 	return false;
@@ -1450,7 +1430,7 @@ static inline bool cpuinfo_has_x86_rtm(void) {
 }
 
 static inline bool cpuinfo_has_x86_xtest(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.xtest;
 #else
 	return false;
@@ -1458,7 +1438,7 @@ static inline bool cpuinfo_has_x86_xtest(void) {
 }
 
 static inline bool cpuinfo_has_x86_mpx(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.mpx;
 #else
 	return false;
@@ -1466,27 +1446,27 @@ static inline bool cpuinfo_has_x86_mpx(void) {
 }
 
 static inline bool cpuinfo_has_x86_cmov(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-	return cpuinfo_isa.cmov;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		return cpuinfo_isa.cmov;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_cmpxchg8b(void) {
-#if CPUINFO_ARCH_X86_64
-	return true;
-#elif CPUINFO_ARCH_X86
-	return cpuinfo_isa.cmpxchg8b;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_X86_64
+		return true;
+	#elif CPUINFO_ARCH_X86
+		return cpuinfo_isa.cmpxchg8b;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_x86_cmpxchg16b(void) {
-#if CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.cmpxchg16b;
 #else
 	return false;
@@ -1494,7 +1474,7 @@ static inline bool cpuinfo_has_x86_cmpxchg16b(void) {
 }
 
 static inline bool cpuinfo_has_x86_clwb(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.clwb;
 #else
 	return false;
@@ -1502,7 +1482,7 @@ static inline bool cpuinfo_has_x86_clwb(void) {
 }
 
 static inline bool cpuinfo_has_x86_movbe(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.movbe;
 #else
 	return false;
@@ -1512,7 +1492,7 @@ static inline bool cpuinfo_has_x86_movbe(void) {
 static inline bool cpuinfo_has_x86_lahf_sahf(void) {
 #if CPUINFO_ARCH_X86
 	return true;
-#elif CPUINFO_ARCH_X86_64
+#elif CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.lahf_sahf;
 #else
 	return false;
@@ -1520,7 +1500,7 @@ static inline bool cpuinfo_has_x86_lahf_sahf(void) {
 }
 
 static inline bool cpuinfo_has_x86_lzcnt(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.lzcnt;
 #else
 	return false;
@@ -1528,7 +1508,7 @@ static inline bool cpuinfo_has_x86_lzcnt(void) {
 }
 
 static inline bool cpuinfo_has_x86_popcnt(void) {
-#if CPUINFO_ARCH_X86_64
+#if CPUINFO_ARCH_X86_64 && !defined(__QNXNTO__)
 #if defined(__ANDROID__)
 	return true;
 #else
@@ -1542,7 +1522,7 @@ static inline bool cpuinfo_has_x86_popcnt(void) {
 }
 
 static inline bool cpuinfo_has_x86_tbm(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.tbm;
 #else
 	return false;
@@ -1550,7 +1530,7 @@ static inline bool cpuinfo_has_x86_tbm(void) {
 }
 
 static inline bool cpuinfo_has_x86_bmi(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.bmi;
 #else
 	return false;
@@ -1558,7 +1538,7 @@ static inline bool cpuinfo_has_x86_bmi(void) {
 }
 
 static inline bool cpuinfo_has_x86_bmi2(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.bmi2;
 #else
 	return false;
@@ -1566,7 +1546,7 @@ static inline bool cpuinfo_has_x86_bmi2(void) {
 }
 
 static inline bool cpuinfo_has_x86_adx(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.adx;
 #else
 	return false;
@@ -1574,7 +1554,7 @@ static inline bool cpuinfo_has_x86_adx(void) {
 }
 
 static inline bool cpuinfo_has_x86_aes(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.aes;
 #else
 	return false;
@@ -1582,7 +1562,7 @@ static inline bool cpuinfo_has_x86_aes(void) {
 }
 
 static inline bool cpuinfo_has_x86_vaes(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.vaes;
 #else
 	return false;
@@ -1590,7 +1570,7 @@ static inline bool cpuinfo_has_x86_vaes(void) {
 }
 
 static inline bool cpuinfo_has_x86_pclmulqdq(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.pclmulqdq;
 #else
 	return false;
@@ -1598,7 +1578,7 @@ static inline bool cpuinfo_has_x86_pclmulqdq(void) {
 }
 
 static inline bool cpuinfo_has_x86_vpclmulqdq(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.vpclmulqdq;
 #else
 	return false;
@@ -1606,7 +1586,7 @@ static inline bool cpuinfo_has_x86_vpclmulqdq(void) {
 }
 
 static inline bool cpuinfo_has_x86_gfni(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.gfni;
 #else
 	return false;
@@ -1614,7 +1594,7 @@ static inline bool cpuinfo_has_x86_gfni(void) {
 }
 
 static inline bool cpuinfo_has_x86_rdrand(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.rdrand;
 #else
 	return false;
@@ -1622,7 +1602,7 @@ static inline bool cpuinfo_has_x86_rdrand(void) {
 }
 
 static inline bool cpuinfo_has_x86_rdseed(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.rdseed;
 #else
 	return false;
@@ -1630,7 +1610,7 @@ static inline bool cpuinfo_has_x86_rdseed(void) {
 }
 
 static inline bool cpuinfo_has_x86_sha(void) {
-#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+#if (CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.sha;
 #else
 	return false;
@@ -1697,31 +1677,35 @@ extern struct cpuinfo_arm_isa cpuinfo_isa;
 #endif
 
 static inline bool cpuinfo_has_arm_thumb(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.thumb;
+#elif defined(__QNXNTO__) && CPUINFO_ARCH_ARM
+	return true;
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_arm_thumb2(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.thumb2;
+#elif defined(__QNXNTO__) && CPUINFO_ARCH_ARM
+	return true;
 #else
 	return false;
 #endif
 }
 
 static inline bool cpuinfo_has_arm_v5e(void) {
-#if CPUINFO_ARCH_ARM
-	return cpuinfo_isa.armv5e;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_ARM
+		return cpuinfo_isa.armv5e;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_arm_v6(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.armv6;
 #else
 	return false;
@@ -1729,7 +1713,7 @@ static inline bool cpuinfo_has_arm_v6(void) {
 }
 
 static inline bool cpuinfo_has_arm_v6k(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.armv6k;
 #else
 	return false;
@@ -1738,7 +1722,11 @@ static inline bool cpuinfo_has_arm_v6k(void) {
 
 static inline bool cpuinfo_has_arm_v7(void) {
 #if CPUINFO_ARCH_ARM
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & ARM_CPU_FLAG_V7) != 0);
+#else
 	return cpuinfo_isa.armv7;
+#endif
 #else
 	return false;
 #endif
@@ -1746,7 +1734,11 @@ static inline bool cpuinfo_has_arm_v7(void) {
 
 static inline bool cpuinfo_has_arm_v7mp(void) {
 #if CPUINFO_ARCH_ARM
+#if defined(__QNXNTO__)
+	return ((SYSPAGE_ARRAY_IDX(cpuinfo,0)->flags & ARM_CPU_FLAG_V7_MP) != 0);
+#else
 	return cpuinfo_isa.armv7mp;
+#endif
 #else
 	return false;
 #endif
@@ -1755,7 +1747,7 @@ static inline bool cpuinfo_has_arm_v7mp(void) {
 static inline bool cpuinfo_has_arm_v8(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.armv8;
 #else
 	return false;
@@ -1765,7 +1757,7 @@ static inline bool cpuinfo_has_arm_v8(void) {
 static inline bool cpuinfo_has_arm_idiv(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.idiv;
 #else
 	return false;
@@ -1773,7 +1765,7 @@ static inline bool cpuinfo_has_arm_idiv(void) {
 }
 
 static inline bool cpuinfo_has_arm_vfpv2(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv2;
 #else
 	return false;
@@ -1783,7 +1775,7 @@ static inline bool cpuinfo_has_arm_vfpv2(void) {
 static inline bool cpuinfo_has_arm_vfpv3(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3;
 #else
 	return false;
@@ -1793,7 +1785,7 @@ static inline bool cpuinfo_has_arm_vfpv3(void) {
 static inline bool cpuinfo_has_arm_vfpv3_d32(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3 && cpuinfo_isa.d32;
 #else
 	return false;
@@ -1803,7 +1795,7 @@ static inline bool cpuinfo_has_arm_vfpv3_d32(void) {
 static inline bool cpuinfo_has_arm_vfpv3_fp16(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3 && cpuinfo_isa.fp16;
 #else
 	return false;
@@ -1813,7 +1805,7 @@ static inline bool cpuinfo_has_arm_vfpv3_fp16(void) {
 static inline bool cpuinfo_has_arm_vfpv3_fp16_d32(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3 && cpuinfo_isa.fp16 && cpuinfo_isa.d32;
 #else
 	return false;
@@ -1823,7 +1815,7 @@ static inline bool cpuinfo_has_arm_vfpv3_fp16_d32(void) {
 static inline bool cpuinfo_has_arm_vfpv4(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3 && cpuinfo_isa.fma;
 #else
 	return false;
@@ -1833,7 +1825,7 @@ static inline bool cpuinfo_has_arm_vfpv4(void) {
 static inline bool cpuinfo_has_arm_vfpv4_d32(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.vfpv3 && cpuinfo_isa.fma && cpuinfo_isa.d32;
 #else
 	return false;
@@ -1841,7 +1833,7 @@ static inline bool cpuinfo_has_arm_vfpv4_d32(void) {
 }
 
 static inline bool cpuinfo_has_arm_fp16_arith(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.fp16arith;
 #else
 	return false;
@@ -1849,7 +1841,7 @@ static inline bool cpuinfo_has_arm_fp16_arith(void) {
 }
 
 static inline bool cpuinfo_has_arm_bf16(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.bf16;
 #else
 	return false;
@@ -1857,7 +1849,7 @@ static inline bool cpuinfo_has_arm_bf16(void) {
 }
 
 static inline bool cpuinfo_has_arm_wmmx(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.wmmx;
 #else
 	return false;
@@ -1865,17 +1857,17 @@ static inline bool cpuinfo_has_arm_wmmx(void) {
 }
 
 static inline bool cpuinfo_has_arm_wmmx2(void) {
-#if CPUINFO_ARCH_ARM
-	return cpuinfo_isa.wmmx2;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_ARM
+		return cpuinfo_isa.wmmx2;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_arm_neon(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.neon;
 #else
 	return false;
@@ -1885,7 +1877,7 @@ static inline bool cpuinfo_has_arm_neon(void) {
 static inline bool cpuinfo_has_arm_neon_fp16(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.neon && cpuinfo_isa.fp16;
 #else
 	return false;
@@ -1895,7 +1887,7 @@ static inline bool cpuinfo_has_arm_neon_fp16(void) {
 static inline bool cpuinfo_has_arm_neon_fma(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.neon && cpuinfo_isa.fma;
 #else
 	return false;
@@ -1905,7 +1897,7 @@ static inline bool cpuinfo_has_arm_neon_fma(void) {
 static inline bool cpuinfo_has_arm_neon_v8(void) {
 #if CPUINFO_ARCH_ARM64
 	return true;
-#elif CPUINFO_ARCH_ARM
+#elif CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.neon && cpuinfo_isa.armv8;
 #else
 	return false;
@@ -1913,15 +1905,15 @@ static inline bool cpuinfo_has_arm_neon_v8(void) {
 }
 
 static inline bool cpuinfo_has_arm_atomics(void) {
-#if CPUINFO_ARCH_ARM64
-	return cpuinfo_isa.atomics;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_ARM64
+		return cpuinfo_isa.atomics;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_arm_neon_rdm(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.rdm;
 #else
 	return false;
@@ -1929,9 +1921,9 @@ static inline bool cpuinfo_has_arm_neon_rdm(void) {
 }
 
 static inline bool cpuinfo_has_arm_neon_fp16_arith(void) {
-#if CPUINFO_ARCH_ARM
+#if CPUINFO_ARCH_ARM && !defined(__QNXNTO__)
 	return cpuinfo_isa.neon && cpuinfo_isa.fp16arith;
-#elif CPUINFO_ARCH_ARM64
+#elif CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.fp16arith;
 #else
 	return false;
@@ -1939,7 +1931,7 @@ static inline bool cpuinfo_has_arm_neon_fp16_arith(void) {
 }
 
 static inline bool cpuinfo_has_arm_fhm(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.fhm;
 #else
 	return false;
@@ -1947,7 +1939,7 @@ static inline bool cpuinfo_has_arm_fhm(void) {
 }
 
 static inline bool cpuinfo_has_arm_neon_dot(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.dot;
 #else
 	return false;
@@ -1955,7 +1947,7 @@ static inline bool cpuinfo_has_arm_neon_dot(void) {
 }
 
 static inline bool cpuinfo_has_arm_neon_bf16(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.bf16;
 #else
 	return false;
@@ -1963,7 +1955,7 @@ static inline bool cpuinfo_has_arm_neon_bf16(void) {
 }
 
 static inline bool cpuinfo_has_arm_jscvt(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.jscvt;
 #else
 	return false;
@@ -1971,7 +1963,7 @@ static inline bool cpuinfo_has_arm_jscvt(void) {
 }
 
 static inline bool cpuinfo_has_arm_fcma(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.fcma;
 #else
 	return false;
@@ -1979,7 +1971,7 @@ static inline bool cpuinfo_has_arm_fcma(void) {
 }
 
 static inline bool cpuinfo_has_arm_i8mm(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.i8mm;
 #else
 	return false;
@@ -1987,7 +1979,7 @@ static inline bool cpuinfo_has_arm_i8mm(void) {
 }
 
 static inline bool cpuinfo_has_arm_aes(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.aes;
 #else
 	return false;
@@ -1995,7 +1987,7 @@ static inline bool cpuinfo_has_arm_aes(void) {
 }
 
 static inline bool cpuinfo_has_arm_sha1(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.sha1;
 #else
 	return false;
@@ -2003,7 +1995,7 @@ static inline bool cpuinfo_has_arm_sha1(void) {
 }
 
 static inline bool cpuinfo_has_arm_sha2(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.sha2;
 #else
 	return false;
@@ -2011,15 +2003,15 @@ static inline bool cpuinfo_has_arm_sha2(void) {
 }
 
 static inline bool cpuinfo_has_arm_pmull(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
-	return cpuinfo_isa.pmull;
-#else
-	return false;
-#endif
+	#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+		return cpuinfo_isa.pmull;
+	#else
+		return false;
+	#endif
 }
 
 static inline bool cpuinfo_has_arm_crc32(void) {
-#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+#if (CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64) && !defined(__QNXNTO__)
 	return cpuinfo_isa.crc32;
 #else
 	return false;
@@ -2027,7 +2019,7 @@ static inline bool cpuinfo_has_arm_crc32(void) {
 }
 
 static inline bool cpuinfo_has_arm_sve(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sve;
 #else
 	return false;
@@ -2035,7 +2027,7 @@ static inline bool cpuinfo_has_arm_sve(void) {
 }
 
 static inline bool cpuinfo_has_arm_sve_bf16(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sve && cpuinfo_isa.bf16;
 #else
 	return false;
@@ -2043,7 +2035,7 @@ static inline bool cpuinfo_has_arm_sve_bf16(void) {
 }
 
 static inline bool cpuinfo_has_arm_sve2(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sve2;
 #else
 	return false;
@@ -2052,7 +2044,7 @@ static inline bool cpuinfo_has_arm_sve2(void) {
 
 // Function to get the max SVE vector length on ARM CPU's which support SVE.
 static inline uint32_t cpuinfo_get_max_arm_sve_length(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.svelen * 8; // bytes * 8 = bit length(vector length)
 #else
 	return 0;
@@ -2060,7 +2052,7 @@ static inline uint32_t cpuinfo_get_max_arm_sve_length(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme;
 #else
 	return false;
@@ -2068,7 +2060,7 @@ static inline bool cpuinfo_has_arm_sme(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme2(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme2;
 #else
 	return false;
@@ -2076,7 +2068,7 @@ static inline bool cpuinfo_has_arm_sme2(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme2p1(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme2p1;
 #else
 	return false;
@@ -2084,7 +2076,7 @@ static inline bool cpuinfo_has_arm_sme2p1(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme_i16i32(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme_i16i32;
 #else
 	return false;
@@ -2092,7 +2084,7 @@ static inline bool cpuinfo_has_arm_sme_i16i32(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme_bi32i32(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme_bi32i32;
 #else
 	return false;
@@ -2100,7 +2092,7 @@ static inline bool cpuinfo_has_arm_sme_bi32i32(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme_b16b16(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme_b16b16;
 #else
 	return false;
@@ -2108,7 +2100,7 @@ static inline bool cpuinfo_has_arm_sme_b16b16(void) {
 }
 
 static inline bool cpuinfo_has_arm_sme_f16f16(void) {
-#if CPUINFO_ARCH_ARM64
+#if CPUINFO_ARCH_ARM64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.sme_f16f16;
 #else
 	return false;
@@ -2147,7 +2139,7 @@ extern struct cpuinfo_riscv_isa cpuinfo_isa;
 #endif
 
 static inline bool cpuinfo_has_riscv_i(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.i;
 #else
 	return false;
@@ -2155,7 +2147,7 @@ static inline bool cpuinfo_has_riscv_i(void) {
 }
 
 static inline bool cpuinfo_has_riscv_e(void) {
-#if CPUINFO_ARCH_RISCV32
+#if CPUINFO_ARCH_RISCV32 && !defined(__QNXNTO__)
 	return cpuinfo_isa.e;
 #else
 	return false;
@@ -2163,7 +2155,7 @@ static inline bool cpuinfo_has_riscv_e(void) {
 }
 
 static inline bool cpuinfo_has_riscv_m(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.m;
 #else
 	return false;
@@ -2171,7 +2163,7 @@ static inline bool cpuinfo_has_riscv_m(void) {
 }
 
 static inline bool cpuinfo_has_riscv_a(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.a;
 #else
 	return false;
@@ -2179,7 +2171,7 @@ static inline bool cpuinfo_has_riscv_a(void) {
 }
 
 static inline bool cpuinfo_has_riscv_f(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.f;
 #else
 	return false;
@@ -2187,7 +2179,7 @@ static inline bool cpuinfo_has_riscv_f(void) {
 }
 
 static inline bool cpuinfo_has_riscv_d(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.d;
 #else
 	return false;
@@ -2201,7 +2193,7 @@ static inline bool cpuinfo_has_riscv_g(void) {
 }
 
 static inline bool cpuinfo_has_riscv_c(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.c;
 #else
 	return false;
@@ -2209,7 +2201,7 @@ static inline bool cpuinfo_has_riscv_c(void) {
 }
 
 static inline bool cpuinfo_has_riscv_v(void) {
-#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#if CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64 && !defined(__QNXNTO__)
 	return cpuinfo_isa.v;
 #else
 	return false;
@@ -2257,38 +2249,34 @@ uint32_t CPUINFO_ABI cpuinfo_get_max_cache_size(void);
 /**
  * Identify the logical processor that executes the current thread.
  *
- * There is no guarantee that the thread will stay on the same logical processor
- * for any time. Callers should treat the result as only a hint, and be prepared
- * to handle NULL return value.
+ * There is no guarantee that the thread will stay on the same logical processor for any time.
+ * Callers should treat the result as only a hint, and be prepared to handle NULL return value.
  */
 const struct cpuinfo_processor* CPUINFO_ABI cpuinfo_get_current_processor(void);
 
 /**
  * Identify the core that executes the current thread.
  *
- * There is no guarantee that the thread will stay on the same core for any
- * time. Callers should treat the result as only a hint, and be prepared to
- * handle NULL return value.
+ * There is no guarantee that the thread will stay on the same core for any time.
+ * Callers should treat the result as only a hint, and be prepared to handle NULL return value.
  */
 const struct cpuinfo_core* CPUINFO_ABI cpuinfo_get_current_core(void);
 
 /**
- * Identify the microarchitecture index of the core that executes the current
- * thread. If the system does not support such identification, the function
- * returns 0.
+ * Identify the microarchitecture index of the core that executes the current thread.
+ * If the system does not support such identification, the function returns 0.
  *
- * There is no guarantee that the thread will stay on the same type of core for
- * any time. Callers should treat the result as only a hint.
+ * There is no guarantee that the thread will stay on the same type of core for any time.
+ * Callers should treat the result as only a hint.
  */
 uint32_t CPUINFO_ABI cpuinfo_get_current_uarch_index(void);
 
 /**
- * Identify the microarchitecture index of the core that executes the current
- * thread. If the system does not support such identification, the function
- * returns the user-specified default value.
+ * Identify the microarchitecture index of the core that executes the current thread.
+ * If the system does not support such identification, the function returns the user-specified default value.
  *
- * There is no guarantee that the thread will stay on the same type of core for
- * any time. Callers should treat the result as only a hint.
+ * There is no guarantee that the thread will stay on the same type of core for any time.
+ * Callers should treat the result as only a hint.
  */
 uint32_t CPUINFO_ABI cpuinfo_get_current_uarch_index_with_default(uint32_t default_uarch_index);
 
diff --git a/src/api.c b/src/api.c
index b8c999f..378559c 100644
--- a/src/api.c
+++ b/src/api.c
@@ -15,6 +15,10 @@
 #endif
 #endif
 
+#ifdef __QNXNTO__
+#include <qnx/api.h>
+#endif
+
 bool cpuinfo_is_initialized = false;
 
 struct cpuinfo_processor* cpuinfo_processors = NULL;
@@ -50,28 +54,44 @@ const struct cpuinfo_processor* cpuinfo_get_processors(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "processors");
 	}
+#ifdef __QNXNTO__
+	return qnx_processors;
+#else
 	return cpuinfo_processors;
+#endif
 }
 
 const struct cpuinfo_core* cpuinfo_get_cores(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "core");
 	}
+#ifdef __QNXNTO__
+	return (const struct cpuinfo_core*)qnx_core;
+#else
 	return cpuinfo_cores;
+#endif
 }
 
 const struct cpuinfo_cluster* cpuinfo_get_clusters(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "clusters");
 	}
+#ifdef __QNXNTO__
+	return (const struct cpuinfo_cluster*)qnx_cluster;
+#else
 	return cpuinfo_clusters;
+#endif
 }
 
 const struct cpuinfo_package* cpuinfo_get_packages(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "packages");
 	}
+#ifdef __QNXNTO__
+	return qnx_package;
+#else
 	return cpuinfo_packages;
+#endif
 }
 
 const struct cpuinfo_uarch_info* cpuinfo_get_uarchs() {
@@ -92,7 +112,11 @@ const struct cpuinfo_processor* cpuinfo_get_processor(uint32_t index) {
 	if CPUINFO_UNLIKELY (index >= cpuinfo_processors_count) {
 		return NULL;
 	}
+#ifdef __QNXNTO__
+	return (const struct cpuinfo_processor*)&qnx_processors[index];
+#else
 	return &cpuinfo_processors[index];
+#endif
 }
 
 const struct cpuinfo_core* cpuinfo_get_core(uint32_t index) {
@@ -102,7 +126,11 @@ const struct cpuinfo_core* cpuinfo_get_core(uint32_t index) {
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cores_count) {
 		return NULL;
 	}
+#ifdef __QNXNTO__
+	return qnx_core;
+#else
 	return &cpuinfo_cores[index];
+#endif
 }
 
 const struct cpuinfo_cluster* cpuinfo_get_cluster(uint32_t index) {
@@ -112,7 +140,11 @@ const struct cpuinfo_cluster* cpuinfo_get_cluster(uint32_t index) {
 	if CPUINFO_UNLIKELY (index >= cpuinfo_clusters_count) {
 		return NULL;
 	}
+#ifdef __QNXNTO__
+	return qnx_cluster;
+#else
 	return &cpuinfo_clusters[index];
+#endif
 }
 
 const struct cpuinfo_package* cpuinfo_get_package(uint32_t index) {
@@ -122,7 +154,11 @@ const struct cpuinfo_package* cpuinfo_get_package(uint32_t index) {
 	if CPUINFO_UNLIKELY (index >= cpuinfo_packages_count) {
 		return NULL;
 	}
+#ifdef __QNXNTO__
+	return qnx_package;
+#else
 	return &cpuinfo_packages[index];
+#endif
 }
 
 const struct cpuinfo_uarch_info* cpuinfo_get_uarch(uint32_t index) {
@@ -146,28 +182,44 @@ uint32_t cpuinfo_get_processors_count(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "processors_count");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_processors_count();
+#else
 	return cpuinfo_processors_count;
+#endif
 }
 
 uint32_t cpuinfo_get_cores_count(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "cores_count");
 	}
+#ifdef __QNXNTO__
+	return 1;
+#else
 	return cpuinfo_cores_count;
+#endif
 }
 
 uint32_t cpuinfo_get_clusters_count(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "clusters_count");
 	}
+#ifdef __QNXNTO__
+	return 1;
+#else
 	return cpuinfo_clusters_count;
+#endif
 }
 
 uint32_t cpuinfo_get_packages_count(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "packages_count");
 	}
+#ifdef __QNXNTO__
+	return 1;
+#else
 	return cpuinfo_packages_count;
+#endif
 }
 
 uint32_t cpuinfo_get_uarchs_count(void) {
@@ -175,7 +227,11 @@ uint32_t cpuinfo_get_uarchs_count(void) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "uarchs_count");
 	}
 #if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64 || CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
+#ifdef __QNXNTO__
+	return 1;
+#else
 	return cpuinfo_uarchs_count;
+#endif
 #else
 	return 1;
 #endif
@@ -185,85 +241,125 @@ const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l1i_caches(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l1i_caches");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1i_caches();
+#else
 	return cpuinfo_cache[cpuinfo_cache_level_1i];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l1d_caches(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l1d_caches");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1d_caches();
+#else
 	return cpuinfo_cache[cpuinfo_cache_level_1d];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l2_caches(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l2_caches");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1d_caches();
+#else
 	return cpuinfo_cache[cpuinfo_cache_level_2];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l3_caches(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l3_caches");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1d_caches();
+#else
 	return cpuinfo_cache[cpuinfo_cache_level_3];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l4_caches(void) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l4_caches");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1d_caches();
+#else
 	return cpuinfo_cache[cpuinfo_cache_level_4];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l1i_cache(uint32_t index) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l1i_cache");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1i_caches();
+#else
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cache_count[cpuinfo_cache_level_1i]) {
 		return NULL;
 	}
 	return &cpuinfo_cache[cpuinfo_cache_level_1i][index];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l1d_cache(uint32_t index) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l1d_cache");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l1d_caches();
+#else
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cache_count[cpuinfo_cache_level_1d]) {
 		return NULL;
 	}
 	return &cpuinfo_cache[cpuinfo_cache_level_1d][index];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l2_cache(uint32_t index) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l2_cache");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l2_caches();
+#else
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cache_count[cpuinfo_cache_level_2]) {
 		return NULL;
 	}
 	return &cpuinfo_cache[cpuinfo_cache_level_2][index];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l3_cache(uint32_t index) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l3_cache");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l3_caches();
+#else
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cache_count[cpuinfo_cache_level_3]) {
 		return NULL;
 	}
 	return &cpuinfo_cache[cpuinfo_cache_level_3][index];
+#endif
 }
 
 const struct cpuinfo_cache* CPUINFO_ABI cpuinfo_get_l4_cache(uint32_t index) {
 	if CPUINFO_UNLIKELY (!cpuinfo_is_initialized) {
 		cpuinfo_log_fatal("cpuinfo_get_%s called before cpuinfo is initialized", "l4_cache");
 	}
+#ifdef __QNXNTO__
+	return cpuinfo_qnx_get_l4_caches();
+#else
 	if CPUINFO_UNLIKELY (index >= cpuinfo_cache_count[cpuinfo_cache_level_4]) {
 		return NULL;
 	}
 	return &cpuinfo_cache[cpuinfo_cache_level_4][index];
+#endif
 }
 
 uint32_t CPUINFO_ABI cpuinfo_get_l1i_caches_count(void) {
diff --git a/src/init.c b/src/init.c
index 81d5721..516073d 100644
--- a/src/init.c
+++ b/src/init.c
@@ -8,6 +8,10 @@
 #include <cpuinfo/internal-api.h>
 #include <cpuinfo/log.h>
 
+#ifdef __QNXNTO__
+	#include <qnx/api.h>
+#endif
+
 #ifdef __APPLE__
 #include "TargetConditionals.h"
 #endif
@@ -30,6 +34,8 @@ bool CPUINFO_ABI cpuinfo_initialize(void) {
 	pthread_once(&init_guard, &cpuinfo_x86_linux_init);
 #elif defined(_WIN32) || defined(__CYGWIN__)
 	InitOnceExecuteOnce(&init_guard, &cpuinfo_x86_windows_init, NULL, NULL);
+#elif defined(__QNXNTO__)
+	pthread_once(&init_guard, &cpuinfo_qnx_init);
 #else
 	cpuinfo_log_error("operating system is not supported in cpuinfo");
 #endif
@@ -46,6 +52,8 @@ bool CPUINFO_ABI cpuinfo_initialize(void) {
 #elif CPUINFO_ARCH_RISCV32 || CPUINFO_ARCH_RISCV64
 #if defined(__linux__)
 	pthread_once(&init_guard, &cpuinfo_riscv_linux_init);
+#elif defined(__QNXNTO__)
+	pthread_once(&init_guard, &cpuinfo_qnx_init);
 #else
 	cpuinfo_log_error("operating system is not supported in cpuinfo");
 #endif
@@ -64,4 +72,8 @@ bool CPUINFO_ABI cpuinfo_initialize(void) {
 	return cpuinfo_is_initialized;
 }
 
-void CPUINFO_ABI cpuinfo_deinitialize(void) {}
+void CPUINFO_ABI cpuinfo_deinitialize(void) {
+	#ifdef __QNXNTO__
+		cpuinfo_qnx_deinit();
+	#endif
+}
diff --git a/src/qnx/api.c b/src/qnx/api.c
new file mode 100644
index 0000000..9a7b553
--- /dev/null
+++ b/src/qnx/api.c
@@ -0,0 +1,1876 @@
+#include <sys/neutrino.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <sys/syspage.h>
+#include <string.h>
+
+#include <cpuinfo.h>
+#include <cpuinfo/internal-api.h>
+#include <cpuinfo/log.h>
+#include <qnx/api.h>
+
+#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+    #include <arm/midr.h>
+    #include <arm/api.h>
+#endif
+
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+        #include <x86_64/inline.h>
+        #include <x86/api.h>
+#endif
+
+// Please note the following:
+// Since not enough information is provided in system page the following assumptions has been made
+// Assuming one core per package
+// Assuming identical processors within a core
+
+// Since Optimization is no needed by customer only features used by libtorch are implemented in this library to speed development
+
+// TODO:
+// For x86_64 cpuid assembly instruction can be used to read information about the processor
+// For ARM Main Register ID can be read to get more information about CPU
+// Use assembly to detect a lot more CPU features.
+
+extern struct syspage_entry *_syspage_ptr;
+
+struct cpuinfo_processor * qnx_processors;
+struct cpuinfo_cache * qnx_cache;
+struct cpuinfo_core * qnx_core;
+struct cpuinfo_cluster * qnx_cluster;
+struct cpuinfo_package * qnx_package;
+
+enum cpuinfo_vendor cpuinfo_qnx_get_vendor(){
+    // To figure out the vendor if the processor
+    // we will read the name of the cpu from the system page
+    int cpu_name_index = SYSPAGE_ARRAY_IDX(cpuinfo,0)->name;
+    char * current_string = (char *)SYSPAGE_ENTRY(strings);
+    if ( current_string == NULL ){
+        cpuinfo_log_fatal("cpuinfo_qnx_get_vendor: system page strings is NULL");
+        return cpuinfo_vendor_unknown;
+    }
+    char * cpu_name = &current_string[cpu_name_index];
+    if ( cpu_name == NULL ){
+        cpuinfo_log_fatal("cpuinfo_qnx_get_vendor: cpu_name is NULL");
+        return cpuinfo_vendor_unknown;
+    }
+    // The list of cpus and their mappings, more processors can be added here
+    if( strstr(cpu_name, "Cortex") != NULL )
+        return cpuinfo_vendor_arm;
+    if( strstr(cpu_name, "Intel") != NULL || strstr(cpu_name, "Core") != NULL )
+        return cpuinfo_vendor_intel;
+    else
+        return cpuinfo_vendor_unknown;
+}
+
+enum cpuinfo_uarch cpuinfo_qnx_get_uarch(){
+
+    int cpu_name_index = SYSPAGE_ARRAY_IDX(cpuinfo,0)->name;
+    char * current_string = (char *)SYSPAGE_ENTRY(strings);
+    if ( current_string == NULL ){
+        cpuinfo_log_fatal("cpuinfo_qnx_get_vendor: system page strings is NULL");
+        return cpuinfo_uarch_unknown;
+    }
+    char * cpu_name = &current_string[cpu_name_index];
+    if ( cpu_name == NULL ){
+        cpuinfo_log_fatal("cpuinfo_qnx_get_vendor: cpu_name is NULL");
+        return cpuinfo_uarch_unknown;
+    }
+    // The list of cpus and their mappings, more processors can be added here
+    if( strstr(cpu_name, "Core i7/5/3") != NULL )
+        return cpuinfo_uarch_sky_lake;
+    // cpu_name is an ASCII, NULL-terminated machine name. http://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.building/topic/syspage/cpuinfo.html
+    char * token = strstr(cpu_name, "A7");
+    if( token != NULL && (token+2) != NULL && (*(token+2)==' ' || *(token+2)=='\0') )
+        return cpuinfo_uarch_cortex_a7;
+    if( strstr(cpu_name, "A53") != NULL )
+        return cpuinfo_uarch_cortex_a53;
+    if( strstr(cpu_name, "A55R0") != NULL )
+        return cpuinfo_uarch_cortex_a55r0;
+    if( strstr(cpu_name, "A55") != NULL )
+        return cpuinfo_uarch_cortex_a55;
+    if( strstr(cpu_name, "A57") != NULL )
+        return cpuinfo_uarch_cortex_a57;
+    if( strstr(cpu_name, "A65") != NULL )
+        return cpuinfo_uarch_cortex_a65;
+    if( strstr(cpu_name, "A72") != NULL )
+        return cpuinfo_uarch_cortex_a72;
+    if( strstr(cpu_name, "A73") != NULL )
+        return cpuinfo_uarch_cortex_a73;
+    if( strstr(cpu_name, "A75") != NULL )
+        return cpuinfo_uarch_cortex_a75;
+    if( strstr(cpu_name, "A76") != NULL )
+        return cpuinfo_uarch_cortex_a76;
+    if( strstr(cpu_name, "A77") != NULL )
+        return cpuinfo_uarch_cortex_a77;
+    if( strstr(cpu_name, "A78") != NULL )
+        return cpuinfo_uarch_cortex_a78;
+    if( strstr(cpu_name, "Neoverse-N1") != NULL )
+        return cpuinfo_uarch_neoverse_n1;
+    if( strstr(cpu_name, "Neoverse-E1") != NULL )
+        return cpuinfo_uarch_neoverse_e1;
+    if( strstr(cpu_name, "Scorpion") != NULL )
+        return cpuinfo_uarch_scorpion;
+    if( strstr(cpu_name, "Krait") != NULL )
+        return cpuinfo_uarch_krait;
+    if( strstr(cpu_name, "Kryo") != NULL )
+        return cpuinfo_uarch_kryo;
+    if( strstr(cpu_name, "falkor") != NULL )
+        return cpuinfo_uarch_falkor;
+    if( strstr(cpu_name, "Saphira") != NULL )
+        return cpuinfo_uarch_saphira;
+    else
+        return cpuinfo_uarch_unknown;
+}
+
+int cpuinfo_qnx_fill_core_info(struct cpuinfo_core * core){
+    core->processor_start = 0;
+    core->processor_count = _syspage_ptr->num_cpu;
+    cpuinfo_cores_count = 1;
+    if ( core->processor_count > MAX_PROCESSOR || core->processor_count == 0 ){
+        cpuinfo_log_fatal("cpuinfo_qnx_fill_processors_info: num_cpu value is invalid");
+        return -1;
+    }
+    core->core_id = 0;
+    core->cluster = qnx_cluster;
+    core->package = qnx_package;
+    core->vendor = cpuinfo_qnx_get_vendor();
+    core->uarch = cpuinfo_qnx_get_uarch();
+#if CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+	/** Value of CPUID leaf 1 EAX register for this core */
+    uint32_t EAX=0;
+    uint32_t EBX=0;
+    uint32_t ECX=0;
+    uint32_t EDX=0;
+    uint32_t leaf = 1;
+    x86_cpuid1(leaf, &EAX, &EBX, &ECX, &EDX );
+    core->cpuid = EAX;
+#elif CPUINFO_ARCH_ARM64
+	/** Value of Main ID Register (MIDR) for this core */
+    __asm__("mrs %0, MIDR_EL1" : "=r"(core->midr));
+#elif CPUINFO_ARCH_ARM
+    /** Value of Main ID Register (MIDR) for this core */
+    __asm__("mrc p15,0,%0,c0,c0,0":"=r"(core->midr));
+#endif
+    core->frequency = SYSPAGE_ENTRY(qtime)->cycles_per_sec;
+    return 0;
+}
+
+void cpuinfo_qnx_fill_cluster_info(struct cpuinfo_core * cluster){
+    // TODO
+}
+
+void cpuinfo_qnx_fill_package_info(struct cpuinfo_core * package){
+    // TODO
+}
+
+int cpuinfo_qnx_fill_processors_info(struct cpuinfo_processor * processor_list){
+
+    int ret = -1;
+
+    ret = cpuinfo_qnx_fill_core_info(qnx_core);
+    if(ret!=0){
+        cpuinfo_log_fatal("cpuinfo_qnx_fill_processors_info: cpuinfo_qnx_fill_core_info failed");
+        return -1;
+    }
+
+    int num_cpu = _syspage_ptr->num_cpu;
+    if ( num_cpu > MAX_PROCESSOR ){
+        cpuinfo_log_fatal("cpuinfo_qnx_fill_processors_info: num_cpu value from syspage greater than MAX_PROCESSOR");
+        return -1;
+    }
+
+    cpuinfo_clusters_count = 1;
+    cpuinfo_packages_count = 1;
+
+    int l1i_index = SYSPAGE_ARRAY_IDX(cpuinfo,0)->ins_cache;
+    if ( l1i_index != 0 || l1i_index != 1 ){
+        l1i_index = 0;
+    }
+    int l1d_index = SYSPAGE_ARRAY_IDX(cpuinfo,0)->data_cache;
+    if ( l1d_index != 0 || l1d_index != 1 ){
+        l1d_index = 1;
+    }
+
+#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+        uint32_t midr=0;
+        #if CPUINFO_ARCH_ARM64
+            /** Value of Main ID Register (MIDR) for this core */
+            __asm__("mrs %0, MIDR_EL1" : "=r"(midr));
+        #elif CPUINFO_ARCH_ARM
+            /** Value of Main ID Register (MIDR) for this core */
+            __asm__("mrc p15,0,%0,c0,c0,0":"=r"(midr));
+        #endif
+	    uint32_t cluster_cores = 1;
+        enum cpuinfo_uarch uarch;
+        enum cpuinfo_vendor vendor;
+        #if CPUINFO_ARCH_ARM
+            cpuinfo_arm_decode_vendor_uarch(midr,1,&vendor,&uarch);
+        #else
+            cpuinfo_arm_decode_vendor_uarch(midr,&vendor,&uarch);
+        #endif
+        cpuinfo_arm_qnx_decode_cache( uarch, cluster_cores, midr, &qnx_cache[0], &qnx_cache[1], &qnx_cache[2], &qnx_cache[3]);
+#elif CPUINFO_ARCH_X86 || CPUINFO_ARCH_X86_64
+        struct cpuid_regs regs;
+        uint32_t package_cores_max = 0;
+        struct cpuinfo_x86_caches caches;
+        struct cpuid_regs leaf4;
+		uint32_t input_ecx = 0;
+		do {
+            // To get L1, L2 and L3 cache sizes, you need to use CPUID with EAX=4, and set ECX to 0, 1, 2, ...
+			x86_cpuid2(4, input_ecx++, &regs.eax, &regs.ebx, &regs.ecx, &regs.edx );
+		} while (cpuinfo_x86_decode_deterministic_cache_parameters(regs, &caches, &package_cores_max));
+        int j;
+        struct cpuinfo_x86_cache * cptr = &caches.l1i;
+        for( j = 0; ( j < input_ecx - 1 ) && ( j < MAX_CACHE ); j++ ){
+            qnx_cache[j].associativity = cptr->associativity;
+            qnx_cache[j].size = cptr->size;
+            qnx_cache[j].line_size = cptr->line_size;
+            qnx_cache[j].partitions = cptr->partitions;
+            qnx_cache[j].sets = cptr->sets;
+            cptr++;
+        }
+#endif
+
+    int i;
+    for( i=0; i<num_cpu && i<MAX_PROCESSOR; i++ ) {
+        processor_list[i].smt_id = SYSPAGE_ARRAY_IDX(cpuinfo,0)->smp_hwcoreid;
+        // Assuming processors have identical cache
+        processor_list[i].cache.l1i = &qnx_cache[0];
+        processor_list[i].cache.l1d = &qnx_cache[1];
+        processor_list[i].cache.l2 = &qnx_cache[2];
+        processor_list[i].cache.l3 = &qnx_cache[3];
+        processor_list[i].cache.l4 = &qnx_cache[4];
+        // Use same core, cluster and package info for all processors
+        // Directly reading cpu id registers can allow more information about cpus to be parsed
+        processor_list[i].core = qnx_core;
+        processor_list[i].cluster = qnx_cluster;
+        processor_list[i].package = qnx_package;
+    }
+    return 0;
+}
+
+void cpuinfo_qnx_init(void){
+
+    bool cleanup = false;
+
+    if ( ThreadCtl(_NTO_TCTL_IO_PRIV, NULL) == -1) {
+        cpuinfo_log_fatal("Failed to get I/O access permission");
+        cleanup = true;
+    }
+
+    // allocate memory:
+    qnx_processors = calloc( MAX_PROCESSOR, sizeof( struct cpuinfo_processor) );
+    if( qnx_processors == NULL ){
+        cpuinfo_log_fatal("Failed to allocate memory for qnx_processors");
+        cleanup = true;
+    }
+
+    qnx_cache = calloc( MAX_CACHE, sizeof( struct cpuinfo_cache ) );
+    if( qnx_cache == NULL ){
+        cpuinfo_log_fatal("Failed to allocate memory for qnx_cache");
+        cleanup = true;
+    }
+
+    qnx_core = calloc( 1, sizeof( struct cpuinfo_core ) );
+    if( qnx_core == NULL ){
+        cpuinfo_log_fatal("Failed to allocate memory for qnx_core");
+        cleanup = true;
+    }
+
+    qnx_cluster = calloc( 1, sizeof( struct cpuinfo_cluster ) );
+    if( qnx_cluster == NULL ){
+        cpuinfo_log_fatal("Failed to allocate memory for qnx_cluster");
+        cleanup = true;
+    }
+
+    qnx_package = calloc( 1, sizeof( struct cpuinfo_package ) );
+    if( qnx_package == NULL ){
+        cpuinfo_log_fatal("Failed to allocate memory for qnx_package");
+        cleanup = true;
+    }
+
+    int ret = cpuinfo_qnx_fill_processors_info(qnx_processors);
+    if( ret != 0 ){
+        cleanup = true;
+    }
+
+    __sync_synchronize();
+
+    if( cleanup == true ){
+        cpuinfo_log_fatal("CPUINIT-FAILED");
+         // free memory on failure:
+         if(qnx_processors != NULL){
+             free(qnx_processors);
+         }
+
+         if(qnx_cache != NULL){
+             free(qnx_cache);
+         }
+
+         if(qnx_core != NULL){
+             free(qnx_core);
+         }
+
+         if(qnx_cluster != NULL){
+             free(qnx_cluster);
+         }
+
+         if(qnx_package != NULL){
+             free(qnx_package);
+         }
+     }
+     else{
+         cpuinfo_is_initialized = true;
+     }
+}
+
+const struct cpuinfo_processor * cpuinfo_qnx_get_processor(uint32_t index){
+    return (const struct cpuinfo_processor *)&qnx_processors[index];
+}
+
+const struct cpuinfo_core * cpuinfo_qnx_get_core(void){
+    return (const struct cpuinfo_core *)qnx_core;
+}
+
+const struct cpuinfo_cluster* cpuinfo_qnx_get_cluster(void){
+    return (const struct cpuinfo_cluster*)qnx_cluster;
+}
+
+const struct cpuinfo_package* cpuinfo_qnx_get_package(void){
+    return (const struct cpuinfo_package*)qnx_package;
+}
+
+uint32_t cpuinfo_qnx_get_processors_count(void){
+    cpuinfo_processors_count = _syspage_ptr->num_cpu;
+    if ( cpuinfo_processors_count > MAX_PROCESSOR ){
+        cpuinfo_log_fatal("cpuinfo_qnx_fill_processors_info: num_cpu value from syspage greater than MAX_PROCESSOR");
+        return 1;
+    }
+    return cpuinfo_processors_count;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1i_caches(void){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l1i;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1d_caches(void){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l1d;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l2_caches(void){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l2;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l3_caches(void){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l3;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l4_caches(void){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l4;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1i_cache(uint32_t index){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l1i;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1d_cache(uint32_t index){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l1d;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l2_cache(uint32_t index){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l2;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l3_cache(uint32_t index){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l3;
+}
+
+const struct cpuinfo_cache* cpuinfo_qnx_get_l4_cache(uint32_t index){
+    return (const struct cpuinfo_cache*)qnx_processors[0].cache.l4;
+}
+
+void cpuinfo_qnx_deinit(){
+    // free memory:
+     if( qnx_processors != NULL ){
+         free(qnx_processors);
+     }
+
+     if( qnx_cache!=NULL ){
+         free(qnx_cache);
+     }
+
+     if( qnx_core != NULL ){
+         free(qnx_core);
+     }
+
+     if( qnx_cluster != NULL ){
+         free(qnx_cluster);
+     }
+
+     if( qnx_package != NULL ){
+         free(qnx_package);
+     }
+}
+
+#if CPUINFO_ARCH_ARM || CPUINFO_ARCH_ARM64
+
+void cpuinfo_arm_qnx_decode_cache(
+	enum cpuinfo_uarch uarch,
+	uint32_t cluster_cores,
+	uint32_t midr,
+	struct cpuinfo_cache l1i[restrict static 1],
+	struct cpuinfo_cache l1d[restrict static 1],
+	struct cpuinfo_cache l2[restrict static 1],
+	struct cpuinfo_cache l3[restrict static 1])
+{
+	switch (uarch) {
+#if CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_7A__) && !defined(__ARM_ARCH_8A__)
+		case cpuinfo_uarch_xscale:
+			switch (midr_get_part(midr) >> 8) {
+				case 2:
+					/*
+					 * PXA 210/25X/26X
+					 *
+					 * See "Computer Organization and Design, Revised Printing: The Hardware/Software Interface"
+					 *     by David A. Patterson, John L. Hennessy
+					 */
+					*l1i = (struct cpuinfo_cache) {
+						.size = 16 * 1024,
+						.associativity = 32,
+						.line_size = 32
+					};
+					*l1d = (struct cpuinfo_cache) {
+						.size = 16 * 1024,
+						.associativity = 4,
+						.line_size = 64
+					};
+					break;
+				case 4:
+					/* PXA 27X */
+					*l1i = (struct cpuinfo_cache) {
+						.size = 32 * 1024,
+						.associativity = 32,
+						.line_size = 32
+					};
+					*l1d = (struct cpuinfo_cache) {
+						.size = 32 * 1024,
+						.associativity = 32,
+						.line_size = 32
+					};
+					break;
+				case 6:
+					/*
+					 * PXA 3XX
+					 *
+					 * See http://download.intel.com/design/intelxscale/31628302.pdf
+					 */
+					*l1i = (struct cpuinfo_cache) {
+						.size = 32 * 1024,
+						.associativity = 4,
+						.line_size = 32
+					};
+					*l1d = (struct cpuinfo_cache) {
+						.size = 32 * 1024,
+						.associativity = 4,
+						.line_size = 32
+					};
+					*l2 = (struct cpuinfo_cache) {
+						.size = 256 * 1024,
+						.associativity = 8,
+						.line_size = 32
+					};
+					break;
+			}
+			break;
+		case cpuinfo_uarch_arm11:
+			*l1i = (struct cpuinfo_cache) {
+				.size = 16 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 16 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			break;
+#endif /* CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_7A__) && !defined(__ARM_ARCH_8A__) */
+#if CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_8A__)
+		case cpuinfo_uarch_cortex_a5:
+			/*
+			 * Cortex-A5 Technical Reference Manual:
+			 * 7.1.1. Memory system
+			 *   The Cortex-A5 processor has separate instruction and data caches.
+			 *   The caches have the following features:
+			 *    - Data cache is 4-way set-associative.
+			 *    - Instruction cache is 2-way set-associative.
+			 *    - The cache line length is eight words.
+			 *    - You can configure the instruction and data caches independently during implementation
+			 *      to sizes of 4KB, 8KB, 16KB, 32KB, or 64KB.
+			 * 1.1.3. System design components
+			 *    PrimeCell Level 2 Cache Controller (PL310)
+			 *      The addition of an on-chip secondary cache, also referred to as a Level 2 or L2 cache, is a
+			 *      recognized method of improving the performance of ARM-based systems when significant memory traffic
+			 *      is generated by the processor. The PrimeCell Level 2 Cache Controller reduces the number of external
+			 *      memory accesses and has been optimized for use with the Cortex-A5 processor.
+			 * 8.1.7. Exclusive L2 cache
+			 *    The Cortex-A5 processor can be connected to an L2 cache that supports an exclusive cache mode.
+			 *    This mode must be activated both in the Cortex-A5 processor and in the L2 cache controller.
+			 *
+			 *  +--------------------+-----------+-----------+----------+-----------+
+			 *  | Processor model    | L1D cache | L1I cache | L2 cache | Reference |
+			 *  +--------------------+-----------+-----------+----------+-----------+
+			 *  | Qualcomm MSM7225A  |           |           |          |           |
+			 *  | Qualcomm MSM7625A  |           |           |          |           |
+			 *  | Qualcomm MSM7227A  |           |           |          |           |
+			 *  | Qualcomm MSM7627A  |    32K    |    32K    |   256K   | Wiki [1]  |
+			 *  | Qualcomm MSM7225AB |           |           |          |           |
+			 *  | Qualcomm MSM7225AB |           |           |          |           |
+			 *  | Qualcomm QSD8250   |           |           |          |           |
+			 *  | Qualcomm QSD8650   |           |           |          |           |
+			 *  +--------------------+-----------+-----------+----------+-----------+
+			 *  | Spreadtrum SC6821  |    32K    |    32K    |    ?     |           |
+			 *  | Spreadtrum SC6825  |    32K    |    32K    |   256K   | Wiki [2]  |
+			 *  | Spreadtrum SC8810  |     ?     |     ?     |    ?     |           |
+			 *  | Spreadtrum SC8825  |    32K    |    32K    |    ?     |           |
+			 *  +--------------------+-----------+-----------+----------+-----------+
+			 *
+			 * [1] https://en.wikipedia.org/wiki/List_of_Qualcomm_Snapdragon_systems-on-chip#Snapdragon_S1
+			 * [2] https://en.wikipedia.org/wiki/Spreadtrum
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 32
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 256 * 1024,
+				/*
+				 * Follow NXP specification: "Eight-way set-associative 512 kB L2 cache with 32B line size"
+				 * Reference: http://www.nxp.com/assets/documents/data/en/application-notes/AN4947.pdf
+				 */
+				.associativity = 8,
+				.line_size = 32
+			};
+			break;
+		case cpuinfo_uarch_cortex_a7:
+			/*
+			 * Cortex-A7 MPCore Technical Reference Manual:
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches. You can configure the
+			 *   instruction and data caches independently during implementation to sizes of 8KB, 16KB, 32KB, or 64KB.
+			 *
+			 *   The L1 instruction memory system has the following features:
+			 *    - Instruction side cache line length of 32-bytes.
+			 *    - 2-way set-associative instruction cache.
+			 *
+			 *   The L1 data memory system has the following features:
+			 *    - Data side cache line length of 64-bytes.
+			 *    - 4-way set-associative data cache.
+			 *
+			 * 7.1. About the L2 Memory system
+			 *   The L2 memory system consists of an:
+			 *    - Optional tightly-coupled L2 cache that includes:
+			 *      - Configurable L2 cache size of 128KB, 256KB, 512KB, and 1MB.
+			 *      - Fixed line length of 64 bytes
+			 *      - 8-way set-associative cache structure
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Allwinner A20      |   2   |    32K    |    32K    |   256K    |    [1]    |
+			 *  | Allwinner A23      |   2   |    32K    |    32K    |   256K    |    [2]    |
+			 *  | Allwinner A31      |   4   |    32K    |    32K    |    1M     |    [3]    |
+			 *  | Allwinner A31s     |   4   |    32K    |    32K    |    1M     |    [4]    |
+			 *  | Allwinner A33      |   4   |    32K    |    32K    |   512K    |    [5]    |
+			 *  | Allwinner A80 Octa | 4(+4) |    32K    |    32K    | 512K(+2M) |    [6]    |
+			 *  | Allwinner A81T     |   8   |    32K    |    32K    |    1M     |    [7]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Broadcom BCM2836   |   4   |    32K    |    32K    |    512K   |    [8]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Kirin 920          | 4(+4) |     ?     |     ?     |    512K   |    [9]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] https://linux-sunxi.org/A20
+			 * [2] https://linux-sunxi.org/A23
+			 * [3] http://dl.linux-sunxi.org/A31/A3x_release_document/A31/IC/A31%20datasheet%20V1.3%2020131106.pdf
+			 * [4] https://github.com/allwinner-zh/documents/blob/master/A31s/A31s_Datasheet_v1.5_20150510.pdf
+			 * [5] http://dl.linux-sunxi.org/A33/A33_Datasheet_release1.0.pdf
+			 * [6] https://linux-sunxi.org/images/1/10/A80_Datasheet_Revision_1.0_0404.pdf
+			 * [7] http://dl.linux-sunxi.org/A83T/A83T_datasheet_Revision_1.1.pdf
+			 * [8] https://www.raspberrypi.org/forums/viewtopic.php?t=98428
+			 * [9] http://www.gizmochina.com/2014/10/07/hisilicon-kirin-920-tear-down/
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 32
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 128 * 1024 * cluster_cores,
+				.associativity = 8,
+				.line_size = 64
+			};
+			break;
+		case cpuinfo_uarch_cortex_a8:
+			/*
+			 * Cortex-A8 Technical Reference Manual:
+			 * 7.1. About the L1 memory system
+			 *    The L1 memory system consists of separate instruction and data caches in a Harvard arrangement.
+			 *    The L1 memory system provides the core with:
+			 *     - fixed line length of 64 bytes
+			 *     - support for 16KB or 32KB caches
+			 *     - 4-way set associative cache structure
+			 * 8.1. About the L2 memory system
+			 *    The L2 memory system is tightly coupled to the L1 data cache and L1 instruction cache.
+			 *    The key features of the L2 memory system include:
+			 *     - configurable cache size of 0KB, 128KB, 256KB, 512KB, and 1MB
+			 *     - fixed line length of 64 bytes
+			 *     - 8-way set associative cache structure
+			 *
+			 *  +----------------------+-----------+-----------+-----------+-----------+
+			 *  | Processor model      | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +----------------------+-----------+-----------+-----------+-----------+
+			 *  | Exynos 3 Single 3110 |    32K    |    32K    |   512K    |    [1]    |
+			 *  +----------------------+-----------+-----------+-----------+-----------+
+			 *  | TI DM 3730           |    32K    |    32K    |   256K    |    [2]    |
+			 *  +----------------------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] https://en.wikichip.org/w/images/0/04/Exynos_3110.pdf
+			 * [2] https://www.ti.com/lit/ds/symlink/dm3725.pdf
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+                .size = 512 * 1024,
+				.associativity = 8,
+				.line_size = 64
+			};
+
+			break;
+		case cpuinfo_uarch_cortex_a9:
+			/*
+			 * ARM CortexA9 Technical Reference Manual:
+			 * 7.1.1 Memory system
+			 *    The CortexA9 processor has separate instruction and data caches.
+			 *    The caches have the following features:
+			 *     - Both caches are 4-way set-associative.
+			 *     - The cache line length is eight words.
+			 *     - You can configure the instruction and data caches independently during implementation
+			 *       to sizes of 16KB, 32KB, or 64KB.
+			 * 8.1.5 Exclusive L2 cache
+			 *    The CortexA9 processor can be connected to an L2 cache that supports an exclusive cache mode.
+			 *    This mode must be activated both in the CortexA9 processor and in the L2 cache controller.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Exynos 4 Dual 4210 |   2   |    32K    |    32K    |    1M     |    [1]    |
+			 *  | Exynos 4 Dual 4212 |   2   |    32K    |    32K    |    1M     |    [2]    |
+			 *  | Exynos 4 Quad 4412 |   4   |    32K    |    32K    |    1M     |    [3]    |
+			 *  | Exynos 4 Quad 4415 |   4   |    32K    |    32K    |    1M     |           |
+			 *  | TI OMAP 4430       |   2   |    32K    |    32K    |    1M     |    [4]    |
+			 *  | TI OMAP 4460       |   2   |    32K    |    32K    |    1M     |    [5]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.samsung.com/global/business/semiconductor/file/product/Exynos_4_Dual_45nm_User_Manaul_Public_REV1.00-0.pdf
+			 * [2] http://www.samsung.com/global/business/semiconductor/file/product/Exynos_4_Dual_32nm_User_Manaul_Public_REV100-0.pdf
+			 * [3] http://www.samsung.com/global/business/semiconductor/file/product/Exynos_4_Quad_User_Manaul_Public_REV1.00-0.pdf
+			 * [4] https://www.hotchips.org/wp-content/uploads/hc_archives/hc21/2_mon/HC21.24.400.ClientProcessors-Epub/HC21.24.421.Witt-OMAP4430.pdf
+			 * [5] http://www.anandtech.com/show/5310/samsung-galaxy-nexus-ice-cream-sandwich-review/9
+			 */
+
+			/* Use Exynos 4 specs */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 1024 * 1024,
+				/* OMAP4460 in Pandaboard ES has 16-way set-associative L2 cache */
+				.associativity = 16,
+				.line_size = 32
+			};
+			break;
+		case cpuinfo_uarch_cortex_a15:
+			/*
+			 * 6.1. About the L1 memory system
+			 *    The L1 memory system consists of separate instruction and data caches.
+			 *    The L1 instruction memory system has the following features:
+			 *     - 32KB 2-way set-associative instruction cache.
+			 *     - Fixed line length of 64 bytes.
+			 *    The L1 data memory system has the following features:
+			 *     - 32KB 2-way set-associative data cache.
+			 *     - Fixed line length of 64 bytes.
+			 * 7.1. About the L2 memory system
+			 *    The features of the L2 memory system include:
+			 *     - Configurable L2 cache size of 512KB, 1MB, 2MB and 4MB.
+			 *     - Fixed line length of 64 bytes.
+			 *     - 16-way set-associative cache structure.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Exynos 5 Dual 5250 |   2   |    32K    |    32K    |    1M     |    [1]    |
+			 *  | Exynos 5 Hexa 5260 | 2(+4) |    32K    |    32K    | 1M(+512K) |    [2]    |
+			 *  | Exynos 5 Octa 5410 | 4(+4) |    32K    |    32K    | 2M(+512K) |    [3]    |
+			 *  | Exynos 5 Octa 5420 | 4(+4) |    32K    |    32K    | 2M(+512K) |    [3]    |
+			 *  | Exynos 5 Octa 5422 | 4(+4) |    32K    |    32K    | 2M(+512K) |    [3]    |
+			 *  | Exynos 5 Octa 5430 | 4(+4) |    32K    |    32K    | 2M(+512K) |    [3]    |
+			 *  | Exynos 5 Octa 5800 | 4(+4) |    32K    |    32K    | 2M(+512K) |    [3]    |
+			 *  | Kirin 920          | 4(+4) |     ?     |     ?     | 2M(+512K) |    [4]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.arndaleboard.org/wiki/downloads/supports/Exynos_5_Dual_User_Manaul_Public_REV1.00.pdf
+			 * [2] http://www.yicsystem.com/wp-content/uploads/2014/08/Espresso5260P-Guide-Book.pdf
+			 * [3] http://www.anandtech.com/show/6768/samsung-details-exynos-5-octa-architecture-power-at-isscc-13
+			 * [4] http://www.gizmochina.com/2014/10/07/hisilicon-kirin-920-tear-down/
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 512 * 1024,
+				.associativity = 16,
+				.line_size = 64
+			};
+			break;
+		case cpuinfo_uarch_cortex_a17:
+			/*
+			 * ARM Cortex-A17 MPCore Processor Technical Reference Manual:
+			 * 6.1. About the L1 memory system
+			 *    The L1 memory system consists of separate instruction and data caches.
+			 *    The size of the instruction cache is implemented as either 32KB or 64KB.
+			 *    The size of the data cache is 32KB.
+			 *
+			 *    The L1 instruction cache has the following features:
+			 *     - Instruction side cache line length of 64-bytes.
+			 *     - 4-way set-associative instruction cache.
+			 *
+			 *    The L1 data cache has the following features:
+			 *     - Data side cache line length of 64-bytes.
+			 *     - 4-way set-associative data cache.
+			 *
+			 * 7.1. About the L2 Memory system
+			 *    An integrated L2 cache:
+			 *     - The cache size is implemented as either 256KB, 512KB, 1MB, 2MB, 4MB or 8MB.
+			 *     - A fixed line length of 64 bytes.
+			 *     - 16-way set-associative cache structure.
+			 *
+			 *  +------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model  | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | MediaTek MT6595  | 4(+4) |    32K    |    32K    | 2M(+512K) |    [1]    |
+			 *  +------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] https://blog.osakana.net/archives/5268
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 512 * 1024,
+				.associativity = 16,
+				.line_size = 64
+			};
+			break;
+#endif /* CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_8A__) */
+		case cpuinfo_uarch_cortex_a35:
+			/*
+			 * ARM CortexA35 Processor Technical Reference Manual:
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system includes several power-saving and performance-enhancing features.
+			 *   These include separate instruction and data caches, which can be configured
+			 *   independently during implementation to sizes of 8KB, 16KB, 32KB, or 64KB.
+			 *
+			 *   L1 instruction-side memory system
+			 *     A dedicated instruction cache that:
+			 *      - is virtually indexed and physically tagged.
+			 *      - is 2-way set associative.
+			 *      - is configurable to be 8KB, 16KB, 32KB, or 64KB.
+			 *      - uses a cache line length of 64 bytes.
+			 *
+			 *   L1 data-side memory system
+			 *     A dedicated data cache that:
+			 *      - is physically indexed and physically tagged.
+			 *      - is 4-way set associative.
+			 *      - is configurable to be 8KB, 16KB, 32KB, or 64KB.
+			 *      - uses a cache line length of 64 bytes.
+			 *
+			 * 7.1. About the L2 memory system
+			 *   The L2 cache is 8-way set associative.
+			 *   Further features of the L2 cache are:
+			 *    - Configurable size of 128KB, 256KB, 512KB, and 1MB.
+			 *    - Fixed line length of 64 bytes.
+			 *    - Physically indexed and tagged.
+			 *
+			 *  +-----------------+---------+-----------+-----------+-----------+-----------+
+			 *  | Processor model |  Cores  | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +-----------------+---------+-----------+-----------+-----------+-----------+
+			 *  | MediaTek MT6599 | 4(+4+2) |     ?     |     ?     |     ?     |           |
+			 *  +-----------------+---------+-----------+-----------+-----------+-----------+
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 16 * 1024, /* assumption based on low-end Cortex-A53 */
+				.associativity = 2,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 16 * 1024, /* assumption based on low-end Cortex-A53 */
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 256 * 1024, /* assumption based on low-end Cortex-A53 */
+				.associativity = 8,
+				.line_size = 64
+			};
+			break;
+		case cpuinfo_uarch_cortex_a53:
+			/*
+			 * ARM Cortex-A53 MPCore Processor Technical Reference Manual:
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches. The implementer configures the
+			 *   instruction and data caches independently during implementation, to sizes of 8KB, 16KB, 32KB, or 64KB.
+			 *
+			 *   The L1 Instruction memory system has the following key features:
+			 *    - Instruction side cache line length of 64 bytes.
+			 *    - 2-way set associative L1 Instruction cache.
+			 *
+			 *   The L1 Data memory system has the following features:
+			 *    - Data side cache line length of 64 bytes.
+			 *    - 4-way set associative L1 Data cache.
+			 *
+			 * 7.1. About the L2 memory system
+			 *   The L2 memory system consists of an:
+			 *    - Optional tightly-coupled L2 cache that includes:
+			 *      - Configurable L2 cache size of 128KB, 256KB, 512KB, 1MB and 2MB.
+			 *      - Fixed line length of 64 bytes.
+			 *      - 16-way set-associative cache structure.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Broadcom BCM2837   |   4   |    16K    |    16K    |    512K   |    [1]    |
+			 *  | Exynos 7420        | 4(+4) |    32K    |    32K    |    256K   |  [2, 3]   |
+			 *  | Exynos 8890        | 4(+4) |    32K    |    32K    |    256K   |    [4]    |
+			 *  | Rochchip RK3368    |  4+4  |    32K    |    32K    | 512K+256K |   sysfs   |
+			 *  | MediaTek MT8173C   | 2(+2) |    32K    |    32K    | 512K(+1M) |   sysfs   |
+			 *  | Snapdragon 410     |   4   |    32K    |    32K    |    512K   |    [3]    |
+			 *  | Snapdragon 630     |  4+4  |    32K    |    32K    |  1M+512K  |   sysfs   |
+			 *  | Snapdragon 636     | 4(+4) |  32K+64K  |  32K+64K  |   1M+1M   |   sysfs   |
+			 *  | Snapdragon 660     | 4(+4) |  32K+64K  |  32K+64K  |   1M+1M   |   sysfs   |
+			 *  | Snapdragon 835     | 4(+4) |  32K+64K  |  32K+64K  |  1M(+2M)  |   sysfs   |
+			 *  | Kirin 620          |  4+4  |    32K    |    32K    |    512K   |    [5]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=145766
+			 * [2] http://www.anandtech.com/show/9330/exynos-7420-deep-dive/2
+			 * [3] https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_lipp.pdf
+			 * [4] http://www.boardset.com/products/products_v8890.php
+			 * [5] http://mirror.lemaker.org/Hi6220V100_Multi-Mode_Application_Processor_Function_Description.pdf
+			 */
+			if (midr_is_qualcomm_cortex_a53_silver(midr)) {
+				/* Qualcomm-modified Cortex-A53 in Snapdragon 630/660/835 */
+				uint32_t l2_size = 512 * 1024;
+				*l1i = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 2,
+					.line_size = 64
+				};
+				*l1d = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 4,
+					.line_size = 64
+				};
+				*l2 = (struct cpuinfo_cache) {
+					.size = l2_size,
+					.associativity = 16,
+					.line_size = 64
+				};
+			} else {
+				/* Standard Cortex-A53 */
+
+				/* Use conservative values by default */
+				uint32_t l1_size = 16 * 1024;
+				uint32_t l2_size = 256 * 1024;
+				*l1i = (struct cpuinfo_cache) {
+					.size = l1_size,
+					.associativity = 2,
+					.line_size = 64
+				};
+				*l1d = (struct cpuinfo_cache) {
+					.size = l1_size,
+					.associativity = 4,
+					.line_size = 64
+				};
+				*l2 = (struct cpuinfo_cache) {
+					.size = l2_size,
+					.associativity = 16,
+					.line_size = 64
+				};
+			}
+			break;
+		case cpuinfo_uarch_cortex_a55r0:
+		case cpuinfo_uarch_cortex_a55:
+			/*
+			 * ARM Cortex-A55 Core Technical Reference Manual
+			 * A6.1. About the L1 memory system
+			 *   The Cortex-A55 core's L1 memory system enhances core performance and power efficiency.
+			 *   It consists of separate instruction and data caches. You can configure instruction and data caches
+			 *   independently during implementation to sizes of 16KB, 32KB, or 64KB.
+			 *
+			 *   L1 instruction-side memory system
+			 *   The L1 instruction-side memory system provides an instruction stream to the DPU. Its key features are:
+			 *    - 64-byte instruction side cache line length.
+			 *    - 4-way set associative L1 instruction cache.
+			 *
+			 *   L1 data-side memory system
+			 *    - 64-byte data side cache line length.
+			 *    - 4-way set associative L1 data cache.
+			 *
+			 * A7.1 About the L2 memory system
+			 *   The Cortex-A55 L2 memory system is required to interface the Cortex-A55 cores to the L3 memory system.
+			 *   The L2 memory subsystem consists of:
+			 *    - An optional 4-way, set-associative L2 cache with a configurable size of 64KB, 128KB or 256KB. Cache
+			 *      lines have a fixed length of 64 bytes.
+			 *
+			 *   The main features of the L2 memory system are:
+			 *    - Strictly exclusive with L1 data cache.
+			 *    - Pseudo-inclusive with L1 instruction cache.
+			 *    - Private per-core unified L2 cache.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | L3 cache | Reference  |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Snapdragon 845     | 4(+4) |    32K    |    32K    |    128K   |    2M    | [1], sysfs |
+			 *  | Exynos 9810        | 4(+4) |     ?     |     ?     |    None   |   512K   |     [2]    |
+			 *  | Kirin 980          | 4(+4) |    32K    |    32K    |    128K   |    4M    |     [3]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *
+			 * [1] https://www.anandtech.com/show/12114/qualcomm-announces-snapdragon-845-soc
+			 * [2] https://www.anandtech.com/show/12478/exynos-9810-handson-awkward-first-results
+			 * [3] https://en.wikichip.org/wiki/hisilicon/kirin/980
+			 */
+			if (midr_is_qualcomm_cortex_a55_silver(midr)) {
+				/* Qualcomm-modified Cortex-A55 in Snapdragon 670 / 710 / 845 */
+				uint32_t l3_size = 1024 * 1024;
+				*l1i = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 4,
+					.line_size = 64,
+				};
+				*l1d = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 4,
+					.line_size = 64,
+				};
+				*l2 = (struct cpuinfo_cache) {
+					.size = 128 * 1024,
+					.associativity = 4,
+					.line_size = 64,
+				};
+				*l3 = (struct cpuinfo_cache) {
+					.size = l3_size,
+					.associativity = 16,
+					.line_size = 64,
+				};
+			} else {
+				/* Standard Cortex-A55 */
+
+				*l1i = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 4,
+					.line_size = 64,
+				};
+				*l1d = (struct cpuinfo_cache) {
+					.size = 32 * 1024,
+					.associativity = 4,
+					.line_size = 64,
+				};
+
+				uint32_t l3_size = 1024 * 1024;
+                *l2 = (struct cpuinfo_cache) {
+                    .size = 128 * 1024,
+                    .associativity = 4,
+                    .line_size = 64,
+                };
+                *l3 = (struct cpuinfo_cache) {
+                    .size = l3_size,
+                    /* DynamIQ */
+                    .associativity = 16,
+                    .line_size = 64,
+                };
+
+			}
+			break;
+		case cpuinfo_uarch_cortex_a57:
+			/*
+			 * ARM Cortex-A57 MPCore Processor Technical Reference Manual:
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches.
+			 *
+			 *   The L1 instruction memory system has the following features:
+			 *    - 48KB 3-way set-associative instruction cache.
+			 *    - Fixed line length of 64 bytes.
+			 *
+			 *   The L1 data memory system has the following features:
+			 *    - 32KB 2-way set-associative data cache.
+			 *    - Fixed line length of 64 bytes.
+			 *
+			 * 7.1 About the L2 memory system
+			 *   The features of the L2 memory system include:
+			 *    - Configurable L2 cache size of 512KB, 1MB, and 2MB.
+			 *    - Fixed line length of 64 bytes.
+			 *    - 16-way set-associative cache structure.
+			 *    - Inclusion property with L1 data caches.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Snapdragon 810     | 4(+4) |    32K    |    48K    |    2M     |    [1]    |
+			 *  | Exynos 7420        | 4(+4) |    32K    |    48K    |    2M     |    [2]    |
+			 *  | Jetson TX1         |   4   |    32K    |    48K    |    2M     |    [3]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.anandtech.com/show/9837/snapdragon-820-preview
+			 * [2] http://www.anandtech.com/show/9330/exynos-7420-deep-dive/2
+			 * [3] https://devblogs.nvidia.com/parallelforall/jetson-tx2-delivers-twice-intelligence-edge/
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 48 * 1024,
+				.associativity = 3,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 512 * 1024,
+				.associativity = 16,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE
+			};
+			break;
+		case cpuinfo_uarch_cortex_a65:
+		{
+			/*
+			 * ARM CortexA65 Core Technical Reference Manual
+			 * A6.1. About the L1 memory system
+			 *   The L1 memory system enhances the performance and power efficiency in the CortexA65 core.
+			 *   It consists of separate instruction and data caches. You can configure instruction and data caches
+			 *   independently during implementation to sizes of 32KB or 64KB.
+			 *
+			 *   L1 instruction-side memory system
+			 *   The L1 instruction-side memory system provides an instruction stream to the DPU. Its key features are:
+			 *    - 64-byte instruction side cache line length.
+			 *    - 4-way set associative L1 instruction cache.
+			 *
+			 *   L1 data-side memory system
+			 *    - 64-byte data side cache line length.
+			 *    - 4-way set associative L1 data cache.
+			 *
+			 * A7.1 About the L2 memory system
+			 *   The CortexA65 L2 memory system is required to interface the CortexA65 cores to the L3 memory system.
+			 *   The L2 memory subsystem consists of:
+			 *    - An optional 4-way, set-associative L2 cache with a configurable size of 64KB, 128KB, or 256KB.
+			 *      Cache lines have a fixed length of 64 bytes.
+			 *
+			 *   The main features of the L2 memory system are:
+			 *    - Strictly exclusive with L1 data cache.
+			 *    - Pseudo-inclusive with L1 instruction cache.
+			 *    - Private per-core unified L2 cache.
+			 */
+			const uint32_t l1_size = 32 * 1024;
+			const uint32_t l2_size = 128 * 1024;
+			const uint32_t l3_size = 512 * 1024;
+			*l1i = (struct cpuinfo_cache) {
+				.size = l1_size,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = l1_size,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = l2_size,
+				.associativity = 4,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = l3_size,
+				/* DynamIQ */
+				.associativity = 16,
+				.line_size = 64,
+			};
+			break;
+		}
+		case cpuinfo_uarch_cortex_a72:
+		{
+			/*
+			 * ARM Cortex-A72 MPCore Processor Technical Reference Manual
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches.
+			 *
+			 *   The L1 instruction memory system has the following features:
+			 *    - 48KB 3-way set-associative instruction cache.
+			 *    - Fixed line length of 64 bytes.
+			 *
+			 *   The L1 data memory system has the following features:
+			 *    - 32KB 2-way set-associative data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 * 7.1 About the L2 memory system
+			 *   The features of the L2 memory system include:
+			 *    - Configurable L2 cache size of 512KB, 1MB, 2MB and 4MB.
+			 *    - Fixed line length of 64 bytes.
+			 *    - Banked pipeline structures.
+			 *    - Inclusion property with L1 data caches.
+			 *    - 16-way set-associative cache structure.
+			 *
+			 *  +---------------------+---------+-----------+-----------+------------+-----------+
+			 *  | Processor model     | Cores   | L1D cache | L1I cache | L2 cache   | Reference |
+			 *  +---------------------+---------+-----------+-----------+------------+-----------+
+			 *  | Snapdragon 650      |  2(+4)  | 32K(+32K) | 48K(+32K) |  1M(+512K) |    [1]    |
+			 *  | Snapdragon 652      |  4(+4)  | 32K(+32K) | 48K(+32K) |  1M(+512K) |    [2]    |
+			 *  | Snapdragon 653      |  4(+4)  | 32K(+32K) | 48K(+32K) |  1M(+512K) |    [3]    |
+			 *  | HiSilicon Kirin 950 |  4(+4)  |  32K+32K  |  48K+32K  |     ?      |           |
+			 *  | HiSilicon Kirin 955 |  4(+4)  |  32K+32K  |  48K+32K  |     ?      |           |
+			 *  | MediaTek MT8173C    |  2(+2)  | 32K(+32K) | 48K(+32K) |  1M(+512K) |   sysfs   |
+			 *  | MediaTek Helio X20  | 2(+4+4) |     ?     |     ?     |     ?      |           |
+			 *  | MediaTek Helio X23  | 2(+4+4) |     ?     |     ?     |     ?      |           |
+			 *  | MediaTek Helio X25  | 2(+4+4) |     ?     |     ?     |     ?      |           |
+			 *  | MediaTek Helio X27  | 2(+4+4) |     ?     |     ?     |     ?      |           |
+			 *  | Broadcom BCM2711    |    4    |    32K    |    48K    |     1M     |    [4]    |
+			 *  +---------------------+---------+-----------+-----------+------------+-----------+
+			 *
+			 * [1] http://pdadb.net/index.php?m=processor&id=578&c=qualcomm_snapdragon_618_msm8956__snapdragon_650
+			 * [2] http://pdadb.net/index.php?m=processor&id=667&c=qualcomm_snapdragon_620_apq8076__snapdragon_652
+			 * [3] http://pdadb.net/index.php?m=processor&id=692&c=qualcomm_snapdragon_653_msm8976sg__msm8976_pro
+			 * [4] https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/README.md
+			 */
+			uint32_t l2_size;
+			l2_size = 1024 * 1024;
+			*l1i = (struct cpuinfo_cache) {
+				.size = 48 * 1024,
+				.associativity = 3,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 2,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = l2_size,
+				.associativity = 16,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE
+			};
+			break;
+		}
+		case cpuinfo_uarch_cortex_a73:
+		{
+			/*
+			 * ARM CortexA73 MPCore Processor Technical Reference Manual
+			 * 6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches.
+			 *   The size of the instruction cache is 64KB.
+			 *   The size of the data cache is configurable to either 32KB or 64KB.
+			 *
+			 *   The L1 instruction memory system has the following key features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), four-way set-associative instruction cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 *   The L1 data memory system has the following features:
+			 *    - ...the data cache behaves like an eight-way set associative PIPT cache (for 32KB configurations)
+			 *      and a 16-way set associative PIPT cache (for 64KB configurations).
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 * 7.1 About the L2 memory system
+			 *   The L2 memory system consists of:
+			 *    - A tightly-integrated L2 cache with:
+			 *      - A configurable size of 256KB, 512KB, 1MB, 2MB, 4MB, or 8MB.
+			 *      - A 16-way, set-associative structure.
+			 *      - A fixed line length of 64 bytes.
+			 *
+			 * The ARM Cortex A73 - Artemis Unveiled [1]
+			 *   "ARM still envisions that most vendors will choose to use configurations of 1 to
+			 *    2MB in consumer products. The L2 cache is inclusive of the L1 cache. "
+			 *
+			 *  +---------------------+---------+-----------+-----------+-----------+-----------+
+			 *  | Processor model     | Cores   | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +---------------------+---------+-----------+-----------+-----------+-----------+
+			 *  | HiSilicon Kirin 960 |  4(+4)  |  64K+32K  |  64K+32K  |     ?     |    [2]    |
+			 *  | MediaTek Helio X30  | 2(+4+4) |     ?     |  64K+ ?   |     ?     |           |
+			 *  | Snapdragon 636      |  4(+4)  | 64K(+32K) | 64K(+32K) |  1M(+1M)  |   sysfs   |
+			 *  | Snapdragon 660      |  4(+4)  |  64K+32K  |  64K+32K  |  1M(+1M)  |    [3]    |
+			 *  | Snapdragon 835      |  4(+4)  |  64K+32K  |  64K+32K  |  2M(+1M)  |   sysfs   |
+			 *  +---------------------+---------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.anandtech.com/show/10347/arm-cortex-a73-artemis-unveiled/2
+			 * [2] http://www.anandtech.com/show/11088/hisilicon-kirin-960-performance-and-power/3
+			 * [3] https://arstechnica.com/gadgets/2017/05/qualcomms-snapdragon-660-and-630-bring-more-high-end-features-to-midrange-chips/
+			 */
+			uint32_t l1d_size = 32 * 1024;
+			uint32_t l2_size = 512 * 1024;
+            switch (midr) {
+                case UINT32_C(0x51AF8001): /* Kryo 280 Gold */
+                    l1d_size = 64 * 1024;
+                    l2_size = 2 * 1024 * 1024;
+                    break;
+                case UINT32_C(0x51AF8002): /* Kryo 260 Gold */
+                    l1d_size = 64 * 1024;
+                    l2_size = 1 * 1024 * 1024;
+                    break;
+            }
+
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = l1d_size,
+				.associativity = (l1d_size >> 12),
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = l2_size,
+				.associativity = 16,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE
+			};
+			break;
+		}
+		case cpuinfo_uarch_cortex_a75:
+		{
+			/*
+			 * ARM Cortex-A75 Core Technical Reference Manual
+			 * A6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches. Both have a fixed size of 64KB.
+			 *
+			 * A6.1.1 L1 instruction-side memory system
+			 *   The L1 instruction memory system has the following key features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), four-way set-associative instruction cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 * A6.1.2 L1 data-side memory system
+			 *   The L1 data memory system has the following features:
+			 *    - Physically Indexed, Physically Tagged (PIPT), 16-way set-associative L1 data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *    - Pseudo-random cache replacement policy.
+			 *
+			 * A7.1 About the L2 memory system
+			 *   The L2 memory subsystem consist of:
+			 *    - An 8-way set associative L2 cache with a configurable size of 256KB or 512KB.
+			 *      Cache lines have a fixed length of 64 bytes.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | L3 cache | Reference  |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Snapdragon 845     | 4(+4) |    64K    |    64K    |    256K   |    2M    | [1], sysfs |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *
+			 * [1] https://www.anandtech.com/show/12114/qualcomm-announces-snapdragon-845-soc
+			 */
+			uint32_t l3_size = 1024 * 1024;
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 16,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 256 * 1024,
+				.associativity = 8,
+				.line_size = 64
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = l3_size,
+				.associativity = 16,
+				.line_size = 64
+			};
+			break;
+		}
+		case cpuinfo_uarch_cortex_a76:
+		{
+			/*
+			 * ARM Cortex-A76 Core Technical Reference Manual
+			 * A6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches. Both have a fixed size of 64KB.
+			 *
+			 * A6.1.1 L1 instruction-side memory system
+			 *   The L1 instruction memory system has the following key features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), which behaves as a Physically Indexed,
+			 *      Physically Tagged (PIPT) 4-way set-associative L1 data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 * A6.1.2 L1 data-side memory system
+			 *   The L1 data memory system has the following features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), which behaves as a Physically Indexed,
+			 *      Physically Tagged (PIPT) 4-way set-associative L1 data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *    - Pseudo-LRU cache replacement policy.
+			 *
+			 * A7.1 About the L2 memory system
+			 *   The L2 memory subsystem consist of:
+			 *    - An 8-way set associative L2 cache with a configurable size of 128KB, 256KB or 512KB.
+			 *      Cache lines have a fixed length of 64 bytes.
+			 *    - Strictly inclusive with L1 data cache. Weakly inclusive with L1 instruction cache.
+			 *    - Dynamic biased replacement policy.
+			 *    - Modified Exclusive Shared Invalid (MESI) coherency.
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | L3 cache | Reference  |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Kirin 980          | 4(+4) |    64K    |    64K    |    512K   |    4M    |  [1], [2]  |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *
+			 * [1] https://www.anandtech.com/show/13298/hisilicon-announces-the-kirin-980-first-a76-g76-on-7nm
+			 * [2] https://en.wikichip.org/wiki/hisilicon/kirin/980
+			 */
+			uint32_t l2_size = 256 * 1024;
+			uint32_t l3_size = 1024 * 1024;
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = l2_size,
+				.associativity = 8,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE,
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = l3_size,
+				.associativity = 16,
+				.line_size = 64,
+			};
+			break;
+		}
+		case cpuinfo_uarch_cortex_a77:
+		{
+			/*
+			 * ARM Cortex-A77 Core Technical Reference Manual
+			 * A6.1. About the L1 memory system
+			 *   The L1 memory system consists of separate instruction and data caches. Both have a fixed size of 64KB.
+			 *
+			 * A6.1.1 L1 instruction-side memory system
+			 *   The L1 instruction memory system has the following key features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), which behaves as a Physically Indexed,
+			 *      Physically Tagged (PIPT) 4-way set-associative L1 data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *
+			 * A6.1.2 L1 data-side memory system
+			 *   The L1 data memory system has the following features:
+			 *    - Virtually Indexed, Physically Tagged (VIPT), which behaves as a Physically Indexed,
+			 *      Physically Tagged (PIPT) 4-way set-associative L1 data cache.
+			 *    - Fixed cache line length of 64 bytes.
+			 *    - Pseudo-LRU cache replacement policy.
+			 *
+			 * A7.1 About the L2 memory system
+			 *   The L2 memory subsystem consist of:
+			 *    - An 8-way set associative L2 cache with a configurable size of 128KB, 256KB or 512KB. Cache lines
+			 *      have a fixed length of 64 bytes.
+			 *    - Strictly inclusive with L1 data cache. Weakly inclusive with L1 instruction cache.
+			 */
+			const uint32_t l2_size = 256 * 1024;
+			const uint32_t l3_size = 1024 * 1024;
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64,
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = l2_size,
+				.associativity = 8,
+				.line_size = 64,
+				.flags = CPUINFO_CACHE_INCLUSIVE,
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = l3_size,
+				.associativity = 16,
+				.line_size = 64,
+			};
+			break;
+		}
+#if CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_8A__)
+		case cpuinfo_uarch_scorpion:
+			/*
+			 * - "The CPU includes 32KB instruction and data caches as
+			 *    well as a complete memory-management unit (MMU) suitable
+			 *    for high-level operating systems. The CPU also has
+			 *    256KB of SRAM that can be allocated in 64KB increments
+			 *    to level-two (L2) cache or tightly coupled memory (TCM)." [1]
+			 *    We interpret it as L2 cache being 4-way set-associative on single-core Scorpion.
+			 * - L1 Data Cache = 32 KB. 32 B/line. [2]
+             * - L2 Cache = 256 KB. 128 B/line. [2]
+			 * - 256 KB (single-core) or 512 KB (dual-core) L2 cache [3]
+			 * - Single or dual-core configuration [3]
+			 * - For L1 cache assume the same associativity as Krait
+			 *
+			 * [1] https://www.qualcomm.com/media/documents/files/linley-report-on-dual-core-snapdragon.pdf
+			 * [2] http://www.7-cpu.com/cpu/Snapdragon.html
+			 * [3] https://en.wikipedia.org/wiki/Scorpion_(CPU)
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 32
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 256 * 1024,
+				.associativity = 4,
+				.line_size = 128
+			};
+			break;
+		case cpuinfo_uarch_krait:
+			/*
+			 * - L0 Data cache = 4 KB. 64 B/line, direct mapped [1]
+			 * - L0 Instruction cache = 4 KB. [1]
+			 * - L1 Data cache = 16 KB. 64 B/line, 4-way [1]
+			 * - L1 Instruction cache = 16 KB, 4-way [1]
+			 * - L2 Cache = 1 MB, 128 B/line, 8-way. Each core has fast access only to 512 KB of L2 cache. [1]
+			 * - L2	= 1MB (dual core) or 2MB (quad core), 8-way set associative [2]
+			 *
+			 * [1] http://www.7-cpu.com/cpu/Krait.html
+			 * [2] http://www.anandtech.com/show/4940/qualcomm-new-snapdragon-s4-msm8960-krait-architecture/2
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 16 * 1024,
+				.associativity = 4,
+				.line_size = 64 /* assume same as L1D */
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 16 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 512 * 1024,
+				.associativity = 8,
+				.line_size = 128
+			};
+			break;
+#endif /* CPUINFO_ARCH_ARM && !defined(__ARM_ARCH_8A__) */
+		case cpuinfo_uarch_kryo:
+			/*
+			 *  +-----------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +-----------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Snapdragon 820  |  2+2  |    24K    |    32K    |  1M+512K  |   [1, 2]  |
+			 *  | Snapdragon 821  |  2+2  |     ?     |     ?     |  1M+512K  |    [1]    |
+			 *  +-----------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.anandtech.com/show/9837/snapdragon-820-preview/2
+			 * [2] https://www.inforcecomputing.com/public_docs/Inforce6601/Inforce_6601_Micro-SOM_FAQs_04-2016-1.pdf
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 24 * 1024,
+				.associativity = 3,
+				.line_size = 64
+			};
+			if (midr_is_kryo_silver(midr)) {
+				/* Kryo "Silver" */
+				*l2 = (struct cpuinfo_cache) {
+					.size = 512 * 1024,
+					.associativity = 8,
+					.line_size = 128
+				};
+			} else {
+				/* Kryo "Gold" */
+				*l2 = (struct cpuinfo_cache) {
+					.size = 1024 * 1024,
+					.associativity = 8,
+					.line_size = 128
+				};
+			}
+			break;
+		case cpuinfo_uarch_denver:
+		case cpuinfo_uarch_denver2:
+			/*
+			 * The Denver chip includes a 128KB, 4-way level 1 instruction cache, a 64KB, 4-way level 2 data cache,
+			 * and a 2MB, 16-way level 2 cache, all of which can service both cores. [1]
+			 *
+			 * All the caches have 64-byte lines. [2]
+			 *
+			 * [1] http://www.pcworld.com/article/2463900/nvidia-reveals-pc-like-performance-for-denver-tegra-k1.html
+			 * [2] http://linleygroup.com/newsletters/newsletter_detail.php?num=5205&year=2014
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 128 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 2 * 1024 * 1024,
+				.associativity = 16,
+				.line_size = 64
+			};
+			break;
+		case cpuinfo_uarch_exynos_m1:
+		case cpuinfo_uarch_exynos_m2:
+			/*
+			 * - "Moving past branch prediction we can see some elements of how the cache is set up for the L1 I$,
+			 *    namely 64 KB split into four sets with 128-byte line sizes for 128 cache lines per set" [1]
+			 * - "For loads and stores, a 32 KB, 8-way set associative cache with 64 byte line size is used" [1]
+			 * - "The L2 cache here is 2MB shared across all cores split into 16 sets. This memory is also split
+			 *    into 4 banks and has a 22 cycle latency" [1]
+			 *
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | Reference |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *  | Exynos 8 Octa 8890 | 4(+4) |    64K    |    32K    |    2M     |    [1]    |
+			 *  | Exynos 8 Octa 8895 | 4(+4) |    64K    |    32K    |    2M     |    [2]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+-----------+
+			 *
+			 * [1] http://www.anandtech.com/show/10590/hot-chips-2016-exynos-m1-architecture-disclosed
+			 * [2] https://www.extremetech.com/mobile/244949-samsungs-exynos-8895-features-custom-cpu-cores-first-10nm-chip-market
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4,
+				.line_size = 128
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 8,
+				.line_size = 64
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 2 * 1024 * 1024,
+				.associativity = 16,
+				.line_size = 64
+			};
+			break;
+		case cpuinfo_uarch_exynos_m3:
+			/*
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Processor model    | Cores | L1D cache | L1I cache | L2 cache  | L3 cache | Reference  |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *  | Exynos 9810        | 4(+4) |    64K    |     ?     |    512K   |    4M    |     [1]    |
+			 *  +--------------------+-------+-----------+-----------+-----------+----------+------------+
+			 *
+			 * [1] https://www.anandtech.com/show/12478/exynos-9810-handson-awkward-first-results
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024 /* assume same as in Exynos M1/M2 cores */,
+				.associativity = 4 /* assume same as in Exynos M1/M2 cores */,
+				.line_size = 128 /* assume same as in Exynos M1/M2 cores */
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 8 /* assume same as in Exynos M1/M2 cores */,
+				.line_size = 64 /* assume same as in Exynos M1/M2 cores */,
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 512 * 1024,
+				.associativity = 16 /* assume same as in Exynos M1/M2 cores */,
+				.line_size = 64 /* assume same as in Exynos M1/M2 cores */,
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = 4 * 1024 * 1024,
+				.associativity = 16 /* assume DynamIQ cache */,
+				.line_size = 64 /* assume DynamIQ cache */,
+			};
+			break;
+#if CPUINFO_ARCH_ARM64 && !defined(__ANDROID__)
+		case cpuinfo_uarch_thunderx:
+			/*
+			 * "78K-Icache and 32K-D cache per core, 16 MB shared L2 cache" [1]
+			 *
+			 * [1] https://www.cavium.com/pdfFiles/ThunderX_CP_PB_Rev1.pdf
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 78 * 1024,
+				.associativity = 4 /* assumption */,
+				.line_size = 64 /* assumption */
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 32 * 1024,
+				.associativity = 4 /* assumption */,
+				.line_size = 64 /* assumption */
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 16 * 1024 * 1024,
+				.associativity = 8 /* assumption */,
+				.line_size = 64 /* assumption */
+			};
+			break;
+		case cpuinfo_uarch_taishan_v110:
+			/*
+			 * It features private 64 KiB L1 instruction and data caches as well as 512 KiB of private L2. [1]
+			 *
+			 *  +------------------+-------+-----------+-----------+-----------+----------+-----------+
+			 *  | Processor model  | Cores | L1D cache | L1I cache | L2 cache  | L3 cache | Reference |
+			 *  +------------------+-------+-----------+-----------+-----------+----------+-----------+
+			 *  | Kunpeng 920-3226 |  32   |    64K    |    64K    |    512K   |    32M   |     [2]   |
+			 *  +------------------+-------+-----------+-----------+-----------+----------+-----------+
+			 *  | Kunpeng 920-4826 |  48   |    64K    |    64K    |    512K   |    48M   |     [3]   |
+			 *  +------------------+-------+-----------+-----------+-----------+----------+-----------+
+			 *  | Kunpeng 920-6426 |  64   |    64K    |    64K    |    512K   |    64M   |     [4]   |
+			 *  +------------------+-------+-----------+-----------+-----------+----------+-----------+
+			 *
+			 * [1] https://en.wikichip.org/wiki/hisilicon/microarchitectures/taishan_v110
+			 * [2] https://en.wikichip.org/wiki/hisilicon/kunpeng/920-3226
+			 * [3] https://en.wikichip.org/wiki/hisilicon/kunpeng/920-4826
+			 * [4] https://en.wikichip.org/wiki/hisilicon/kunpeng/920-6426
+			 */
+			*l1i = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4 /* assumption */,
+				.line_size = 128 /* assumption */,
+			};
+			*l1d = (struct cpuinfo_cache) {
+				.size = 64 * 1024,
+				.associativity = 4 /* assumption */,
+				.line_size = 128 /* assumption */,
+			};
+			*l2 = (struct cpuinfo_cache) {
+				.size = 512 * 1024,
+				.associativity = 8 /* assumption */,
+				.line_size = 128 /* assumption */,
+				.flags = CPUINFO_CACHE_INCLUSIVE /* assumption */,
+			};
+			*l3 = (struct cpuinfo_cache) {
+				.size = cluster_cores * 1024 * 1024,
+				.associativity = 16 /* assumption */,
+				.line_size = 128 /* assumption */,
+			};
+			break;
+#endif
+		case cpuinfo_uarch_cortex_a12:
+		case cpuinfo_uarch_cortex_a32:
+		default:
+			cpuinfo_log_warning("target uarch not recognized; using generic cache parameters");
+			/* Follow OpenBLAS */
+            *l1i = (struct cpuinfo_cache) {
+                .size = 32 * 1024,
+                .associativity = 4,
+                .line_size = 64
+            };
+            *l1d = (struct cpuinfo_cache) {
+                .size = 32 * 1024,
+                .associativity = 4,
+                .line_size = 64
+            };
+            *l2 = (struct cpuinfo_cache) {
+                .size = cluster_cores * 256 * 1024,
+                .associativity = 8,
+                .line_size = 64
+            };
+			break;
+	}
+	l1i->sets = l1i->size / (l1i->associativity * l1i->line_size);
+	l1i->partitions = 1;
+	l1d->sets = l1d->size / (l1d->associativity * l1d->line_size);
+	l1d->partitions = 1;
+	if (l2->size != 0) {
+		l2->sets = l2->size / (l2->associativity * l2->line_size);
+		l2->partitions = 1;
+		if (l3->size != 0) {
+			l3->sets = l3->size / (l3->associativity * l3->line_size);
+			l3->partitions = 1;
+		}
+	}
+}
+
+uint32_t cpuinfo_arm_compute_max_cache_size(const struct cpuinfo_processor* processor) {
+	/*
+	 * There is no precise way to detect cache size on ARM/ARM64, and cache size reported by cpuinfo
+	 * may underestimate the actual cache size. Thus, we use microarchitecture-specific maximum.
+	 */
+	switch (processor->core->uarch) {
+		case cpuinfo_uarch_xscale:
+		case cpuinfo_uarch_arm11:
+		case cpuinfo_uarch_scorpion:
+		case cpuinfo_uarch_krait:
+		case cpuinfo_uarch_kryo:
+		case cpuinfo_uarch_exynos_m1:
+		case cpuinfo_uarch_exynos_m2:
+		case cpuinfo_uarch_exynos_m3:
+			/* cpuinfo-detected cache size always correct */
+			return cpuinfo_compute_max_cache_size(processor);
+		case cpuinfo_uarch_cortex_a5:
+			/* Max observed (NXP Vybrid SoC) */
+			return 512 * 1024;
+		case cpuinfo_uarch_cortex_a7:
+			/*
+			 * Cortex-A7 MPCore Technical Reference Manual:
+			 * 7.1. About the L2 Memory system
+			 *   The L2 memory system consists of an:
+			 *    - Optional tightly-coupled L2 cache that includes:
+			 *      - Configurable L2 cache size of 128KB, 256KB, 512KB, and 1MB.
+			 */
+			return 1024 * 1024;
+		case cpuinfo_uarch_cortex_a8:
+			/*
+			 * Cortex-A8 Technical Reference Manual:
+			 * 8.1. About the L2 memory system
+			 *   The key features of the L2 memory system include:
+			 *    - configurable cache size of 0KB, 128KB, 256KB, 512KB, and 1MB
+			 */
+			return 1024 * 1024;
+		case cpuinfo_uarch_cortex_a9:
+			/* Max observed (e.g. Exynos 4212) */
+			return 1024 * 1024;
+		case cpuinfo_uarch_cortex_a12:
+		case cpuinfo_uarch_cortex_a17:
+			/*
+			 * ARM Cortex-A17 MPCore Processor Technical Reference Manual:
+			 * 7.1. About the L2 Memory system
+			 *   The key features of the L2 memory system include:
+			 *    - An integrated L2 cache:
+			 *      - The cache size is implemented as either 256KB, 512KB, 1MB, 2MB, 4MB or 8MB.
+			 */
+			return 8 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a15:
+			/*
+			 * ARM Cortex-A15 MPCore Processor Technical Reference Manual:
+			 * 7.1. About the L2 memory system
+			 *   The features of the L2 memory system include:
+			 *    - Configurable L2 cache size of 512KB, 1MB, 2MB and 4MB.
+			 */
+			return 4 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a35:
+			/*
+			 * ARM CortexA35 Processor Technical Reference Manual:
+			 * 7.1 About the L2 memory system
+			 *   L2 cache
+			 *    - Further features of the L2 cache are:
+			 *      - Configurable size of 128KB, 256KB, 512KB, and 1MB.
+			 */
+			return 1024 * 1024;
+		case cpuinfo_uarch_cortex_a53:
+			/*
+			 * ARM Cortex-A53 MPCore Processor Technical Reference Manual:
+			 * 7.1. About the L2 memory system
+			 *   The L2 memory system consists of an:
+			 *    - Optional tightly-coupled L2 cache that includes:
+			 *      - Configurable L2 cache size of 128KB, 256KB, 512KB, 1MB and 2MB.
+			 */
+			return 2 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a57:
+			/*
+			 * ARM Cortex-A57 MPCore Processor Technical Reference Manual:
+			 * 7.1 About the L2 memory system
+			 *   The features of the L2 memory system include:
+			 *    - Configurable L2 cache size of 512KB, 1MB, and 2MB.
+			 */
+			return 2 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a72:
+			/*
+			 * ARM Cortex-A72 MPCore Processor Technical Reference Manual:
+			 * 7.1 About the L2 memory system
+			 *   The features of the L2 memory system include:
+			 *    - Configurable L2 cache size of 512KB, 1MB, 2MB and 4MB.
+			 */
+			return 4 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a73:
+			/*
+			 * ARM CortexA73 MPCore Processor Technical Reference Manual
+			 * 7.1 About the L2 memory system
+			 *   The L2 memory system consists of:
+			 *    - A tightly-integrated L2 cache with:
+			 *       - A configurable size of 256KB, 512KB, 1MB, 2MB, 4MB, or 8MB.
+			 */
+			return 8 * 1024 * 1024;
+		case cpuinfo_uarch_cortex_a55:
+		case cpuinfo_uarch_cortex_a75:
+		case cpuinfo_uarch_cortex_a76:
+		case cpuinfo_uarch_exynos_m4:
+		default:
+			/*
+			 * ARM DynamIQ Shared Unit Technical Reference Manual
+			 * 1.3 Implementation options
+			 *   L3_CACHE_SIZE
+			 *    - 256KB
+			 *    - 512KB
+			 *    - 1024KB
+			 *    - 1536KB
+			 *    - 2048KB
+			 *    - 3072KB
+			 *    - 4096KB
+			 */
+			return 4 * 1024 * 1024;
+	}
+}
+
+#endif
diff --git a/src/qnx/api.h b/src/qnx/api.h
new file mode 100644
index 0000000..79da908
--- /dev/null
+++ b/src/qnx/api.h
@@ -0,0 +1,36 @@
+#ifndef __QNX_API__
+#define __QNX_API__
+
+#define MAX_PROCESSOR	8
+#define MAX_CACHE	5 // -> L1i, L1d, L2, L3, L4
+
+extern struct cpuinfo_processor * qnx_processors;
+extern struct cpuinfo_cache * qnx_cache;
+extern struct cpuinfo_core * qnx_core;
+extern struct cpuinfo_cluster * qnx_cluster;
+extern struct cpuinfo_package * qnx_package;
+
+void cpuinfo_qnx_init();
+int cpuinfo_qnx_fill_processors_info(struct cpuinfo_processor * processor_list);
+const struct cpuinfo_processor * cpuinfo_qnx_get_processor(uint32_t index);
+const struct cpuinfo_core* cpuinfo_qnx_get_core(void);
+const struct cpuinfo_cluster* cpuinfo_qnx_get_cluster(void);
+const struct cpuinfo_package* cpuinfo_qnx_get_package(void);
+uint32_t cpuinfo_qnx_get_processors_count(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1i_caches(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1d_caches(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l2_caches(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l3_caches(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l4_caches(void);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1i_cache(uint32_t index);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l1d_cache(uint32_t index);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l2_cache(uint32_t index);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l3_cache(uint32_t index);
+const struct cpuinfo_cache* cpuinfo_qnx_get_l4_cache(uint32_t index);
+enum cpuinfo_uarch cpuinfo_qnx_get_uarch();
+enum cpuinfo_vendor cpuinfo_qnx_get_vendor();
+void cpuinfo_qnx_deinit();
+void cpuinfo_arm_qnx_decode_cache( enum cpuinfo_uarch uarch, uint32_t cluster_cores, uint32_t midr, struct cpuinfo_cache l1i[restrict static 1], struct cpuinfo_cache l1d[restrict static 1], struct cpuinfo_cache l2[restrict static 1], struct cpuinfo_cache l3[restrict static 1]);
+uint32_t cpuinfo_arm_compute_max_cache_size(const struct cpuinfo_processor* processor);
+
+#endif // __QNX_API__
