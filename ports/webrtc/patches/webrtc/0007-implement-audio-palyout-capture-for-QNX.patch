From 84963306204ddae965201743ffb5f5f4acee97d9 Mon Sep 17 00:00:00 2001
From: Yongxin Dai <yodai@blackberry.com>
Date: Fri, 14 Apr 2023 15:45:05 -0400
Subject: [PATCH] implement audio palyout/capture for QNX

---
 media/engine/adm_helpers.cc                   |    6 +
 modules/audio_coding/neteq/neteq_impl.cc      |    8 +-
 modules/audio_device/BUILD.gn                 |   15 +-
 modules/audio_device/audio_device_buffer.cc   |   28 +
 modules/audio_device/audio_device_buffer.h    |    3 +
 modules/audio_device/audio_device_impl.cc     |   12 +
 modules/audio_device/audio_device_impl.h      |    1 +
 modules/audio_device/qnx/audio_device_qnx.cc  | 1738 +++++++++++++++++
 modules/audio_device/qnx/audio_device_qnx.h   |  214 ++
 .../qnx/audio_mixer_manager_qnx.cc            |  497 +++++
 .../qnx/audio_mixer_manager_qnx.h             |   64 +
 .../audio_device/qnx/qsasymboltable_qnx.cc    |   40 +
 modules/audio_device/qnx/qsasymboltable_qnx.h |   82 +
 modules/audio_mixer/audio_mixer_impl.cc       |    8 +
 14 files changed, 2714 insertions(+), 2 deletions(-)
 create mode 100644 modules/audio_device/qnx/audio_device_qnx.cc
 create mode 100644 modules/audio_device/qnx/audio_device_qnx.h
 create mode 100644 modules/audio_device/qnx/audio_mixer_manager_qnx.cc
 create mode 100644 modules/audio_device/qnx/audio_mixer_manager_qnx.h
 create mode 100644 modules/audio_device/qnx/qsasymboltable_qnx.cc
 create mode 100644 modules/audio_device/qnx/qsasymboltable_qnx.h

diff --git a/media/engine/adm_helpers.cc b/media/engine/adm_helpers.cc
index 12dfbc9bbe..3aaf89d4a2 100644
--- a/media/engine/adm_helpers.cc
+++ b/media/engine/adm_helpers.cc
@@ -44,9 +44,13 @@ void Init(AudioDeviceModule* adm) {
       RTC_LOG(LS_ERROR) << "Unable to set playout device.";
       return;
     }
+#if !defined(WEBRTC_QNX)
+    // the mixer device will be obtained from snd_pcm_channel_setup object
+    // postpone InitSpeaker() until the channel is setup
     if (adm->InitSpeaker() != 0) {
       RTC_LOG(LS_ERROR) << "Unable to access speaker.";
     }
+#endif
 
     // Set number of channels
     bool available = false;
@@ -64,9 +68,11 @@ void Init(AudioDeviceModule* adm) {
       RTC_LOG(LS_ERROR) << "Unable to set recording device.";
       return;
     }
+#if !defined(WEBRTC_QNX)
     if (adm->InitMicrophone() != 0) {
       RTC_LOG(LS_ERROR) << "Unable to access microphone.";
     }
+#endif
 
     // Set number of channels
     bool available = false;
diff --git a/modules/audio_coding/neteq/neteq_impl.cc b/modules/audio_coding/neteq/neteq_impl.cc
index 6a9371c7f7..fec8cfb23a 100644
--- a/modules/audio_coding/neteq/neteq_impl.cc
+++ b/modules/audio_coding/neteq/neteq_impl.cc
@@ -202,10 +202,16 @@ int NetEqImpl::GetAudio(AudioFrame* audio_frame,
     return kFail;
   }
   stats_->IncreaseCounter(output_size_samples_, fs_hz_);
+#if defined(WEBRTC_QNX)
+  RTC_DCHECK_EQ(
+      audio_frame->sample_rate_hz_,
+      rtc::dchecked_cast<int>(audio_frame->samples_per_channel_ * 1000 / kOutputSizeMs));
+#else
   RTC_DCHECK_EQ(
       audio_frame->sample_rate_hz_,
       rtc::dchecked_cast<int>(audio_frame->samples_per_channel_ * 100));
-  if (muted != nullptr) {
+#endif
+ if (muted != nullptr) {
     *muted = audio_frame->muted();
   }
   audio_frame->speech_type_ = ToSpeechType(LastOutputType());
diff --git a/modules/audio_device/BUILD.gn b/modules/audio_device/BUILD.gn
index b69ada7f31..631d52afca 100644
--- a/modules/audio_device/BUILD.gn
+++ b/modules/audio_device/BUILD.gn
@@ -389,6 +389,19 @@ rtc_library("audio_device_impl") {
           "../../rtc_base/win:scoped_com_initializer",
         ]
       }
+      if (is_qnx) {
+        sources += [
+          "qnx/audio_device_qnx.cc",
+          "qnx/audio_device_qnx.h",
+          "qnx/audio_mixer_manager_qnx.cc",
+          "qnx/audio_mixer_manager_qnx.h",
+          "qnx/qsasymboltable_qnx.cc",
+          "qnx/qsasymboltable_qnx.h",
+        ]
+        deps += [
+          "../utility:late_binding_symbol_table",
+        ]
+      }
       configs += [ ":audio_device_warnings_config" ]
     }
   } else {
@@ -476,7 +489,7 @@ if (rtc_include_tests && !build_with_chromium) {
       "../../test:test_support",
       "../../test/time_controller",
     ]
-    if (is_linux || is_chromeos || is_mac || is_win) {
+    if (is_linux || is_chromeos || is_mac || is_win || is_qnx) {
       sources += [ "audio_device_unittest.cc" ]
     }
     if (is_win) {
diff --git a/modules/audio_device/audio_device_buffer.cc b/modules/audio_device/audio_device_buffer.cc
index 95096da8e6..b579cf0b83 100644
--- a/modules/audio_device/audio_device_buffer.cc
+++ b/modules/audio_device/audio_device_buffer.cc
@@ -302,7 +302,9 @@ int32_t AudioDeviceBuffer::SetRecordedBuffer(
   }
   // Update recording stats which is used as base for periodic logging of the
   // audio input state.
+#if !defined(WEBRTC_QNX)
   UpdateRecStats(max_abs, samples_per_channel);
+#endif
   return 0;
 }
 
@@ -398,6 +400,32 @@ int32_t AudioDeviceBuffer::GetPlayoutData(void* audio_buffer) {
   return static_cast<int32_t>(play_buffer_.size() / play_channels_);
 }
 
+#if defined(WEBRTC_QNX)
+int AudioDeviceBuffer::GetMoreAudioData(void* data,
+                                        size_t samples_per_channel) {
+  size_t num_samples_out(0);
+  // It is currently supported to start playout without a valid audio
+  // transport object. Leads to warning and silence.
+  if (!audio_transport_cb_) {
+    RTC_LOG(LS_WARNING) << "Invalid audio transport";
+    return 0;
+  }
+
+  // Retrieve new 16-bit PCM audio data using the audio transport instance.
+  int64_t elapsed_time_ms = -1;
+  int64_t ntp_time_ms = -1;
+  const size_t bytes_per_frame = play_channels_ * sizeof(int16_t);
+  uint32_t res = audio_transport_cb_->NeedMorePlayData(
+      samples_per_channel, bytes_per_frame, play_channels_, play_sample_rate_,
+      data, num_samples_out, &elapsed_time_ms, &ntp_time_ms);
+  if (res != 0) {
+    RTC_LOG(LS_ERROR) << "NeedMorePlayData() failed";
+    return -1;
+  }
+  return num_samples_out * sizeof(int16_t);
+}
+#endif
+
 void AudioDeviceBuffer::StartPeriodicLogging() {
   task_queue_->PostTask([this] { LogStats(AudioDeviceBuffer::LOG_START); });
 }
diff --git a/modules/audio_device/audio_device_buffer.h b/modules/audio_device/audio_device_buffer.h
index 99a4cb7d1a..c319503931 100644
--- a/modules/audio_device/audio_device_buffer.h
+++ b/modules/audio_device/audio_device_buffer.h
@@ -117,6 +117,9 @@ class AudioDeviceBuffer {
 
   virtual int32_t RequestPlayoutData(size_t samples_per_channel);
   virtual int32_t GetPlayoutData(void* audio_buffer);
+#if defined(WEBRTC_QNX)
+  int GetMoreAudioData(void* data, size_t samples_per_channel);
+#endif
 
   int32_t SetTypingStatus(bool typing_status);
 
diff --git a/modules/audio_device/audio_device_impl.cc b/modules/audio_device/audio_device_impl.cc
index 622be1b8f0..f6c7091357 100644
--- a/modules/audio_device/audio_device_impl.cc
+++ b/modules/audio_device/audio_device_impl.cc
@@ -38,6 +38,8 @@
 #include "sdk/objc/native/src/audio/audio_device_ios.h"
 #elif defined(WEBRTC_MAC)
 #include "modules/audio_device/mac/audio_device_mac.h"
+#elif defined(WEBRTC_QNX)
+#include "modules/audio_device/qnx/audio_device_qnx.h"
 #endif
 #if defined(WEBRTC_DUMMY_FILE_DEVICES)
 #include "modules/audio_device/dummy/file_audio_device.h"
@@ -153,6 +155,9 @@ int32_t AudioDeviceModuleImpl::CheckPlatform() {
 #elif defined(WEBRTC_FUCHSIA)
   platform = kPlatformFuchsia;
   RTC_LOG(LS_INFO) << "current platform is Fuchsia";
+#elif defined(WEBRTC_QNX)
+  platform = kPlatformQNX;
+  RTC_LOG(LS_INFO) << "current platform is QNX";
 #endif
   if (platform == kPlatformNotSupported) {
     RTC_LOG(LS_ERROR)
@@ -254,6 +259,13 @@ int32_t AudioDeviceModuleImpl::CreatePlatformSpecificObjects() {
   }
 #endif  // WEBRTC_MAC
 
+#if defined(WEBRTC_QNX)
+  if (audio_layer == kPlatformDefaultAudio) {
+    audio_device_.reset(new AudioDeviceQnx());
+    RTC_LOG(LS_WARNING) << "QNX ALSA APIs will be utilized.";
+  }
+#endif
+
   // Dummy ADM implementation.
   if (audio_layer == kDummyAudio) {
     audio_device_.reset(new AudioDeviceDummy());
diff --git a/modules/audio_device/audio_device_impl.h b/modules/audio_device/audio_device_impl.h
index 41d68209e8..6ca4894f13 100644
--- a/modules/audio_device/audio_device_impl.h
+++ b/modules/audio_device/audio_device_impl.h
@@ -40,6 +40,7 @@ class AudioDeviceModuleImpl : public AudioDeviceModuleForTest {
     // `CreatePlatformSpecificObjects()` call will fail unless usable
     // implementation will be provided by the user.
     kPlatformFuchsia = 7,
+    kPlatformQNX = 8
   };
 
   int32_t CheckPlatform();
diff --git a/modules/audio_device/qnx/audio_device_qnx.cc b/modules/audio_device/qnx/audio_device_qnx.cc
new file mode 100644
index 0000000000..360683c66f
--- /dev/null
+++ b/modules/audio_device/qnx/audio_device_qnx.cc
@@ -0,0 +1,1738 @@
+/*
+ *  Copyright (c) 2023 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_device/qnx/audio_device_qnx.h"
+
+#include <assert.h>
+#include <math.h>
+#include <poll.h>
+
+#include <algorithm>
+#include <limits>
+#include <numeric>
+
+#include "modules/audio_device/audio_device_config.h"
+#include "rtc_base/logging.h"
+#include "rtc_base/system/arch.h"
+#include "system_wrappers/include/sleep.h"
+
+WebRTCQsaSymbolTable* GetQsaSymbolTable() {
+  static WebRTCQsaSymbolTable* alsa_symbol_table = new WebRTCQsaSymbolTable();
+  return alsa_symbol_table;
+}
+
+// Accesses ALSA functions through our late-binding symbol table instead of
+// directly. This way we don't have to link to libasound, which means our binary
+// will work on systems that don't have it.
+#define LATE(sym) \
+  LATESYM_GET(webrtc::adm_qnx_qsa::QsaSymbolTable, GetQsaSymbolTable(), sym)
+
+void WebrtcAlsaErrorHandler(const char* file,
+                            int line,
+                            const char* function,
+                            int err,
+                            const char* fmt,
+                            ...) {}
+
+namespace webrtc {
+namespace {
+// this has to be 10ms with current WebRTC implementation
+constexpr uint8_t SINGLE_BUFFER_DURATION_IN_MS = 10;
+constexpr uint8_t CHAR_BASE = 48;
+
+std::unique_ptr<char[]> valueFromEnv(const char* name) {
+  char* value = getenv(name);
+  if (!value)
+    return std::unique_ptr<char[]>{};
+  std::string raw(value);
+  size_t pos = raw.find(':');
+  if (pos == std::string::npos)
+    return std::unique_ptr<char[]>{};
+  int card = std::atoi(raw.substr(0, pos).data());
+  int device = std::atoi(raw.substr(pos + 1).data());
+  std::unique_ptr<char[]> buf(new char[3]);
+  buf[0] = (char)(card + CHAR_BASE);
+  buf[1] = (char)(device + CHAR_BASE);
+  buf[2] = '\0';
+  return std::move(buf);
+}
+
+const char* targetedPlayDev() {
+  static std::unique_ptr<char[]> playout =
+      valueFromEnv("WEBRTC_AUDIO_PLAY_DEVICE");
+  return playout.get();
+}
+
+const char* targetedRecordDev() {
+  static std::unique_ptr<char[]> record =
+      valueFromEnv("WEBRTC_AUDIO_RECORD_DEVICE");
+  return record.get();
+}
+
+#if defined(WEBRTC_ARCH_BIG_ENDIAN)
+constexpr unsigned QSA_FORMAT = SND_PCM_SFMT_S16_BE;
+#else
+constexpr unsigned QSA_FORMAT = SND_PCM_SFMT_S16_LE;
+#endif
+constexpr uint8_t FRAME_BYTES = 2;
+
+uint32_t toRateFlag(uint32_t rate) {
+  uint32_t flag;
+  switch (rate) {
+    case 8000:
+      flag = SND_PCM_RATE_8000;
+      break;
+    case 11025:
+      flag = SND_PCM_RATE_11025;
+      break;
+    case 12000:
+      flag = SND_PCM_RATE_12000;
+      break;
+    case 16000:
+      flag = SND_PCM_RATE_16000;
+      break;
+    case 18900:
+      flag = SND_PCM_RATE_18900;
+      break;
+    case 22050:
+      flag = SND_PCM_RATE_22050;
+      break;
+    case 24000:
+      flag = SND_PCM_RATE_24000;
+      break;
+    case 32000:
+      flag = SND_PCM_RATE_32000;
+      break;
+    case 44100:
+      flag = SND_PCM_RATE_44100;
+      break;
+    case 48000:
+      flag = SND_PCM_RATE_48000;
+      break;
+    case 64000:
+      flag = SND_PCM_RATE_64000;
+      break;
+    case 88200:
+      flag = SND_PCM_RATE_88200;
+      break;
+    case 96000:
+      flag = SND_PCM_RATE_96000;
+      break;
+    case 176400:
+      flag = SND_PCM_RATE_176400;
+      break;
+    case 192000:
+      flag = SND_PCM_RATE_192000;
+      break;
+    default:
+      RTC_CHECK_NOTREACHED();
+  }
+  return flag;
+}
+
+int32_t channelStatus(snd_pcm_t* handle,
+                      int32_t channel,
+                      snd_pcm_channel_status_t* status) {
+  memset(status, 0, sizeof(snd_pcm_channel_status_t));
+  status->channel = channel;
+  int err = LATE(snd_pcm_plugin_status)(handle, status);
+  if (err != EOK) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_status error: "
+                      << LATE(snd_strerror)(err);
+    return err;
+  }
+  return status->status;
+}
+
+int32_t channelStatus(snd_pcm_t* handle, int32_t channel) {
+  snd_pcm_channel_status_t status;
+  return channelStatus(handle, channel, &status);
+}
+
+int32_t channelInfo(snd_pcm_t* handle,
+                    int32_t channel,
+                    snd_pcm_channel_info_t& info) {
+  memset(&info, 0, sizeof(snd_pcm_channel_info_t));
+  info.channel = channel;
+  int err = LATE(snd_pcm_plugin_info)(handle, &info);
+  if (err != EOK) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_info error: "
+                      << LATE(snd_strerror)(err) << " (" << err << ")";
+    return -1;
+  }
+  return 0;
+}
+
+int snd_pcm_wait(int32_t fd, short events, int timeout) {
+  struct pollfd pullFD;
+  pullFD.fd = fd;
+  pullFD.events = events;
+  return poll(&pullFD, 1, timeout);
+}
+
+int close_pcm_dev(snd_pcm_t* handle) {
+  int err(EOK);
+  while ((err = LATE(snd_pcm_close)(handle)) == -EINTR)
+    ;
+  if (err != EOK) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_close error: " << LATE(snd_strerror)(err)
+                      << " (" << err << ")";
+  }
+  return err;
+}
+}  // namespace
+static const unsigned int ALSA_PLAYOUT_FREQ = 48000;
+static const unsigned int ALSA_PLAYOUT_CH = 2;
+static const unsigned int ALSA_PLAYOUT_LATENCY = 40 * 1000;  // in us
+static const unsigned int ALSA_PLAYOUT_WAIT_TIMEOUT = 3;     // in ms
+static const unsigned int ALSA_CAPTURE_FREQ = 48000;
+static const unsigned int ALSA_CAPTURE_CH = 2;
+static const unsigned int ALSA_CAPTURE_LATENCY = 40 * 1000;  // in us
+static const unsigned int ALSA_CAPTURE_WAIT_TIMEOUT = 5;     // in ms
+
+#define FUNC_GET_NUM_OF_DEVICE 0
+#define FUNC_GET_DEVICE_NAME 1
+#define FUNC_GET_DEVICE_NAME_FOR_AN_ENUM 2
+
+AudioDeviceQnx::AudioDeviceQnx()
+    : _ptrAudioBuffer(NULL),
+      _inputDeviceIndex(0),
+      _outputDeviceIndex(0),
+      _inputDeviceIsSpecified(false),
+      _outputDeviceIsSpecified(false),
+      _handleRecord(NULL),
+      _handlePlayout(NULL),
+      _recordingBuffersizeInFrame(0),
+      _recordingPeriodSizeInFrame(0),
+      _playoutBufferSizeInFrame(0),
+      _playoutPeriodSizeInFrame(0),
+      _recordingBufferSizeInNMS(0),
+      _playoutBufferSizeInNMS(0),
+      _recordingFramesInNMS(0),
+      _playoutFramesInNMS(0),
+      _recordingFreq(ALSA_CAPTURE_FREQ),
+      _playoutFreq(ALSA_PLAYOUT_FREQ),
+      _recChannels(std::numeric_limits<uint8_t>::max()),
+      _playChannels(ALSA_PLAYOUT_CH),
+      _recordingBuffer(NULL),
+      _playoutBuffer(NULL),
+      _playoutBytesLeft(0),
+      _initialized(false),
+      _recording(false),
+      _playing(false),
+      _writing(false),
+      _reading(false),
+      _recordingDelay(0),
+      _playoutDelay(0),
+      _recordingFormat(QSA_FORMAT),
+      _playoutFormat(QSA_FORMAT),
+      _recordingFD(-1),
+      _playoutFD(-1),
+      _recordingFragSize(0),
+      _recordingBufferSize(0),
+      _recordingBufferDataSize(0),
+      _playoutFragSize(0),
+      _playoutBufferSize(0),
+      _playoutBufferDataSize(0) {
+  memset(_oldKeyState, 0, sizeof(_oldKeyState));
+  RTC_LOG(LS_INFO) << __FUNCTION__ << " created";
+}
+
+// ----------------------------------------------------------------------------
+//  AudioDeviceQnx - dtor
+// ----------------------------------------------------------------------------
+
+AudioDeviceQnx::~AudioDeviceQnx() {
+  RTC_LOG(LS_INFO) << __FUNCTION__ << " destroyed";
+
+  Terminate();
+
+  // Clean up the recording buffer and playout buffer.
+  if (_recordingBuffer) {
+    free((void*)_recordingBuffer);
+    _recordingBuffer = nullptr;
+  }
+  if (_playoutBuffer) {
+    free((void*)_playoutBuffer);
+    _playoutBuffer = nullptr;
+  }
+}
+
+void AudioDeviceQnx::AttachAudioBuffer(AudioDeviceBuffer* audioBuffer) {
+  MutexLock lock(&mutex_);
+
+  _ptrAudioBuffer = audioBuffer;
+
+  // Inform the AudioBuffer about default settings for this implementation.
+  // Set all values to zero here since the actual settings will be done by
+  // InitPlayout and InitRecording later.
+  _ptrAudioBuffer->SetRecordingSampleRate(0);
+  _ptrAudioBuffer->SetPlayoutSampleRate(0);
+  _ptrAudioBuffer->SetRecordingChannels(0);
+  _ptrAudioBuffer->SetPlayoutChannels(0);
+}
+
+int32_t AudioDeviceQnx::ActiveAudioLayer(
+    AudioDeviceModule::AudioLayer& audioLayer) const {
+  audioLayer = AudioDeviceModule::kPlatformDefaultAudio;
+  return 0;
+}
+
+AudioDeviceGeneric::InitStatus AudioDeviceQnx::Init() {
+  if (_initialized.load(std::memory_order_relaxed)) {
+    return InitStatus::OK;
+  }
+
+  MutexLock lock(&mutex_);
+  // Load libasound
+  if (!GetQsaSymbolTable()->Load()) {
+    // Alsa is not installed on this system
+    RTC_LOG(LS_ERROR) << "failed to load symbol table";
+    return InitStatus::OTHER_ERROR;
+  }
+
+  _initialized.store(true, std::memory_order_relaxed);
+
+  return InitStatus::OK;
+}
+
+int32_t AudioDeviceQnx::Terminate() {
+  if (!_initialized.load(std::memory_order_relaxed)) {
+    return 0;
+  }
+
+  MutexLock lock(&mutex_);
+  _mixerManager.Close();
+  _outputDeviceIsSpecified = false;
+  _inputDeviceIsSpecified = false;
+  mutex_.Unlock();
+
+  // RECORDING
+  _ptrThreadRec.Finalize();
+
+  // PLAYOUT
+  _ptrThreadPlay.Finalize();
+
+  _initialized.store(false, std::memory_order_relaxed);
+
+  return 0;
+}
+
+bool AudioDeviceQnx::Initialized() const {
+  return (_initialized.load(std::memory_order_relaxed));
+}
+
+int32_t AudioDeviceQnx::InitSpeaker() {
+  MutexLock lock(&mutex_);
+  return InitSpeakerLocked();
+}
+
+int32_t AudioDeviceQnx::InitSpeakerLocked() {
+  if (_playing.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  bool preinitialized = _handlePlayout.load(std::memory_order_relaxed);
+  if (!preinitialized) {
+    if (InitPlayoutLocked(false))
+      return -1;
+  }
+
+  auto close_device = [this](bool cleanup) {
+    if (cleanup) {
+      close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+      _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    }
+  };
+
+  snd_pcm_channel_setup_t setup;
+  memset(&setup, 0, sizeof(snd_pcm_channel_setup_t));
+  setup.channel = SND_PCM_CHANNEL_PLAYBACK;
+  auto gid = std::make_unique<snd_mixer_gid_t>();
+  memset(gid.get(), 0, sizeof(snd_mixer_gid_t));
+  setup.mixer_gid = gid.get();
+  int errVal = LATE(snd_pcm_plugin_setup)(
+      _handlePlayout.load(std::memory_order_relaxed), &setup);
+  if (errVal != EOK) {
+    close_device(!preinitialized);
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_setup error: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    return -1;
+  }
+
+  auto result = _mixerManager.OpenSpeaker(
+      _handlePlayout.load(std::memory_order_relaxed), std::move(gid));
+  close_device(!preinitialized);
+  return result;
+}
+
+int32_t AudioDeviceQnx::InitMicrophone() {
+  MutexLock lock(&mutex_);
+  return InitMicrophoneLocked();
+}
+
+int32_t AudioDeviceQnx::InitMicrophoneLocked() {
+  if (_recording.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  bool preinitialized = _handleRecord.load(std::memory_order_relaxed);
+  if (!preinitialized) {
+    if (InitRecordingLocked(false))
+      return -1;
+  }
+
+  auto close_device = [this](bool cleanup) {
+    if (cleanup) {
+      close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+      _handleRecord.store(nullptr, std::memory_order_relaxed);
+    }
+  };
+
+  snd_pcm_channel_setup_t setup;
+  memset(&setup, 0, sizeof(snd_pcm_channel_setup_t));
+  setup.channel = SND_PCM_CHANNEL_CAPTURE;
+  auto gid = std::make_unique<snd_mixer_gid_t>();
+  memset(gid.get(), 0, sizeof(snd_mixer_gid_t));
+  setup.mixer_gid = gid.get();
+  int errVal = LATE(snd_pcm_plugin_setup)(
+      _handleRecord.load(std::memory_order_relaxed), &setup);
+  if (errVal != EOK) {
+    close_device(!preinitialized);
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_setup error: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    return -1;
+  }
+  auto result = _mixerManager.OpenMicrophone(
+      _handleRecord.load(std::memory_order_relaxed), std::move(gid));
+  close_device(!preinitialized);
+  return result;
+}
+
+bool AudioDeviceQnx::SpeakerIsInitialized() const {
+  return (_mixerManager.SpeakerIsInitialized());
+}
+
+bool AudioDeviceQnx::MicrophoneIsInitialized() const {
+  return (_mixerManager.MicrophoneIsInitialized());
+}
+
+int32_t AudioDeviceQnx::SpeakerVolumeIsAvailable(bool& available) {
+  bool wasInitialized = _mixerManager.SpeakerIsInitialized();
+
+  // Make an attempt to open up the
+  // output mixer corresponding to the currently selected output device.
+  if (!wasInitialized && InitSpeaker() == -1) {
+    // If we end up here it means that the selected speaker has no volume
+    // control.
+    available = false;
+    return 0;
+  }
+
+  // Given that InitSpeaker was successful, we know that a volume control
+  // exists
+  available = true;
+
+  // Close the initialized output mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseSpeaker();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SetSpeakerVolume(uint32_t volume) {
+  return (_mixerManager.SetSpeakerVolume(volume));
+}
+
+int32_t AudioDeviceQnx::SpeakerVolume(uint32_t& volume) const {
+  uint32_t level(0);
+
+  if (_mixerManager.SpeakerVolume(level) == -1) {
+    return -1;
+  }
+
+  volume = level;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MaxSpeakerVolume(uint32_t& maxVolume) const {
+  uint32_t maxVol(0);
+
+  if (_mixerManager.MaxSpeakerVolume(maxVol) == -1) {
+    return -1;
+  }
+
+  maxVolume = maxVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MinSpeakerVolume(uint32_t& minVolume) const {
+  uint32_t minVol(0);
+
+  if (_mixerManager.MinSpeakerVolume(minVol) == -1) {
+    return -1;
+  }
+
+  minVolume = minVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SpeakerMuteIsAvailable(bool& available) {
+  bool isAvailable(false);
+  bool wasInitialized = _mixerManager.SpeakerIsInitialized();
+
+  // Make an attempt to open up the
+  // output mixer corresponding to the currently selected output device.
+  //
+  if (!wasInitialized && InitSpeaker() == -1) {
+    // If we end up here it means that the selected speaker has no volume
+    // control, hence it is safe to state that there is no mute control
+    // already at this stage.
+    available = false;
+    return 0;
+  }
+
+  // Check if the selected speaker has a mute control
+  _mixerManager.SpeakerMuteIsAvailable(isAvailable);
+
+  available = isAvailable;
+
+  // Close the initialized output mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseSpeaker();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SetSpeakerMute(bool enable) {
+  return (_mixerManager.SetSpeakerMute(enable));
+}
+
+int32_t AudioDeviceQnx::SpeakerMute(bool& enabled) const {
+  bool muted(0);
+
+  if (_mixerManager.SpeakerMute(muted) == -1) {
+    return -1;
+  }
+
+  enabled = muted;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MicrophoneMuteIsAvailable(bool& available) {
+  bool isAvailable(false);
+  bool wasInitialized = _mixerManager.MicrophoneIsInitialized();
+
+  // Make an attempt to open up the
+  // input mixer corresponding to the currently selected input device.
+  //
+  if (!wasInitialized && InitMicrophone() == -1) {
+    // If we end up here it means that the selected microphone has no volume
+    // control, hence it is safe to state that there is no mute control
+    // already at this stage.
+    available = false;
+    return 0;
+  }
+
+  // Check if the selected microphone has a mute control
+  //
+  _mixerManager.MicrophoneMuteIsAvailable(isAvailable);
+  available = isAvailable;
+
+  // Close the initialized input mixer
+  //
+  if (!wasInitialized) {
+    _mixerManager.CloseMicrophone();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SetMicrophoneMute(bool enable) {
+  return (_mixerManager.SetMicrophoneMute(enable));
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneMute
+// ----------------------------------------------------------------------------
+
+int32_t AudioDeviceQnx::MicrophoneMute(bool& enabled) const {
+  bool muted(0);
+
+  if (_mixerManager.MicrophoneMute(muted) == -1) {
+    return -1;
+  }
+
+  enabled = muted;
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StereoRecordingIsAvailable(bool& available) {
+  MutexLock lock(&mutex_);
+
+  // If we already have initialized in stereo it's obviously available
+  if (_handleRecord.load(std::memory_order_relaxed) && (2 == _recChannels)) {
+    available = true;
+    return 0;
+  }
+
+  if (_handleRecord.load(std::memory_order_relaxed)) {
+    snd_pcm_channel_info_t info;
+    if (!channelInfo(_handleRecord.load(std::memory_order_relaxed),
+                     SND_PCM_CHANNEL_CAPTURE, info)) {
+      available = (info.min_voices <= 2 && info.max_voices >= 2) ? true : false;
+      return 0;
+    }
+    available = false;
+    return -1;
+  }
+
+  auto recChannels = _recChannels;
+  _recChannels = 2;
+  auto res = InitRecordingLocked();
+  available = res ? false : true;
+  if (!res) {
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+  }
+  _recChannels = recChannels;
+  return res;
+}
+
+int32_t AudioDeviceQnx::SetStereoRecording(bool enable) {
+  if (enable)
+    _recChannels = 2;
+  else
+    _recChannels = 1;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StereoRecording(bool& enabled) const {
+  if (_recChannels == 2)
+    enabled = true;
+  else
+    enabled = false;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StereoPlayoutIsAvailable(bool& available) {
+  MutexLock lock(&mutex_);
+
+  // If we already have initialized in stereo it's obviously available
+  if (_handlePlayout.load(std::memory_order_relaxed) && (2 == _playChannels)) {
+    available = true;
+    return 0;
+  }
+
+  if (_handlePlayout.load(std::memory_order_relaxed)) {
+    snd_pcm_channel_info_t info;
+    if (!channelInfo(_handlePlayout.load(std::memory_order_relaxed),
+                     SND_PCM_CHANNEL_PLAYBACK, info)) {
+      available = (info.min_voices <= 2 && info.max_voices >= 2) ? true : false;
+      return 0;
+    }
+    return -1;
+  }
+
+  auto playChannels = _playChannels;
+  _playChannels = 2;
+  auto res = InitPlayoutLocked();
+  available = res ? false : true;
+  _playChannels = playChannels;
+  if (_handlePlayout.load(std::memory_order_relaxed)) {
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+  }
+  return res;
+}
+
+int32_t AudioDeviceQnx::SetStereoPlayout(bool enable) {
+  if (enable)
+    _playChannels = 2;
+  else
+    _playChannels = 1;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StereoPlayout(bool& enabled) const {
+  if (_playChannels == 2)
+    enabled = true;
+  else
+    enabled = false;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MicrophoneVolumeIsAvailable(bool& available) {
+  bool wasInitialized = _mixerManager.MicrophoneIsInitialized();
+
+  // Make an attempt to open up the
+  // input mixer corresponding to the currently selected output device.
+  if (!wasInitialized && InitMicrophone() == -1) {
+    // If we end up here it means that the selected microphone has no volume
+    // control.
+    available = false;
+    return 0;
+  }
+
+  // Given that InitMicrophone was successful, we know that a volume control
+  // exists
+  available = true;
+
+  // Close the initialized input mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseMicrophone();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SetMicrophoneVolume(uint32_t volume) {
+  return (_mixerManager.SetMicrophoneVolume(volume));
+}
+
+int32_t AudioDeviceQnx::MicrophoneVolume(uint32_t& volume) const {
+  uint32_t level(0);
+
+  if (_mixerManager.MicrophoneVolume(level) == -1) {
+    RTC_LOG(LS_WARNING) << "failed to retrive current microphone level";
+    return -1;
+  }
+
+  volume = level;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MaxMicrophoneVolume(uint32_t& maxVolume) const {
+  uint32_t maxVol(0);
+
+  if (_mixerManager.MaxMicrophoneVolume(maxVol) == -1) {
+    return -1;
+  }
+
+  maxVolume = maxVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::MinMicrophoneVolume(uint32_t& minVolume) const {
+  uint32_t minVol(0);
+
+  if (_mixerManager.MinMicrophoneVolume(minVol) == -1) {
+    return -1;
+  }
+
+  minVolume = minVol;
+
+  return 0;
+}
+
+int16_t AudioDeviceQnx::PlayoutDevices() {
+  return (int16_t)GetDevicesInfo(FUNC_GET_NUM_OF_DEVICE, true);
+}
+
+int32_t AudioDeviceQnx::SetPlayoutDevice(uint16_t index) {
+  if (_handlePlayout.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  uint32_t nDevices = GetDevicesInfo(FUNC_GET_NUM_OF_DEVICE, true);
+  RTC_LOG(LS_VERBOSE) << "number of available audio output devices is "
+                      << nDevices;
+
+  if (index > (nDevices - 1)) {
+    RTC_LOG(LS_ERROR) << "device index is out of range [0," << (nDevices - 1)
+                      << "]";
+    return -1;
+  }
+
+  _outputDeviceIndex = index;
+  _outputDeviceIsSpecified = true;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnx::SetPlayoutDevice(
+    AudioDeviceModule::WindowsDeviceType /*device*/) {
+  RTC_LOG(LS_ERROR) << "WindowsDeviceType not supported";
+  return -1;
+}
+
+int32_t AudioDeviceQnx::PlayoutDeviceName(uint16_t index,
+                                          char name[kAdmMaxDeviceNameSize],
+                                          char guid[kAdmMaxGuidSize]) {
+  const uint16_t nDevices(PlayoutDevices());
+
+  if ((index > (nDevices - 1)) || (name == NULL)) {
+    return -1;
+  }
+
+  memset(name, 0, kAdmMaxDeviceNameSize);
+
+  if (guid != NULL) {
+    memset(guid, 0, kAdmMaxGuidSize);
+  }
+
+  return GetDevicesInfo(FUNC_GET_DEVICE_NAME, true, index, name,
+                        kAdmMaxDeviceNameSize);
+}
+
+int32_t AudioDeviceQnx::RecordingDeviceName(uint16_t index,
+                                            char name[kAdmMaxDeviceNameSize],
+                                            char guid[kAdmMaxGuidSize]) {
+  const uint16_t nDevices(RecordingDevices());
+
+  if ((index > (nDevices - 1)) || (name == NULL)) {
+    return -1;
+  }
+
+  memset(name, 0, kAdmMaxDeviceNameSize);
+
+  if (guid != NULL) {
+    memset(guid, 0, kAdmMaxGuidSize);
+  }
+
+  return GetDevicesInfo(FUNC_GET_DEVICE_NAME, false, index, name,
+                        kAdmMaxDeviceNameSize);
+}
+
+int16_t AudioDeviceQnx::RecordingDevices() {
+  return (int16_t)GetDevicesInfo(FUNC_GET_NUM_OF_DEVICE, false);
+}
+
+int32_t AudioDeviceQnx::SetRecordingDevice(uint16_t index) {
+  if (_handleRecord.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  uint32_t nDevices = GetDevicesInfo(FUNC_GET_NUM_OF_DEVICE, false);
+  RTC_LOG(LS_VERBOSE) << "number of availiable audio input devices is "
+                      << nDevices;
+
+  if (index > (nDevices - 1)) {
+    RTC_LOG(LS_ERROR) << "device index is out of range [0," << (nDevices - 1)
+                      << "]";
+    return -1;
+  }
+
+  _inputDeviceIndex = index;
+  _inputDeviceIsSpecified = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingDevice II (II)
+// ----------------------------------------------------------------------------
+
+int32_t AudioDeviceQnx::SetRecordingDevice(
+    AudioDeviceModule::WindowsDeviceType /*device*/) {
+  RTC_LOG(LS_ERROR) << "WindowsDeviceType not supported";
+  return -1;
+}
+
+int32_t AudioDeviceQnx::PlayoutIsAvailable(bool& available) {
+  available = false;
+
+  // Try to initialize the playout side with mono
+  // Assumes that user set num channels after calling this function
+  _playChannels = 1;
+  int32_t res = InitPlayout();
+
+  // Cancel effect of initialization
+  StopPlayout();
+
+  if (res != -1) {
+    available = true;
+  } else {
+    // It may be possible to play out in stereo
+    res = StereoPlayoutIsAvailable(available);
+    if (available) {
+      // Then set channels to 2 so InitPlayout doesn't fail
+      _playChannels = 2;
+    }
+  }
+
+  return res;
+}
+
+int32_t AudioDeviceQnx::RecordingIsAvailable(bool& available) {
+  available = false;
+
+  // Try to initialize the recording side with mono
+  // Assumes that user set num channels after calling this function
+  _recChannels = 1;
+  int32_t res = InitRecording();
+
+  // Cancel effect of initialization
+  StopRecording();
+
+  if (!res) {
+    available = true;
+  } else {
+    // It may be possible to record in stereo
+    res = StereoRecordingIsAvailable(available);
+    if (!res && available) {
+      // Then set channels to 2 so InitPlayout doesn't fail
+      _recChannels = 2;
+    }
+  }
+
+  return res;
+}
+
+int32_t AudioDeviceQnx::InitPlayout() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  MutexLock lock(&mutex_);
+  return InitPlayoutLocked();
+}
+
+int32_t AudioDeviceQnx::InitPlayoutLocked(bool initSpeaker) {
+  if (_playing.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  if (!_outputDeviceIsSpecified) {
+    return -1;
+  }
+
+  if (_handlePlayout.load(std::memory_order_relaxed)) {
+    return 0;
+  }
+
+  // Open PCM device for playout
+  char deviceName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(FUNC_GET_DEVICE_NAME_FOR_AN_ENUM, true, _outputDeviceIndex,
+                 deviceName, kAdmMaxDeviceNameSize);
+
+  RTC_LOG(LS_VERBOSE) << "InitPlayout open (" << deviceName << ")";
+  snd_pcm_t* handlePlayout;
+  int errVal =
+      LATE(snd_pcm_open)(&handlePlayout, (int)deviceName[0] - CHAR_BASE,
+                         (int)deviceName[1] - CHAR_BASE,
+                         SND_PCM_OPEN_PLAYBACK | SND_PCM_OPEN_NONBLOCK);
+  if (errVal != EOK) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_open error: " << LATE(snd_strerror)(errVal)
+                      << " (" << errVal << ")";
+    return -1;
+  }
+  _handlePlayout.store(handlePlayout, std::memory_order_relaxed);
+  snd_pcm_channel_info_t info;
+  if (channelInfo(_handlePlayout.load(std::memory_order_relaxed),
+                  SND_PCM_CHANNEL_PLAYBACK, info)) {
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  _playoutFragSize = ParamsToBytes(
+      _playoutFormat, _playoutFreq * SINGLE_BUFFER_DURATION_IN_MS / 1000,
+      _playChannels);
+
+  snd_pcm_channel_params_t params;
+  memset(&params, 0, sizeof(snd_pcm_channel_params_t));
+  params.mode = SND_PCM_MODE_BLOCK;
+  params.channel = SND_PCM_CHANNEL_PLAYBACK;
+  params.start_mode = SND_PCM_START_FULL;
+  params.stop_mode = SND_PCM_STOP_ROLLOVER;
+  if (!(info.formats & (1 << _playoutFormat))) {
+    RTC_LOG(LS_ERROR) << "Unsupported format: " << _playoutFormat;
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.format = _playoutFormat;
+  params.format.interleave = 1;
+  if (!(info.rates & toRateFlag(_playoutFreq))) {
+    RTC_LOG(LS_ERROR) << "Unsupported rate: " << _playoutFreq;
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.rate = _playoutFreq;
+  if (_playChannels < info.min_voices || _playChannels > info.max_voices) {
+    RTC_LOG(LS_ERROR) << "Unsupported voices: " << _playChannels
+                      << ", min: " << info.min_voices
+                      << ", max: " << info.max_voices;
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.voices = _playChannels;
+  params.buf.block.frag_size = _playoutFragSize;
+  params.buf.block.frags_max = 3;
+  params.buf.block.frags_min = 1;
+  strlcpy(params.sw_mixer_subchn_name, "WebRTC PLAY channel",
+          sizeof(params.sw_mixer_subchn_name));
+  // use default for now
+  // strlcpy (params.audio_type_name, "", sizeof(params.audio_type_name));
+  auto state = channelStatus(_handlePlayout.load(std::memory_order_relaxed),
+                             SND_PCM_CHANNEL_PLAYBACK);
+  if (state != SND_PCM_STATUS_NOTREADY && state != SND_PCM_STATUS_READY) {
+    RTC_LOG(LS_ERROR) << "play channel is under an unexpected state: " << state;
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  errVal = LATE(snd_pcm_plugin_params)(
+      _handlePlayout.load(std::memory_order_relaxed), &params);
+  if (errVal != EOK) {
+    _playoutFragSize = 0;
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_params error: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  _playoutFD = LATE(snd_pcm_file_descriptor)(
+      _handlePlayout.load(std::memory_order_relaxed), SND_PCM_CHANNEL_PLAYBACK);
+  if (_playoutFD < 0) {
+    _playoutFragSize = 0;
+    _playoutBufferSizeInNMS = 0;
+    RTC_LOG(LS_ERROR) << "snd_pcm_file_descriptor error: "
+                      << LATE(snd_strerror)(_playoutFD) << " (" << _playoutFD
+                      << ")";
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  snd_pcm_channel_setup_t channel_params;
+  memset(&channel_params, 0, sizeof(snd_pcm_channel_setup_t));
+  channel_params.channel = SND_PCM_CHANNEL_PLAYBACK;
+  errVal = LATE(snd_pcm_plugin_setup)(
+      _handlePlayout.load(std::memory_order_relaxed), &channel_params);
+  if (errVal != EOK) {
+    _playoutFragSize = 0;
+    _playoutBufferSizeInNMS = 0;
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_setup error: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    close_pcm_dev(_handlePlayout.load(std::memory_order_relaxed));
+    _handlePlayout.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  _playoutFragSize = channel_params.buf.block.frag_size;
+  _playoutFormat = channel_params.format.format;
+  _playoutFreq = channel_params.format.rate;
+  _playChannels = channel_params.format.voices;
+  // Set play buffer size
+  _playoutFramesInNMS = _playoutFreq * SINGLE_BUFFER_DURATION_IN_MS / 1000;
+  _playoutBufferSizeInNMS =
+      ParamsToBytes(_playoutFormat, _playoutFramesInNMS, _playChannels);
+  _playoutBufferSize = std::lcm(_playoutFragSize, _playoutBufferSizeInNMS);
+  if (_playoutBufferSize > 5 * _playoutFragSize)
+    _playoutBufferSize = _playoutFragSize + _playoutBufferSizeInNMS;
+
+  if (_ptrAudioBuffer) {
+    // Update webrtc audio buffer with the selected parameters
+    _ptrAudioBuffer->SetPlayoutSampleRate(_playoutFreq);
+    _ptrAudioBuffer->SetPlayoutChannels(_playChannels);
+  }
+
+  if (initSpeaker) {
+    if (InitSpeakerLocked()) {
+      RTC_LOG(LS_WARNING) << "InitSpeaker() failed";
+    }
+  }
+
+  RTC_CHECK(_handlePlayout.load(std::memory_order_relaxed));
+
+  RTC_LOG(LS_VERBOSE) << "InitPlayout succeeded";
+  return 0;
+}
+
+int32_t AudioDeviceQnx::InitRecording() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  MutexLock lock(&mutex_);
+  return InitRecordingLocked();
+}
+
+int32_t AudioDeviceQnx::InitRecordingLocked(bool initMicrophone) {
+  if (_recording.load(std::memory_order_relaxed)) {
+    return -1;
+  }
+
+  if (!_inputDeviceIsSpecified) {
+    return -1;
+  }
+
+  if (_handleRecord.load(std::memory_order_relaxed)) {
+    return 0;
+  }
+
+  char deviceName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(FUNC_GET_DEVICE_NAME_FOR_AN_ENUM, false, _inputDeviceIndex,
+                 deviceName, kAdmMaxDeviceNameSize);
+
+  RTC_LOG(LS_VERBOSE) << "InitRecording open (" << deviceName << ")";
+  snd_pcm_t* handleRecord;
+  int errVal = LATE(snd_pcm_open)(&handleRecord, (int)deviceName[0] - CHAR_BASE,
+                                  (int)deviceName[1] - CHAR_BASE,
+                                  SND_PCM_OPEN_CAPTURE | SND_PCM_OPEN_NONBLOCK);
+  if (errVal != EOK) {
+    RTC_LOG(LS_ERROR) << "unable to open record device: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+  _handleRecord.store(handleRecord, std::memory_order_relaxed);
+  snd_pcm_channel_info_t info;
+  if (channelInfo(_handleRecord.load(std::memory_order_relaxed),
+                  SND_PCM_CHANNEL_CAPTURE, info)) {
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  _recordingFragSize = ParamsToBytes(
+      _recordingFormat, _recordingFreq * SINGLE_BUFFER_DURATION_IN_MS / 1000,
+      _recChannels);
+
+  snd_pcm_channel_params_t params;
+  memset(&params, 0, sizeof(snd_pcm_channel_params_t));
+  params.mode = SND_PCM_MODE_BLOCK;
+  params.channel = SND_PCM_CHANNEL_CAPTURE;
+  params.start_mode = SND_PCM_START_DATA;
+  params.stop_mode = SND_PCM_STOP_ROLLOVER;
+  if (!(info.formats & (1 << _recordingFormat))) {
+    RTC_LOG(LS_ERROR) << "Unsupported format: " << _recordingFormat;
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.format = _recordingFormat;
+  params.format.interleave = 1;
+  if (!(info.rates & toRateFlag(_recordingFreq))) {
+    RTC_LOG(LS_ERROR) << "Unsupported rate: " << _recordingFreq;
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.rate = _recordingFreq;
+  if (_recChannels == std::numeric_limits<uint8_t>::max()) {
+    if (ALSA_CAPTURE_CH >= info.min_voices &&
+        ALSA_CAPTURE_CH <= info.max_voices)
+      _recChannels = ALSA_CAPTURE_CH;
+    else if (info.min_voices <= 2 && info.max_voices >= 2)
+      _recChannels = 2;
+    else
+      _recChannels = 1;
+  }
+  if (_recChannels < info.min_voices || _recChannels > info.max_voices) {
+    RTC_LOG(LS_ERROR) << "Unsupported voices: " << _recChannels
+                      << ", min: " << info.min_voices
+                      << ", max: " << info.max_voices;
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  params.format.voices = _recChannels;
+  params.buf.block.frag_size = _recordingFragSize;
+  params.buf.block.frags_max = -1;
+  params.buf.block.frags_min = 1;
+  strlcpy(params.sw_mixer_subchn_name, "WebRTC REC channel",
+          sizeof(params.sw_mixer_subchn_name));
+
+  auto state = channelStatus(_handleRecord.load(std::memory_order_relaxed),
+                             SND_PCM_CHANNEL_CAPTURE);
+  if (state != SND_PCM_STATUS_NOTREADY && state != SND_PCM_STATUS_READY) {
+    RTC_LOG(LS_ERROR) << "play channel is under an unexpected state: " << state;
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+  errVal = LATE(snd_pcm_plugin_params)(
+      _handleRecord.load(std::memory_order_relaxed), &params);
+  if (errVal != EOK) {
+    if (_recChannels == 1)
+      _recChannels = 2;
+    else
+      _recChannels = 1;
+    params.format.voices = _recChannels;
+    errVal = LATE(snd_pcm_plugin_params)(
+        _handleRecord.load(std::memory_order_relaxed), &params);
+    if (errVal != EOK) {
+      _recordingFragSize = 0;
+      RTC_LOG(LS_ERROR) << "snd_pcm_plugin_params error: "
+                        << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+      close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+      _handleRecord.store(nullptr, std::memory_order_relaxed);
+      return -1;
+    }
+  }
+
+  _recordingFD = LATE(snd_pcm_file_descriptor)(
+      _handleRecord.load(std::memory_order_relaxed), SND_PCM_CHANNEL_CAPTURE);
+  if (_recordingFD < 0) {
+    _recordingFragSize = 0;
+    _recordingBufferSizeInNMS = 0;
+    RTC_LOG(LS_ERROR) << "unable to get file descriptor: "
+                      << LATE(snd_strerror)(_recordingFD) << " ("
+                      << _recordingFD << ")";
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  snd_pcm_channel_setup_t channel_params;
+  memset(&channel_params, 0, sizeof(snd_pcm_channel_setup_t));
+  channel_params.channel = SND_PCM_CHANNEL_CAPTURE;
+  errVal = LATE(snd_pcm_plugin_setup)(
+      _handleRecord.load(std::memory_order_relaxed), &channel_params);
+  if (errVal != EOK) {
+    _recordingFragSize = 0;
+    _recordingBufferSizeInNMS = 0;
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_setup error: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    close_pcm_dev(_handleRecord.load(std::memory_order_relaxed));
+    _handleRecord.store(nullptr, std::memory_order_relaxed);
+    return -1;
+  }
+
+  _recordingFragSize = channel_params.buf.block.frag_size;
+  _recordingFormat = channel_params.format.format;
+  _recordingFreq = channel_params.format.rate;
+  _recChannels = channel_params.format.voices;
+  // Set play buffer size
+  _recordingFramesInNMS = _recordingFreq * SINGLE_BUFFER_DURATION_IN_MS / 1000;
+  _recordingBufferSizeInNMS =
+      ParamsToBytes(_recordingFormat, _recordingFramesInNMS, _recChannels);
+  _recordingBufferSize =
+      std::lcm(_recordingFragSize, _recordingBufferSizeInNMS);
+  if (_recordingBufferSize > 5 * _recordingFragSize)
+    _recordingBufferSize =
+        std::max(_recordingFragSize, _recordingBufferSizeInNMS);
+
+  if (initMicrophone) {
+    // Initialize the microphone (devices might have been added or removed)
+    if (InitMicrophoneLocked()) {
+      RTC_LOG(LS_WARNING) << "InitMicrophone() failed";
+    }
+  }
+
+  if (_ptrAudioBuffer) {
+    // Update webrtc audio buffer with the selected parameters
+    _ptrAudioBuffer->SetRecordingSampleRate(_recordingFreq);
+    _ptrAudioBuffer->SetRecordingChannels(_recChannels);
+  }
+
+  RTC_CHECK(_handleRecord.load(std::memory_order_relaxed));
+
+  RTC_LOG(LS_VERBOSE) << "InitRecording succeeded";
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StartRecording() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  bool expected = false;
+  auto success = _recording.compare_exchange_weak(
+      expected, true, std::memory_order_release, std::memory_order_relaxed);
+  if (!success) {
+    RTC_LOG(LS_WARNING) << "audio capture is already in the recording state";
+    return 0;
+  }
+
+  _recordingBufferDataSize = 0;
+
+  // Make sure we only create the buffer once.
+  if (!_recordingBuffer)
+    _recordingBuffer = (int8_t*)calloc(_recordingBufferSize, sizeof(int8_t));
+  if (!_recordingBuffer) {
+    RTC_LOG(LS_ERROR) << "failed to alloc recording buffer";
+    _recording.store(false, std::memory_order_relaxed);
+    return -1;
+  }
+  // RECORDING
+  _ptrThreadRec = rtc::PlatformThread::SpawnJoinable(
+      [this] {
+        if (!_recording.load(std::memory_order_consume)) {
+          return;
+        }
+        bool expected = false;
+        while (!_reading.compare_exchange_weak(expected, true,
+                                               std::memory_order_release,
+                                               std::memory_order_relaxed))
+          sleep(0);
+        int errVal = LATE(snd_pcm_plugin_prepare)(
+            _handleRecord.load(std::memory_order_relaxed),
+            SND_PCM_CHANNEL_CAPTURE);
+        if (errVal != EOK) {
+          RTC_LOG(LS_ERROR) << "snd_pcm_plugin_prepare failed ("
+                            << LATE(snd_strerror)(errVal) << ")";
+        } else {
+          RTC_LOG(LS_INFO) << "enter audio capture process";
+          while (RecThreadProcess()) {
+          }
+          RTC_LOG(LS_INFO) << "leave audio capture process";
+          int errVal = LATE(snd_pcm_plugin_drop)(
+              _handleRecord.load(std::memory_order_relaxed),
+              SND_PCM_CHANNEL_CAPTURE);
+          if (errVal < 0) {
+            RTC_LOG(LS_ERROR)
+                << "snd_pcm_plugin_drop error: " << LATE(snd_strerror)(errVal);
+          }
+        }
+        _reading.store(false, std::memory_order_relaxed);
+      },
+      "webrtc_audio_module_capture_thread",
+      rtc::ThreadAttributes().SetPriority(rtc::ThreadPriority::kRealtime));
+
+  RTC_LOG(LS_VERBOSE) << "StartRecording succeeded";
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StopRecording() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  bool expected = true;
+  auto success = _recording.compare_exchange_strong(
+      expected, false, std::memory_order_release, std::memory_order_relaxed);
+  if (!success) {
+    RTC_LOG(LS_WARNING) << "audio capture is already in the stop state";
+    return 0;
+  }
+
+  _ptrThreadRec.Finalize();
+
+  // Check if we have muted and unmute if so.
+  bool muteEnabled = false;
+  MicrophoneMute(muteEnabled);
+  if (muteEnabled) {
+    SetMicrophoneMute(false);
+  }
+
+  RTC_LOG(LS_VERBOSE) << "StopRecording succeeded";
+  return 0;
+}
+
+bool AudioDeviceQnx::RecordingIsInitialized() const {
+  return (_handleRecord.load(std::memory_order_relaxed));
+}
+
+bool AudioDeviceQnx::Recording() const {
+  return (_recording.load(std::memory_order_relaxed));
+}
+
+bool AudioDeviceQnx::PlayoutIsInitialized() const {
+  return (_handlePlayout.load(std::memory_order_relaxed));
+}
+
+int32_t AudioDeviceQnx::StartPlayout() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  bool expected = false;
+  auto success = _playing.compare_exchange_weak(
+      expected, true, std::memory_order_release, std::memory_order_relaxed);
+  if (!success) {
+    RTC_LOG(LS_WARNING) << "audio play is already in the playing state";
+    return 0;
+  }
+
+  _playoutBytesLeft = 0;
+  _playoutBufferDataSize = 0;
+  if (!_playoutBuffer) {
+    _playoutBuffer = (int8_t*)calloc(_playoutBufferSize, sizeof(int8_t));
+  }
+  if (!_playoutBuffer) {
+    RTC_LOG(LS_ERROR) << "failed to alloc playout buf";
+    _playing.store(false, std::memory_order_relaxed);
+    return -1;
+  }
+
+  // PLAYOUT
+  _ptrThreadPlay = rtc::PlatformThread::SpawnJoinable(
+      [this] {
+        if (!_playing.load(std::memory_order_consume)) {
+          return;
+        }
+        bool expected = false;
+        while (!_writing.compare_exchange_weak(expected, true,
+                                               std::memory_order_release,
+                                               std::memory_order_relaxed))
+          sleep(0);
+        int errVal = LATE(snd_pcm_plugin_prepare)(
+            _handlePlayout.load(std::memory_order_relaxed),
+            SND_PCM_CHANNEL_PLAYBACK);
+        if (errVal != EOK) {
+          RTC_LOG(LS_ERROR) << "playout snd_pcm_prepare failed ("
+                            << LATE(snd_strerror)(errVal) << ")";
+        } else {
+          RTC_LOG(LS_INFO) << "enter audio play process";
+          while (PlayThreadProcess()) {
+          }
+          RTC_LOG(LS_INFO) << "leave audio play process";
+          errVal = LATE(snd_pcm_plugin_drop)(
+              _handlePlayout.load(std::memory_order_relaxed),
+              SND_PCM_CHANNEL_PLAYBACK);
+          if (errVal < 0) {
+            RTC_LOG(LS_ERROR)
+                << "snd_pcm_plugin_drop error: " << LATE(snd_strerror)(errVal);
+          }
+        }
+        _writing.store(false, std::memory_order_release);
+      },
+      "webrtc_audio_module_play_thread",
+      rtc::ThreadAttributes().SetPriority(rtc::ThreadPriority::kRealtime));
+
+  RTC_LOG(LS_VERBOSE) << "StartPlayout succeeded";
+  return 0;
+}
+
+int32_t AudioDeviceQnx::StopPlayout() {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+  bool expected = true;
+  auto success = _playing.compare_exchange_strong(
+      expected, false, std::memory_order_release, std::memory_order_relaxed);
+  if (!success) {
+    RTC_LOG(LS_WARNING) << "audio play is already in the stop state";
+    return 0;
+  }
+
+  _ptrThreadPlay.Finalize();
+
+  RTC_LOG(LS_VERBOSE) << "StopPlayout succeeded";
+  return 0;
+}
+
+int32_t AudioDeviceQnx::PlayoutDelay(uint16_t& delayMS) const {
+  delayMS = 1.0 * _playoutFragSize / _playChannels / FRAME_BYTES /
+            _playoutFreq * 1000;
+  return 0;
+}
+
+bool AudioDeviceQnx::Playing() const {
+  return (_playing.load(std::memory_order_relaxed));
+}
+
+// ============================================================================
+//                                 Private Methods
+// ============================================================================
+
+int32_t AudioDeviceQnx::GetDevicesInfo(const int32_t function,
+                                       const bool playback,
+                                       const int32_t enumDeviceNo,
+                                       char* enumDeviceName,
+                                       const int32_t ednLen) const {
+  int mode = playback ? SND_PCM_CHANNEL_PLAYBACK : SND_PCM_CHANNEL_CAPTURE;
+  int card, device;
+  int count = 1;
+  int err =
+      LATE(snd_pcm_find)((1 << (playback ? _playoutFormat : _recordingFormat)),
+                         &count, &card, &device, mode);
+  if (err < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_find error: " << LATE(snd_strerror)(err);
+    return -1;
+  }
+
+  count = err;
+  if (count)
+    RTC_LOG(LS_INFO) << count << " pcm device(s) found";
+
+  if (function == FUNC_GET_NUM_OF_DEVICE) {
+    if (playback && targetedPlayDev()) {
+      return 1;
+    } else if (!playback && targetedRecordDev()) {
+      return 1;
+    }
+    return count;
+  }
+
+  if (playback && targetedPlayDev()) {
+    strncpy(enumDeviceName, targetedPlayDev(), strlen(targetedPlayDev()));
+    return 0;
+  } else if (!playback && targetedRecordDev()) {
+    strncpy(enumDeviceName, targetedRecordDev(), strlen(targetedRecordDev()));
+    return 0;
+  }
+
+  if (!count) {
+    RTC_LOG(LS_ERROR) << "no valid pcm device found";
+    return -1;
+  }
+
+  if (enumDeviceNo >= count) {
+    RTC_LOG(LS_ERROR) << "pcm device " << enumDeviceNo << " not found";
+    return -1;
+  }
+
+  auto setName = [&enumDeviceName](int card, int device) {
+    enumDeviceName[0] = (char)card + CHAR_BASE;
+    enumDeviceName[1] = (char)device + CHAR_BASE;
+    enumDeviceName[2] = '\0';
+    return 0;
+  };
+
+  if (count == 1) {
+    return setName(card, device);
+  }
+
+  std::unique_ptr<int, void (*)(void*)> cards((int*)calloc(count, sizeof(int)),
+                                              free);
+  std::unique_ptr<int, void (*)(void*)> devices(
+      (int*)calloc(count, sizeof(int)), free);
+  err =
+      LATE(snd_pcm_find)((1 << (playback ? _playoutFormat : _recordingFormat)),
+                         &count, cards.get(), devices.get(), mode);
+  if (err < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_find error: " << LATE(snd_strerror)(err);
+    return -1;
+  }
+  RTC_CHECK(err > 0);
+
+  snd_pcm_t* pcmHandle;
+  int open_mode = playback ? SND_PCM_OPEN_PLAYBACK : SND_PCM_OPEN_CAPTURE;
+  err = LATE(snd_pcm_open_preferred)(&pcmHandle, &card, &device, open_mode);
+  if (err) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_open_preferred error: "
+                      << LATE(snd_strerror)(err);
+    return -1;
+  }
+  close_pcm_dev(pcmHandle);
+  pcmHandle = nullptr;
+
+  if (!enumDeviceNo) {
+    if (cards.get()[enumDeviceNo] == card &&
+        devices.get()[enumDeviceNo] == device) {  // swich to the device 0
+      card = cards.get()[0];
+      device = devices.get()[0];
+    } else {
+      card = cards.get()[enumDeviceNo];
+      device = devices.get()[enumDeviceNo];
+    }
+  }
+
+  return setName(card, device);
+}
+
+int32_t AudioDeviceQnx::InputSanityCheckAfterUnlockedPeriod() const {
+  if (_handleRecord.load(std::memory_order_relaxed) == NULL) {
+    RTC_LOG(LS_ERROR) << "input state has been modified during unlocked period";
+    return -1;
+  }
+  return 0;
+}
+
+int32_t AudioDeviceQnx::OutputSanityCheckAfterUnlockedPeriod() const {
+  if (!_handlePlayout.load(std::memory_order_relaxed)) {
+    RTC_LOG(LS_ERROR)
+        << "output state has been modified during unlocked period";
+    return -1;
+  }
+  return 0;
+}
+
+int32_t AudioDeviceQnx::ErrorRecovery(int32_t error,
+                                      snd_pcm_t* deviceHandle,
+                                      int32_t channel) {
+  RTC_LOG(LS_WARNING) << (channel == SND_PCM_CHANNEL_PLAYBACK ? "playback "
+                                                              : "capture ")
+                      << "recovery from (" << LATE(snd_strerror)(error) << ")";
+  if (error == -EAGAIN) {
+    return 0;
+  } else if (error == -EIO) {
+    int err = LATE(snd_pcm_plugin_prepare)(deviceHandle, channel);
+    if (err != EOK) {
+      RTC_LOG(LS_ERROR) << (channel == SND_PCM_CHANNEL_PLAYBACK ? "playback "
+                                                                : "capture ")
+                        << "snd_pcm_prepare failed (" << LATE(snd_strerror)(err)
+                        << ")";
+    }
+    return 0;
+  }
+  return -1;
+}
+
+ssize_t AudioDeviceQnx::ParamsToBytes(int32_t format,
+                                      long frames,
+                                      uint8_t channels) {
+  return FRAME_BYTES * frames * channels;
+}
+
+bool AudioDeviceQnx::PlayThreadProcess() {
+  if (!_playing.load(std::memory_order_relaxed))
+    return false;
+
+  int err;
+  ssize_t writeBytes;
+  int32_t availBytes;
+
+  snd_pcm_channel_status_t status;
+  auto state = channelStatus(_handlePlayout.load(std::memory_order_relaxed),
+                             SND_PCM_CHANNEL_PLAYBACK, &status);
+  if (state < 0) {
+    _playing.store(false, std::memory_order_relaxed);
+    return false;
+  }
+  if (state == SND_PCM_STATUS_UNDERRUN || state == SND_PCM_STATUS_OVERRUN) {
+    ErrorRecovery(-EIO, _handlePlayout.load(std::memory_order_relaxed),
+                  SND_PCM_CHANNEL_PLAYBACK);
+    return true;
+  }
+
+  availBytes = status.free;
+  if (availBytes == 0) {  // no frame is available now
+    if (!_playing.load(std::memory_order_acquire))
+      return false;
+    err = snd_pcm_wait(_playoutFD, POLLWRNORM, ALSA_PLAYOUT_WAIT_TIMEOUT);
+    if (!err)  // timeout occured
+      RTC_LOG(LS_VERBOSE) << "audio play poll timeout: " << strerror(err);
+    return true;
+  }
+
+  if (_playoutBytesLeft < _playoutFragSize) {
+    auto leftSpace = _playoutBufferSize - _playoutBufferDataSize;
+    if (leftSpace < _playoutBufferSizeInNMS) {
+      if (_playoutBytesLeft)
+        memcpy(_playoutBuffer,
+               &_playoutBuffer[_playoutBufferDataSize - _playoutBytesLeft],
+               _playoutBytesLeft);
+      _playoutBufferDataSize = _playoutBytesLeft;
+    }
+    if (!_playing.load(std::memory_order_acquire))
+      return false;
+    auto fetch = _ptrAudioBuffer->GetMoreAudioData(
+        &_playoutBuffer[_playoutBufferDataSize], _playoutFramesInNMS);
+    if (fetch <= 0)
+      return true;
+
+    _playoutBytesLeft += fetch;
+    _playoutBufferDataSize += fetch;
+    if (_playoutBytesLeft < _playoutFragSize) {
+      return true;
+    }
+  }
+
+  if (static_cast<uint32_t>(availBytes) > _playoutBytesLeft)
+    availBytes = _playoutBytesLeft;
+  if (auto remainder = availBytes % _playoutFragSize)
+    availBytes -= remainder;
+
+  writeBytes = LATE(snd_pcm_plugin_write)(
+      _handlePlayout.load(std::memory_order_relaxed),
+      &_playoutBuffer[_playoutBufferDataSize - _playoutBytesLeft], availBytes);
+
+  if (writeBytes < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_plugin_write error: "
+                      << LATE(snd_strerror)(writeBytes);
+    _playoutBytesLeft = 0;
+    _playoutBufferDataSize = 0;
+    ErrorRecovery(writeBytes, _handlePlayout.load(std::memory_order_relaxed),
+                  SND_PCM_CHANNEL_PLAYBACK);
+    return true;
+  }
+
+  if (writeBytes != availBytes) {
+    RTC_LOG(LS_WARNING) << "snd_pcm_plugin_write worte " << writeBytes
+                        << " bytes, " << availBytes << " are expected";
+  }
+
+  _playoutBytesLeft -= writeBytes;
+  if (_playoutBytesLeft <= 0) {
+    RTC_DCHECK_EQ(_playoutBytesLeft, 0);
+    _playoutBufferDataSize = 0;
+  }
+  return true;
+}
+
+bool AudioDeviceQnx::RecThreadProcess() {
+  if (!_recording.load(std::memory_order_relaxed))
+    return false;
+
+  int err;
+  ssize_t readBytes;
+  uint32_t availBytes;
+
+  snd_pcm_channel_status_t status;
+  auto state = channelStatus(_handleRecord.load(std::memory_order_relaxed),
+                             SND_PCM_CHANNEL_CAPTURE, &status);
+  if (state < 0) {
+    _recording.store(false, std::memory_order_relaxed);
+    return false;
+  }
+
+  if (state == SND_PCM_STATUS_UNDERRUN || state == SND_PCM_STATUS_OVERRUN) {
+    ErrorRecovery(-EIO, _handleRecord.load(std::memory_order_relaxed),
+                  SND_PCM_CHANNEL_CAPTURE);
+    return true;
+  }
+
+  availBytes = status.count;
+  if (availBytes < _recordingFragSize) {  // no frame is available now
+    if (!_recording.load(std::memory_order_relaxed))
+      return false;
+    err = snd_pcm_wait(_recordingFD, POLLRDNORM, ALSA_CAPTURE_WAIT_TIMEOUT);
+    if (!err)  // timeout occured
+      RTC_LOG(LS_VERBOSE) << "audio capture poll timeout: " << strerror(err);
+    return true;
+  }
+
+  int32_t remainder = 0;
+  do {
+    int32_t singleRead =
+        std::min(availBytes, _recordingBufferSize - _recordingBufferDataSize);
+
+    if (int32_t remainder = singleRead % _recordingFragSize)
+      singleRead = singleRead - remainder;
+
+    while ((readBytes = LATE(snd_pcm_plugin_read)(
+                _handleRecord.load(std::memory_order_relaxed),
+                &_recordingBuffer[_recordingBufferDataSize], singleRead)) ==
+           -EAGAIN)
+      sleep(0);
+    if (readBytes != singleRead)
+      RTC_LOG(LS_WARNING)
+          << "snd_pcm_plugin_read read " << readBytes
+          << " bytes, which does not equal to expected singleRead";
+
+    if (!readBytes) {
+      RTC_LOG(LS_WARNING) << "snd_pcm_plugin_read read " << 0
+                          << " byte, is this an error?";
+      return true;
+    } else if (readBytes < 0) {
+      RTC_LOG(LS_ERROR) << "snd_pcm_plugin_read error: "
+                        << LATE(snd_strerror)(readBytes);
+      ErrorRecovery(readBytes, _handleRecord.load(std::memory_order_relaxed),
+                    SND_PCM_CHANNEL_CAPTURE);
+      return true;
+    }
+    _recordingBufferDataSize += readBytes;
+    availBytes -= readBytes;
+    size_t count = _recordingBufferDataSize / _recordingBufferSizeInNMS;
+    if (!_recording.load(std::memory_order_acquire))
+      return false;
+    for (size_t i = 0; i < count; ++i) {
+      _ptrAudioBuffer->SetRecordedBuffer(
+          &_recordingBuffer[i * _recordingBufferSizeInNMS],
+          _recordingFramesInNMS);
+      _ptrAudioBuffer->SetTypingStatus(KeyPressed());
+      _ptrAudioBuffer->DeliverRecordedData();
+      sleep(0);
+    }
+    auto deliveredSize = count * _recordingBufferSizeInNMS;
+    if (remainder = _recordingBufferDataSize - deliveredSize)
+      memcpy(_recordingBuffer, &_recordingBuffer[deliveredSize], remainder);
+    _recordingBufferDataSize = remainder;
+  } while (availBytes + remainder >= _recordingBufferSizeInNMS);
+  return true;
+}
+
+bool AudioDeviceQnx::KeyPressed() const {
+  return false;
+}
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/audio_device_qnx.h b/modules/audio_device/qnx/audio_device_qnx.h
new file mode 100644
index 0000000000..8ae3586017
--- /dev/null
+++ b/modules/audio_device/qnx/audio_device_qnx.h
@@ -0,0 +1,214 @@
+/*
+ *  Copyright (c) 2023 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef AUDIO_DEVICE_AUDIO_DEVICE_QNX_H_
+#define AUDIO_DEVICE_AUDIO_DEVICE_QNX_H_
+
+#include <sys/asoundlib.h>
+#include <sys/ioctl.h>
+
+#include <memory>
+
+#include "modules/audio_device/audio_device_generic.h"
+#include "modules/audio_device/qnx/audio_mixer_manager_qnx.h"
+#include "rtc_base/platform_thread.h"
+#include "rtc_base/synchronization/mutex.h"
+
+typedef unsigned long snd_pcm_uframes_t;
+typedef long snd_pcm_sframes_t;
+
+typedef webrtc::adm_qnx_qsa::QsaSymbolTable WebRTCQsaSymbolTable;
+WebRTCQsaSymbolTable* GetQsaSymbolTable();
+
+namespace webrtc {
+
+class AudioDeviceQnx : public AudioDeviceGeneric {
+ public:
+  AudioDeviceQnx();
+  virtual ~AudioDeviceQnx();
+
+  // Retrieve the currently utilized audio layer
+  int32_t ActiveAudioLayer(
+      AudioDeviceModule::AudioLayer& audioLayer) const override;
+
+  // Main initializaton and termination
+  InitStatus Init() RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t Terminate() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool Initialized() const override;
+
+  // Device enumeration
+  int16_t PlayoutDevices() override;
+  int16_t RecordingDevices() override;
+  int32_t PlayoutDeviceName(uint16_t index,
+                            char name[kAdmMaxDeviceNameSize],
+                            char guid[kAdmMaxGuidSize]) override;
+  int32_t RecordingDeviceName(uint16_t index,
+                              char name[kAdmMaxDeviceNameSize],
+                              char guid[kAdmMaxGuidSize]) override;
+
+  // Device selection
+  int32_t SetPlayoutDevice(uint16_t index) override;
+  int32_t SetPlayoutDevice(
+      AudioDeviceModule::WindowsDeviceType device) override;
+  int32_t SetRecordingDevice(uint16_t index) override;
+  int32_t SetRecordingDevice(
+      AudioDeviceModule::WindowsDeviceType device) override;
+
+  // Audio transport initialization
+  int32_t PlayoutIsAvailable(bool& available) override;
+  int32_t InitPlayout() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool PlayoutIsInitialized() const override;
+  int32_t RecordingIsAvailable(bool& available) override;
+  int32_t InitRecording() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool RecordingIsInitialized() const override;
+
+  // Audio transport control
+  int32_t StartPlayout() override;
+  int32_t StopPlayout() override;
+  bool Playing() const override;
+  int32_t StartRecording() override;
+  int32_t StopRecording() override;
+  bool Recording() const override;
+
+  // Audio mixer initialization
+  int32_t InitSpeaker() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool SpeakerIsInitialized() const override;
+  int32_t InitMicrophone() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool MicrophoneIsInitialized() const override;
+
+  // Speaker volume controls
+  int32_t SpeakerVolumeIsAvailable(bool& available) override;
+  int32_t SetSpeakerVolume(uint32_t volume) override;
+  int32_t SpeakerVolume(uint32_t& volume) const override;
+  int32_t MaxSpeakerVolume(uint32_t& maxVolume) const override;
+  int32_t MinSpeakerVolume(uint32_t& minVolume) const override;
+
+  // Microphone volume controls
+  int32_t MicrophoneVolumeIsAvailable(bool& available) override;
+  int32_t SetMicrophoneVolume(uint32_t volume) override;
+  int32_t MicrophoneVolume(uint32_t& volume) const override;
+  int32_t MaxMicrophoneVolume(uint32_t& maxVolume) const override;
+  int32_t MinMicrophoneVolume(uint32_t& minVolume) const override;
+
+  // Speaker mute control
+  int32_t SpeakerMuteIsAvailable(bool& available) override;
+  int32_t SetSpeakerMute(bool enable) override;
+  int32_t SpeakerMute(bool& enabled) const override;
+
+  // Microphone mute control
+  int32_t MicrophoneMuteIsAvailable(bool& available) override;
+  int32_t SetMicrophoneMute(bool enable) override;
+  int32_t MicrophoneMute(bool& enabled) const override;
+
+  // Stereo support
+  int32_t StereoPlayoutIsAvailable(bool& available)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t SetStereoPlayout(bool enable) override;
+  int32_t StereoPlayout(bool& enabled) const override;
+  int32_t StereoRecordingIsAvailable(bool& available)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t SetStereoRecording(bool enable) override;
+  int32_t StereoRecording(bool& enabled) const override;
+
+  // Delay information and control
+  int32_t PlayoutDelay(uint16_t& delayMS) const override;
+
+  void AttachAudioBuffer(AudioDeviceBuffer* audioBuffer)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+
+ private:
+  int32_t InitRecordingLocked(bool initMicrophone = true) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitPlayoutLocked(bool initSpeaker = true) RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitSpeakerLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitMicrophoneLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t GetDevicesInfo(int32_t function,
+                         bool playback,
+                         int32_t enumDeviceNo = 0,
+                         char* enumDeviceName = NULL,
+                         int32_t ednLen = 0) const;
+  int32_t ErrorRecovery(int32_t error,
+                        snd_pcm_t* deviceHandle,
+                        int32_t channel);
+
+  ssize_t ParamsToBytes(int32_t format, long frames, uint8_t channels);
+
+  bool KeyPressed() const;
+
+  void Lock() RTC_EXCLUSIVE_LOCK_FUNCTION(mutex_) { mutex_.Lock(); }
+  void UnLock() RTC_UNLOCK_FUNCTION(mutex_) { mutex_.Unlock(); }
+
+  inline int32_t InputSanityCheckAfterUnlockedPeriod() const;
+  inline int32_t OutputSanityCheckAfterUnlockedPeriod() const;
+
+  bool RecThreadProcess();
+  bool PlayThreadProcess();
+
+  AudioDeviceBuffer* _ptrAudioBuffer;
+
+  Mutex mutex_;
+
+  rtc::PlatformThread _ptrThreadRec;
+  rtc::PlatformThread _ptrThreadPlay;
+
+  AudioMixerManagerQnx _mixerManager;
+
+  uint16_t _inputDeviceIndex;
+  uint16_t _outputDeviceIndex;
+  bool _inputDeviceIsSpecified;
+  bool _outputDeviceIsSpecified;
+
+  std::atomic<snd_pcm_t*> _handlePlayout;
+  std::atomic<snd_pcm_t*> _handleRecord;
+
+  snd_pcm_uframes_t _recordingBuffersizeInFrame;
+  snd_pcm_uframes_t _recordingPeriodSizeInFrame;
+  snd_pcm_uframes_t _playoutBufferSizeInFrame;
+  snd_pcm_uframes_t _playoutPeriodSizeInFrame;
+
+  uint32_t _recordingBufferSizeInNMS;
+  uint32_t _playoutBufferSizeInNMS;
+  uint32_t _recordingFramesInNMS;
+  uint32_t _playoutFramesInNMS;
+
+  uint32_t _recordingFreq;
+  uint32_t _playoutFreq;
+  uint8_t _recChannels;
+  uint8_t _playChannels;
+
+  int8_t* _recordingBuffer;  // in byte
+  int8_t* _playoutBuffer;    // in byte
+  uint32_t _playoutBytesLeft;
+
+  std::atomic<bool> _initialized;
+  std::atomic<bool> _recording;
+  std::atomic<bool> _playing;
+  std::atomic<bool> _writing;
+  std::atomic<bool> _reading;
+
+  snd_pcm_sframes_t _recordingDelay;
+  snd_pcm_sframes_t _playoutDelay;
+
+  int32_t _recordingFormat;
+  int32_t _playoutFormat;
+  int32_t _recordingFD;
+  int32_t _playoutFD;
+  uint32_t _recordingFragSize;
+  uint32_t _recordingBufferSize;
+  int32_t _recordingBufferDataSize;
+  uint32_t _playoutFragSize;
+  uint32_t _playoutBufferSize;
+  int32_t _playoutBufferDataSize;
+
+  char _oldKeyState[32];
+};
+
+}  // namespace webrtc
+
+#endif
diff --git a/modules/audio_device/qnx/audio_mixer_manager_qnx.cc b/modules/audio_device/qnx/audio_mixer_manager_qnx.cc
new file mode 100644
index 0000000000..4cdf970362
--- /dev/null
+++ b/modules/audio_device/qnx/audio_mixer_manager_qnx.cc
@@ -0,0 +1,497 @@
+/*
+ *  Copyright (c) 2023 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_device/qnx/audio_mixer_manager_qnx.h"
+
+#include "modules/audio_device/qnx/audio_device_qnx.h"
+#include "rtc_base/logging.h"
+
+#define LATE(sym) \
+  LATESYM_GET(webrtc::adm_qnx_qsa::QsaSymbolTable, GetQsaSymbolTable(), sym)
+
+namespace webrtc {
+
+namespace {
+std::unique_ptr<snd_mixer_group_t> groupForID(snd_mixer_t* handle,
+                                              snd_mixer_gid_t* gid) {
+  auto group = std::make_unique<snd_mixer_group_t>();
+  memset(group.get(), 0, sizeof(snd_mixer_group_t));
+  memcpy(&(group->gid), gid, sizeof(snd_mixer_gid_t));
+  int errVal = LATE(snd_mixer_group_read)(handle, group.get());
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error snd_mixer_group_read: "
+                      << LATE(snd_strerror)(errVal);
+    return {};
+  }
+  return std::move(group);
+}
+
+bool updateGroup(snd_mixer_t* handle, snd_mixer_group_t* group) {
+  int errVal = LATE(snd_mixer_group_write)(handle, group);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error snd_mixer_group_write: "
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  return true;
+}
+
+}  // namespace
+
+AudioMixerManagerQnx::AudioMixerManagerQnx()
+    : _outputMixerHandle(NULL),
+      _inputMixerHandle(NULL),
+      _outputMixerGid(nullptr),
+      _inputMixerGid(nullptr) {
+  RTC_LOG(LS_INFO) << __FUNCTION__ << " created";
+}
+
+AudioMixerManagerQnx::~AudioMixerManagerQnx() {
+  RTC_LOG(LS_INFO) << __FUNCTION__ << " destroyed";
+  Close();
+}
+
+// ============================================================================
+//                                    PUBLIC METHODS
+// ============================================================================
+
+int32_t AudioMixerManagerQnx::Close() {
+  RTC_LOG(LS_VERBOSE) << __FUNCTION__;
+
+  MutexLock lock(&mutex_);
+
+  CloseSpeaker();
+  CloseMicrophone();
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::CloseSpeaker() {
+  RTC_LOG(LS_VERBOSE) << __FUNCTION__;
+  MutexLock lock(&mutex_);
+  if (_outputMixerHandle != NULL) {
+    int errVal = LATE(snd_mixer_close)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    _outputMixerHandle = NULL;
+  }
+  _outputMixerGid.reset(0);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::CloseMicrophone() {
+  RTC_LOG(LS_VERBOSE) << __FUNCTION__;
+  MutexLock lock(&mutex_);
+  if (_inputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+    int errVal = LATE(snd_mixer_close)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer 4";
+    _inputMixerHandle = NULL;
+  }
+  _inputMixerGid.reset(0);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::OpenSpeaker(
+    snd_pcm_t* deviceHandle,
+    std::unique_ptr<snd_mixer_gid_t> gid) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::OpenSpeaker(pcm handle="
+                      << deviceHandle << ")";
+  MutexLock lock(&mutex_);
+  int errVal = 0;
+  if (_outputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing playout mixer";
+    errVal = LATE(snd_mixer_close)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    _outputMixerHandle = NULL;
+  }
+
+  errVal = LATE(snd_mixer_open_pcm)(&_outputMixerHandle, deviceHandle);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_open(&_outputMixerHandle, 0) - error";
+    return -1;
+  }
+
+  if (_outputMixerHandle) {
+    RTC_LOG(LS_VERBOSE) << "the output mixer device is now open ("
+                        << _outputMixerHandle << ")";
+    _outputMixerGid = std::move(gid);
+    return 0;
+  }
+  return -1;
+}
+
+int32_t AudioMixerManagerQnx::OpenMicrophone(
+    snd_pcm_t* deviceHandle,
+    std::unique_ptr<snd_mixer_gid_t> gid) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::OpenMicrophone(pcm handle="
+                      << deviceHandle << ")";
+
+  MutexLock lock(&mutex_);
+
+  int errVal = 0;
+
+  if (_inputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+
+    errVal = LATE(snd_mixer_close)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+    _inputMixerHandle = NULL;
+  }
+
+  errVal = LATE(snd_mixer_open_pcm)(&_inputMixerHandle, deviceHandle);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_open(&_inputMixerHandle, 0) - error";
+    return -1;
+  }
+
+  if (_inputMixerHandle) {
+    RTC_LOG(LS_VERBOSE) << "the input mixer device is now open ("
+                        << _inputMixerHandle << ")";
+    _inputMixerGid = std::move(gid);
+    return 0;
+  }
+
+  return -1;
+}
+
+bool AudioMixerManagerQnx::SpeakerIsInitialized() const {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+
+  return _outputMixerHandle;
+}
+
+bool AudioMixerManagerQnx::MicrophoneIsInitialized() const {
+  RTC_LOG(LS_INFO) << __FUNCTION__;
+
+  return _inputMixerHandle;
+}
+
+int32_t AudioMixerManagerQnx::SetSpeakerVolume(uint32_t volume) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::SetSpeakerVolume(volume="
+                      << volume << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_LEFT)
+    group->volume.names.front_left = volume;
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_RIGHT)
+    group->volume.names.front_right = volume;
+
+  if (updateGroup(_outputMixerHandle, group.get()))
+    return 0;
+
+  return -1;
+}
+
+int32_t AudioMixerManagerQnx::SpeakerVolume(uint32_t& volume) const {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  volume = group->volume.names.front_left;
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MaxSpeakerVolume(uint32_t& maxVolume) const {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avilable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  maxVolume = group->max;
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MinSpeakerVolume(uint32_t& minVolume) const {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  minVolume = group->min;
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::SpeakerVolumeIsAvailable(bool& available) {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  available = (group->caps & SND_MIXER_GRPCAP_VOLUME);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::SpeakerMuteIsAvailable(bool& available) {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  available = (group->caps & SND_MIXER_GRPCAP_MUTE);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::SetSpeakerMute(bool enable) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::SetSpeakerMute(enable="
+                      << enable << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  // Ensure that the selected speaker destination has a valid mute control.
+  bool available(false);
+  SpeakerMuteIsAvailable(available);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the speaker";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_LEFT) {
+    if (enable)
+      group->mute |= SND_MIXER_CHN_MASK_FRONT_LEFT;
+    else
+      group->mute &= ~SND_MIXER_CHN_MASK_FRONT_LEFT;
+  }
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_RIGHT) {
+    if (enable)
+      group->mute |= SND_MIXER_CHN_MASK_FRONT_RIGHT;
+    else
+      group->mute &= ~SND_MIXER_CHN_MASK_FRONT_RIGHT;
+  }
+
+  if (updateGroup(_outputMixerHandle, group.get()))
+    return 0;
+
+  return -1;
+}
+
+int32_t AudioMixerManagerQnx::SpeakerMute(bool& enabled) const {
+  if (!_outputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer exists";
+    return -1;
+  }
+
+  auto group = groupForID(_outputMixerHandle, _outputMixerGid.get());
+  if (!group)
+    return -1;
+
+  enabled = (group->mute & SND_MIXER_CHN_MASK_FRONT_LEFT);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MicrophoneMuteIsAvailable(bool& available) {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  available = (group->caps & SND_MIXER_GRPCAP_MUTE);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::SetMicrophoneMute(bool enable) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::SetMicrophoneMute(enable="
+                      << enable << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  bool available(false);
+  MicrophoneMuteIsAvailable(available);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the microphone";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_LEFT) {
+    if (enable)
+      group->mute |= SND_MIXER_CHN_MASK_FRONT_LEFT;
+    else
+      group->mute &= ~SND_MIXER_CHN_MASK_FRONT_LEFT;
+  }
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_RIGHT) {
+    if (enable)
+      group->mute |= SND_MIXER_CHN_MASK_FRONT_RIGHT;
+    else
+      group->mute &= ~SND_MIXER_CHN_MASK_FRONT_RIGHT;
+  }
+
+  if (updateGroup(_outputMixerHandle, group.get()))
+    return 0;
+
+  return -1;
+}
+
+int32_t AudioMixerManagerQnx::MicrophoneMute(bool& enabled) const {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  enabled = (group->mute & SND_MIXER_CHN_MASK_FRONT_LEFT);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MicrophoneVolumeIsAvailable(bool& available) {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  available = (group->caps & SND_MIXER_GRPCAP_VOLUME);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::SetMicrophoneVolume(uint32_t volume) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnx::SetMicrophoneVolume(volume="
+                      << volume << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_LEFT)
+    group->volume.names.front_left = volume;
+  if (group->channel_mask & SND_MIXER_CHN_MASK_FRONT_RIGHT)
+    group->volume.names.front_right = volume;
+
+  if (updateGroup(_inputMixerHandle, group.get()))
+    return 0;
+
+  return -1;
+}
+
+int32_t AudioMixerManagerQnx::MicrophoneVolume(uint32_t& volume) const {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  volume = group->volume.names.front_left;
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MaxMicrophoneVolume(uint32_t& maxVolume) const {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  maxVolume = group->max;
+  return 0;
+}
+
+int32_t AudioMixerManagerQnx::MinMicrophoneVolume(uint32_t& minVolume) const {
+  if (!_inputMixerGid) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  auto group = groupForID(_inputMixerHandle, _inputMixerGid.get());
+  if (!group)
+    return -1;
+
+  minVolume = group->min;
+  return 0;
+}
+
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/audio_mixer_manager_qnx.h b/modules/audio_device/qnx/audio_mixer_manager_qnx.h
new file mode 100644
index 0000000000..4aae6e5c3c
--- /dev/null
+++ b/modules/audio_device/qnx/audio_mixer_manager_qnx.h
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (c) 2023 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef AUDIO_DEVICE_AUDIO_MIXER_MANAGER_QNX_H_
+#define AUDIO_DEVICE_AUDIO_MIXER_MANAGER_QNX_H_
+
+#include <sys/asoundlib.h>
+
+#include "modules/audio_device/include/audio_device.h"
+#include "modules/audio_device/qnx/qsasymboltable_qnx.h"
+#include "rtc_base/synchronization/mutex.h"
+
+namespace webrtc {
+
+class AudioMixerManagerQnx {
+ public:
+  int32_t OpenSpeaker(snd_pcm_t* deviceHandle,
+                      std::unique_ptr<snd_mixer_gid_t> gid);
+  int32_t OpenMicrophone(snd_pcm_t* deviceHandle,
+                         std::unique_ptr<snd_mixer_gid_t> gid);
+  int32_t SetSpeakerVolume(uint32_t volume);
+  int32_t SpeakerVolume(uint32_t& volume) const;
+  int32_t MaxSpeakerVolume(uint32_t& maxVolume) const;
+  int32_t MinSpeakerVolume(uint32_t& minVolume) const;
+  int32_t SpeakerVolumeIsAvailable(bool& available);
+  int32_t SpeakerMuteIsAvailable(bool& available);
+  int32_t SetSpeakerMute(bool enable);
+  int32_t SpeakerMute(bool& enabled) const;
+  int32_t MicrophoneMuteIsAvailable(bool& available);
+  int32_t SetMicrophoneMute(bool enable);
+  int32_t MicrophoneMute(bool& enabled) const;
+  int32_t MicrophoneVolumeIsAvailable(bool& available);
+  int32_t SetMicrophoneVolume(uint32_t volume);
+  int32_t MicrophoneVolume(uint32_t& volume) const;
+  int32_t MaxMicrophoneVolume(uint32_t& maxVolume) const;
+  int32_t MinMicrophoneVolume(uint32_t& minVolume) const;
+  int32_t Close();
+  int32_t CloseSpeaker();
+  int32_t CloseMicrophone();
+  bool SpeakerIsInitialized() const;
+  bool MicrophoneIsInitialized() const;
+
+ public:
+  AudioMixerManagerQnx();
+  ~AudioMixerManagerQnx();
+
+ private:
+  Mutex mutex_;
+  mutable snd_mixer_t* _outputMixerHandle;
+  mutable snd_mixer_t* _inputMixerHandle;
+  std::unique_ptr<snd_mixer_gid_t> _outputMixerGid;
+  std::unique_ptr<snd_mixer_gid_t> _inputMixerGid;
+};
+
+}  // namespace webrtc
+
+#endif
diff --git a/modules/audio_device/qnx/qsasymboltable_qnx.cc b/modules/audio_device/qnx/qsasymboltable_qnx.cc
new file mode 100644
index 0000000000..2d4cef53d4
--- /dev/null
+++ b/modules/audio_device/qnx/qsasymboltable_qnx.cc
@@ -0,0 +1,40 @@
+/*
+ * libjingle
+ * Copyright 2004--2010, Google Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "modules/audio_device/qnx/qsasymboltable_qnx.h"
+
+namespace webrtc {
+namespace adm_qnx_qsa {
+
+LATE_BINDING_SYMBOL_TABLE_DEFINE_BEGIN(QsaSymbolTable, "libasound.so.3")
+#define X(sym) LATE_BINDING_SYMBOL_TABLE_DEFINE_ENTRY(QsaSymbolTable, sym)
+QSA_SYMBOLS_LIST
+#undef X
+LATE_BINDING_SYMBOL_TABLE_DEFINE_END(QsaSymbolTable)
+
+}  // namespace adm_qnx_qsa
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/qsasymboltable_qnx.h b/modules/audio_device/qnx/qsasymboltable_qnx.h
new file mode 100644
index 0000000000..e56f8953e9
--- /dev/null
+++ b/modules/audio_device/qnx/qsasymboltable_qnx.h
@@ -0,0 +1,82 @@
+/*
+ * libjingle
+ * Copyright 2004--2010, Google Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef AUDIO_DEVICE_QSASYMBOLTABLE_QNX_H_
+#define AUDIO_DEVICE_QSASYMBOLTABLE_QNX_H_
+
+#include "modules/utility/source/late_binding_symbol_table_posix.h"
+
+namespace webrtc {
+namespace adm_qnx_qsa {
+
+// The QSA symbols we need, as an X-Macro list.
+#define QSA_SYMBOLS_LIST                       \
+  X(snd_strerror)                              \
+  X(snd_pcm_close)                             \
+  X(snd_pcm_channel_drain)                     \
+  X(snd_pcm_channel_drop)                      \
+  X(snd_pcm_channel_go)                        \
+  X(snd_pcm_channel_info)                      \
+  X(snd_pcm_channel_params)                    \
+  X(snd_pcm_channel_prepare)                   \
+  X(snd_pcm_channel_setup)                     \
+  X(snd_pcm_channel_status)                    \
+  X(snd_pcm_file_descriptor)                   \
+  X(snd_pcm_find)                              \
+  X(snd_pcm_format_width)                      \
+  X(snd_pcm_info)                              \
+  X(snd_pcm_open)                              \
+  X(snd_pcm_open_name)                         \
+  X(snd_pcm_open_preferred)                    \
+  X(snd_pcm_plugin_drain)                      \
+  X(snd_pcm_plugin_drop)                       \
+  X(snd_pcm_plugin_info)                       \
+  X(snd_pcm_plugin_read)                       \
+  X(snd_pcm_plugin_params)                     \
+  X(snd_pcm_plugin_prepare)                    \
+  X(snd_pcm_plugin_setup)                      \
+  X(snd_pcm_plugin_status)                     \
+  X(snd_pcm_plugin_write)                      \
+  X(snd_pcm_prepare)                           \
+  X(snd_pcm_read)                              \
+  X(snd_pcm_write)                             \
+  X(snd_mixer_close)                           \
+  X(snd_mixer_group_read)                      \
+  X(snd_mixer_group_write)                     \
+  X(snd_mixer_open)                            \
+  X(snd_mixer_open_pcm)
+
+LATE_BINDING_SYMBOL_TABLE_DECLARE_BEGIN(QsaSymbolTable)
+#define X(sym) LATE_BINDING_SYMBOL_TABLE_DECLARE_ENTRY(QsaSymbolTable, sym)
+QSA_SYMBOLS_LIST
+#undef X
+LATE_BINDING_SYMBOL_TABLE_DECLARE_END(QsaSymbolTable)
+
+}  // namespace adm_qnx_qsa
+}  // namespace webrtc
+
+#endif  // AUDIO_DEVICE_QSASYMBOLTABLE_QNX_H_
diff --git a/modules/audio_mixer/audio_mixer_impl.cc b/modules/audio_mixer/audio_mixer_impl.cc
index faa2b1e1ee..2f1e3ca87d 100644
--- a/modules/audio_mixer/audio_mixer_impl.cc
+++ b/modules/audio_mixer/audio_mixer_impl.cc
@@ -92,9 +92,17 @@ void AudioMixerImpl::Mix(size_t number_of_channels,
 
   std::transform(audio_source_list_.begin(), audio_source_list_.end(),
                  helper_containers_->preferred_rates.begin(),
+#if defined(WEBRTC_QNX) // workaround just for not crash
+                 [](std::unique_ptr<SourceStatus>& a) {
+                    if ( a && a->audio_source)
+                      return a->audio_source->PreferredSampleRate();
+                    return 48000;
+                 });
+#else
                  [&](std::unique_ptr<SourceStatus>& a) {
                    return a->audio_source->PreferredSampleRate();
                  });
+#endif
 
   int output_frequency = output_rate_calculator_->CalculateOutputRateFromRange(
       rtc::ArrayView<const int>(helper_containers_->preferred_rates.data(),
-- 
2.34.1

