From 24893c761ad6142dfc19b0ff617dad2a432441f6 Mon Sep 17 00:00:00 2001
From: Yongxin Dai <yodai@blackberry.com>
Date: Thu, 9 May 2024 07:50:07 -0400
Subject: [PATCH] QNX io-snd based implementation for audio device

---
 modules/audio_device/BUILD.gn                 |   40 +-
 modules/audio_device/audio_device_impl.cc     |   11 +-
 .../qnx/alsasymboltable_snd_qnx.cc            |   40 +
 .../qnx/alsasymboltable_snd_qnx.h             |  158 ++
 .../qnx/audio_device_alsa_snd_qnx.cc          | 1963 +++++++++++++++++
 .../qnx/audio_device_alsa_snd_qnx.h           |  252 +++
 .../qnx/audio_mixer_manager_alsa_snd_qnx.cc   |  979 ++++++++
 .../qnx/audio_mixer_manager_alsa_snd_qnx.h    |   71 +
 .../qnx/latebindingsymboltable_snd_qnx.cc     |  106 +
 .../qnx/latebindingsymboltable_snd_qnx.h      |  165 ++
 10 files changed, 3773 insertions(+), 12 deletions(-)
 create mode 100644 modules/audio_device/qnx/alsasymboltable_snd_qnx.cc
 create mode 100644 modules/audio_device/qnx/alsasymboltable_snd_qnx.h
 create mode 100644 modules/audio_device/qnx/audio_device_alsa_snd_qnx.cc
 create mode 100644 modules/audio_device/qnx/audio_device_alsa_snd_qnx.h
 create mode 100644 modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.cc
 create mode 100644 modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h
 create mode 100644 modules/audio_device/qnx/latebindingsymboltable_snd_qnx.cc
 create mode 100644 modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h

diff --git a/modules/audio_device/BUILD.gn b/modules/audio_device/BUILD.gn
index 631d52afca..60288a116b 100644
--- a/modules/audio_device/BUILD.gn
+++ b/modules/audio_device/BUILD.gn
@@ -13,6 +13,10 @@ if (is_android) {
   import("//build/config/android/rules.gni")
 }
 
+if (is_qnx) {
+  import("//build/config/qnx/config.gni")
+}
+
 config("audio_device_warnings_config") {
   if (is_win && is_clang) {
     cflags = [
@@ -390,17 +394,31 @@ rtc_library("audio_device_impl") {
         ]
       }
       if (is_qnx) {
-        sources += [
-          "qnx/audio_device_qnx.cc",
-          "qnx/audio_device_qnx.h",
-          "qnx/audio_mixer_manager_qnx.cc",
-          "qnx/audio_mixer_manager_qnx.h",
-          "qnx/qsasymboltable_qnx.cc",
-          "qnx/qsasymboltable_qnx.h",
-        ]
-        deps += [
-          "../utility:late_binding_symbol_table",
-        ]
+        if (rtc_qnx_use_io_snd) {
+          defines = [ "WEBRTC_QNX_USE_IO_SND" ]
+          sources += [
+            "qnx/alsasymboltable_snd_qnx.cc",
+            "qnx/alsasymboltable_snd_qnx.h",
+            "qnx/audio_device_alsa_snd_qnx.cc",
+            "qnx/audio_device_alsa_snd_qnx.h",
+            "qnx/audio_mixer_manager_alsa_snd_qnx.cc",
+            "qnx/audio_mixer_manager_alsa_snd_qnx.h",
+            "qnx/latebindingsymboltable_snd_qnx.cc",
+            "qnx/latebindingsymboltable_snd_qnx.h",
+          ]
+        } else {
+          sources += [
+            "qnx/audio_device_qnx.cc",
+            "qnx/audio_device_qnx.h",
+            "qnx/audio_mixer_manager_qnx.cc",
+            "qnx/audio_mixer_manager_qnx.h",
+            "qnx/qsasymboltable_qnx.cc",
+            "qnx/qsasymboltable_qnx.h",
+          ]
+          deps += [
+            "../utility:late_binding_symbol_table",
+          ]
+        }
       }
       configs += [ ":audio_device_warnings_config" ]
     }
diff --git a/modules/audio_device/audio_device_impl.cc b/modules/audio_device/audio_device_impl.cc
index f6c7091357..61b4857da2 100644
--- a/modules/audio_device/audio_device_impl.cc
+++ b/modules/audio_device/audio_device_impl.cc
@@ -39,8 +39,12 @@
 #elif defined(WEBRTC_MAC)
 #include "modules/audio_device/mac/audio_device_mac.h"
 #elif defined(WEBRTC_QNX)
+#if defined(WEBRTC_QNX_USE_IO_SND)
+#include "modules/audio_device/qnx/audio_device_alsa_snd_qnx.h"
+#else
 #include "modules/audio_device/qnx/audio_device_qnx.h"
 #endif
+#endif
 #if defined(WEBRTC_DUMMY_FILE_DEVICES)
 #include "modules/audio_device/dummy/file_audio_device.h"
 #include "modules/audio_device/dummy/file_audio_device_factory.h"
@@ -261,8 +265,13 @@ int32_t AudioDeviceModuleImpl::CreatePlatformSpecificObjects() {
 
 #if defined(WEBRTC_QNX)
   if (audio_layer == kPlatformDefaultAudio) {
+#if defined(WEBRTC_QNX_USE_IO_SND)
+    audio_device_.reset(new AudioDeviceQnxALSA());
+    RTC_LOG(LS_INFO) << "QNX io-sound APIs will be utilized.";
+#else
     audio_device_.reset(new AudioDeviceQnx());
-    RTC_LOG(LS_WARNING) << "QNX ALSA APIs will be utilized.";
+    RTC_LOG(LS_INFO) << "QNX io-audio APIs will be utilized.";
+#endif
   }
 #endif
 
diff --git a/modules/audio_device/qnx/alsasymboltable_snd_qnx.cc b/modules/audio_device/qnx/alsasymboltable_snd_qnx.cc
new file mode 100644
index 0000000000..a831f5f470
--- /dev/null
+++ b/modules/audio_device/qnx/alsasymboltable_snd_qnx.cc
@@ -0,0 +1,40 @@
+/*
+ * libjingle
+ * Copyright 2004--2010, Google Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "modules/audio_device/qnx/alsasymboltable_snd_qnx.h"
+
+namespace webrtc {
+namespace adm_qnx_alsa {
+
+LATE_BINDING_SYMBOL_TABLE_DEFINE_BEGIN(AlsaSymbolTable, "/lib/snd/libasound.so")
+#define X(sym) LATE_BINDING_SYMBOL_TABLE_DEFINE_ENTRY(AlsaSymbolTable, sym)
+ALSA_SYMBOLS_LIST
+#undef X
+LATE_BINDING_SYMBOL_TABLE_DEFINE_END(AlsaSymbolTable)
+
+}  // namespace adm_qnx_alsa
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/alsasymboltable_snd_qnx.h b/modules/audio_device/qnx/alsasymboltable_snd_qnx.h
new file mode 100644
index 0000000000..0698e7715c
--- /dev/null
+++ b/modules/audio_device/qnx/alsasymboltable_snd_qnx.h
@@ -0,0 +1,158 @@
+/*
+ * libjingle
+ * Copyright 2004--2010, Google Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef AUDIO_DEVICE_ALSASYMBOLTABLE_QNX_H_
+#define AUDIO_DEVICE_ALSASYMBOLTABLE_QNX_H_
+
+#include "modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h"
+
+namespace webrtc {
+namespace adm_qnx_alsa {
+
+// The ALSA symbols we need, as an X-Macro list.
+// This list must contain precisely every libasound function that is used in
+// alsasoundsystem.cc.
+#define ALSA_SYMBOLS_LIST                      \
+  X(snd_device_name_free_hint)                 \
+  X(snd_device_name_get_hint)                  \
+  X(snd_device_name_hint)                      \
+  X(snd_pcm_avail_update)                      \
+  X(snd_pcm_close)                             \
+  X(snd_pcm_delay)                             \
+  X(snd_pcm_drop)                              \
+  X(snd_pcm_open)                              \
+  X(snd_pcm_prepare)                           \
+  X(snd_pcm_readi)                             \
+  X(snd_pcm_recover)                           \
+  X(snd_pcm_resume)                            \
+  X(snd_pcm_reset)                             \
+  X(snd_pcm_state)                             \
+  X(snd_pcm_set_params)                        \
+  X(snd_pcm_get_params)                        \
+  X(snd_pcm_start)                             \
+  X(snd_pcm_stream)                            \
+  X(snd_pcm_frames_to_bytes)                   \
+  X(snd_pcm_bytes_to_frames)                   \
+  X(snd_pcm_wait)                              \
+  X(snd_pcm_writei)                            \
+  X(snd_pcm_info_get_class)                    \
+  X(snd_pcm_info_get_subdevices_avail)         \
+  X(snd_pcm_info_get_subdevice_name)           \
+  X(snd_pcm_info_set_subdevice)                \
+  X(snd_pcm_info_get_id)                       \
+  X(snd_pcm_info_set_device)                   \
+  X(snd_pcm_info_set_stream)                   \
+  X(snd_pcm_info_get_name)                     \
+  X(snd_pcm_info_get_subdevices_count)         \
+  X(snd_pcm_info_sizeof)                       \
+  X(snd_pcm_hw_params)                         \
+  X(snd_pcm_hw_params_malloc)                  \
+  X(snd_pcm_hw_params_free)                    \
+  X(snd_pcm_hw_params_any)                     \
+  X(snd_pcm_hw_params_get_buffer_size)         \
+  X(snd_pcm_hw_params_get_period_size)         \
+  X(snd_pcm_hw_params_set_access)              \
+  X(snd_pcm_hw_params_set_format)              \
+  X(snd_pcm_hw_params_set_channels)            \
+  X(snd_pcm_hw_params_set_period_size_near)    \
+  X(snd_pcm_hw_params_set_rate)                \
+  X(snd_pcm_hw_params_set_rate_near)           \
+  X(snd_pcm_hw_params_set_buffer_size_near)    \
+  X(snd_pcm_hw_params_sizeof)                  \
+  X(snd_pcm_status)                            \
+  X(snd_pcm_status_get_state)                  \
+  X(snd_pcm_status_sizeof)                     \
+  X(snd_pcm_sw_params)                         \
+  X(snd_pcm_sw_params_current)                 \
+  X(snd_pcm_sw_params_set_avail_min)           \
+  X(snd_pcm_sw_params_set_start_threshold)     \
+  X(snd_pcm_sw_params_sizeof)                  \
+  X(snd_card_next)                             \
+  X(snd_card_get_name)                         \
+  X(snd_config_update)                         \
+  X(snd_config_copy)                           \
+  X(snd_config_get_id)                         \
+  X(snd_ctl_open)                              \
+  X(snd_ctl_close)                             \
+  X(snd_ctl_card_info)                         \
+  X(snd_ctl_card_info_sizeof)                  \
+  X(snd_ctl_card_info_get_id)                  \
+  X(snd_ctl_card_info_get_name)                \
+  X(snd_ctl_pcm_next_device)                   \
+  X(snd_ctl_pcm_info)                          \
+  X(snd_mixer_load)                            \
+  X(snd_mixer_free)                            \
+  X(snd_mixer_detach)                          \
+  X(snd_mixer_close)                           \
+  X(snd_mixer_open)                            \
+  X(snd_mixer_attach)                          \
+  X(snd_mixer_first_elem)                      \
+  X(snd_mixer_elem_next)                       \
+  X(snd_mixer_selem_get_name)                  \
+  X(snd_mixer_selem_is_active)                 \
+  X(snd_mixer_selem_register)                  \
+  X(snd_mixer_selem_set_playback_volume_all)   \
+  X(snd_mixer_selem_get_playback_volume)       \
+  X(snd_mixer_selem_has_playback_volume)       \
+  X(snd_mixer_selem_get_playback_volume_range) \
+  X(snd_mixer_selem_has_playback_switch)       \
+  X(snd_mixer_selem_get_playback_switch)       \
+  X(snd_mixer_selem_set_playback_switch_all)   \
+  X(snd_mixer_selem_has_capture_switch)        \
+  X(snd_mixer_selem_get_capture_switch)        \
+  X(snd_mixer_selem_set_capture_switch_all)    \
+  X(snd_mixer_selem_has_capture_volume)        \
+  X(snd_mixer_selem_set_capture_volume_all)    \
+  X(snd_mixer_selem_get_capture_volume)        \
+  X(snd_mixer_selem_get_capture_volume_range)  \
+  X(snd_config)                                \
+  X(snd_config_search)                         \
+  X(snd_config_get_string)                     \
+  X(snd_config_search_definition)              \
+  X(snd_config_get_type)                       \
+  X(snd_config_delete)                         \
+  X(snd_config_iterator_entry)                 \
+  X(snd_config_iterator_first)                 \
+  X(snd_config_iterator_next)                  \
+  X(snd_config_iterator_end)                   \
+  X(snd_config_delete_compound_members)        \
+  X(snd_config_get_integer)                    \
+  X(snd_config_get_bool)                       \
+  X(snd_strerror)                              \
+  X(snd_lib_error)                             \
+  X(snd_lib_error_set_handler)
+
+LATE_BINDING_SYMBOL_TABLE_DECLARE_BEGIN(AlsaSymbolTable)
+#define X(sym) LATE_BINDING_SYMBOL_TABLE_DECLARE_ENTRY(AlsaSymbolTable, sym)
+ALSA_SYMBOLS_LIST
+#undef X
+LATE_BINDING_SYMBOL_TABLE_DECLARE_END(AlsaSymbolTable)
+
+}  // namespace adm_qnx_alsa
+}  // namespace webrtc
+
+#endif  // AUDIO_DEVICE_ALSASYMBOLTABLE_QNX_H_
diff --git a/modules/audio_device/qnx/audio_device_alsa_snd_qnx.cc b/modules/audio_device/qnx/audio_device_alsa_snd_qnx.cc
new file mode 100644
index 0000000000..e07afd534e
--- /dev/null
+++ b/modules/audio_device/qnx/audio_device_alsa_snd_qnx.cc
@@ -0,0 +1,1963 @@
+/*
+ *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_device/qnx/audio_device_alsa_snd_qnx.h"
+
+#include <fstream>
+#include <iostream>
+
+#include "modules/audio_device/audio_device_config.h"
+#include "rtc_base/logging.h"
+#include "rtc_base/system/arch.h"
+#include "system_wrappers/include/sleep.h"
+
+WebRTCAlsaSymbolTable* GetAlsaSymbolTable() {
+  static WebRTCAlsaSymbolTable* alsa_symbol_table = new WebRTCAlsaSymbolTable();
+  return alsa_symbol_table;
+}
+
+// Accesses ALSA functions through our late-binding symbol table instead of
+// directly. This way we don't have to link to libasound, which means our binary
+// will work on systems that don't have it.
+#define LATE(sym) \
+  LATESYM_GET(webrtc::adm_qnx_alsa::AlsaSymbolTable, GetAlsaSymbolTable(), sym)
+
+// Redefine these here to be able to do late-binding
+#undef snd_ctl_card_info_alloca
+#define snd_ctl_card_info_alloca(ptr)                  \
+  do {                                                 \
+    *ptr = (snd_ctl_card_info_t*)__builtin_alloca(     \
+        LATE(snd_ctl_card_info_sizeof)());             \
+    memset(*ptr, 0, LATE(snd_ctl_card_info_sizeof)()); \
+  } while (0)
+
+#undef snd_pcm_info_alloca
+#define snd_pcm_info_alloca(pInfo)                                           \
+  do {                                                                       \
+    *pInfo = (snd_pcm_info_t*)__builtin_alloca(LATE(snd_pcm_info_sizeof)()); \
+    memset(*pInfo, 0, LATE(snd_pcm_info_sizeof)());                          \
+  } while (0)
+
+#undef snd_pcm_status_alloca
+#define snd_pcm_status_alloca(pStatus)                                      \
+  do {                                                                      \
+    *pStatus =                                                              \
+        (snd_pcm_status_t*)__builtin_alloca(LATE(snd_pcm_status_sizeof)()); \
+    memset(*pStatus, 0, LATE(snd_pcm_status_sizeof)());                     \
+  } while (0)
+
+#undef snd_pcm_hw_params_alloca
+#define snd_pcm_hw_params_alloca(pParams)                                      \
+  do {                                                                      \
+    *pParams =                                                              \
+        (snd_pcm_hw_params_t*)__builtin_alloca(LATE(snd_pcm_hw_params_sizeof)()); \
+    memset(*pParams, 0, LATE(snd_pcm_hw_params_sizeof)());                     \
+  } while (0)
+
+#undef snd_pcm_sw_params_alloca
+#define snd_pcm_sw_params_alloca(pParams)                                      \
+  do {                                                                      \
+    *pParams =                                                              \
+        (snd_pcm_sw_params_t*)__builtin_alloca(LATE(snd_pcm_sw_params_sizeof)()); \
+    memset(*pParams, 0, LATE(snd_pcm_sw_params_sizeof)());                     \
+  } while (0)
+
+// snd_lib_error_handler_t
+void WebrtcAlsaErrorHandler(const char* file,
+                            int line,
+                            const char* function,
+                            int err,
+                            const char* fmt,
+                            ...) {}
+
+namespace webrtc {
+namespace {
+constexpr char palyout_pcm_config_path[] = "/etc/webrtc/playout_pcm.cfg";
+constexpr char capture_pcm_config_path[] = "/etc/webrtc/capture_pcm.cfg";
+
+constexpr uint8_t CHAR_BASE = 48;
+
+std::unique_ptr<char[]> valueFromEnv(const char* name) {
+  char* value = getenv(name);
+  if (!value)
+    return std::unique_ptr<char[]>{};
+  std::string raw(value);
+  size_t pos = raw.find(':');
+  if (pos == std::string::npos)
+    return std::unique_ptr<char[]>{};
+  int card = std::atoi(raw.substr(0, pos).data());
+  int device = std::atoi(raw.substr(pos + 1).data());
+  int plugin(0);
+  pos = raw.find(':', ++pos);
+  if (pos != std::string::npos)
+    plugin = std::atoi(raw.substr(pos + 1).data());
+  std::unique_ptr<char[]> buf(new char[4]);
+  buf[0] = (char)(card + CHAR_BASE);
+  buf[1] = (char)(device + CHAR_BASE);
+  buf[2] = (char)(plugin + CHAR_BASE);
+  buf[3] = '\0';
+  return std::move(buf);
+}
+
+const char* targetedPlayDev() {
+  static std::unique_ptr<char[]> playout =
+      valueFromEnv("WEBRTC_AUDIO_PLAY_DEVICE");
+  return playout.get();
+}
+
+const char* targetedRecordDev() {
+  static std::unique_ptr<char[]> record =
+      valueFromEnv("WEBRTC_AUDIO_RECORD_DEVICE");
+  return record.get();
+}
+}  // namespace
+static const unsigned int ALSA_PLAYOUT_FREQ = 48000;
+static const unsigned int ALSA_PLAYOUT_CH = 2;
+static const unsigned int ALSA_PLAYOUT_LATENCY = 40 * 1000;  // in us
+static const unsigned int ALSA_CAPTURE_FREQ = 48000;
+static const unsigned int ALSA_CAPTURE_CH = 2;
+static const unsigned int ALSA_CAPTURE_LATENCY = 40 * 1000;  // in us
+static const unsigned int ALSA_CAPTURE_WAIT_TIMEOUT = 5;     // in ms
+
+#define FUNC_GET_NUM_OF_DEVICE 0
+#define FUNC_GET_DEVICE_NAME 1
+#define FUNC_GET_DEVICE_NAME_FOR_AN_ENUM 2
+
+static std::map<const std::string, AudioDeviceQnxALSA::PcmPara> s_pcm_params = {
+    {"card", AudioDeviceQnxALSA::SND_CARD},
+    {"device", AudioDeviceQnxALSA::SND_DEVICE},
+    {"plugin", AudioDeviceQnxALSA::SND_PLUGIN},
+    {"format", AudioDeviceQnxALSA::SND_FORMAT},
+    {"rate", AudioDeviceQnxALSA::SND_RATE},
+    {"channels", AudioDeviceQnxALSA::SND_CHANNELS},
+    {"period", AudioDeviceQnxALSA::SND_PERIOD},
+    {"buffer", AudioDeviceQnxALSA::SND_BUFFER}};
+
+template <bool PLAY>
+AudioDeviceQnxALSA::PcmPreferences<PLAY>::PcmPreferences(uint32_t rate,
+                                                   uint8_t channels)
+    : _card(-1),
+      _device(-1),
+      _plugin(false),
+#if defined(WEBRTC_ARCH_BIG_ENDIAN)
+      _format(SND_PCM_FORMAT_S16_BE),
+#else
+      _format(SND_PCM_FORMAT_S16_LE),
+#endif
+      _rate(rate),
+      _channels(channels) {
+}
+
+template <bool PLAY>
+void AudioDeviceQnxALSA::PcmPreferences<PLAY>::Initialize(const char* path,
+                                                    const char* env) {
+  _period = _rate / 100;
+  _buffer = CalculateBuffer(_period);
+
+  std::ifstream file(path);
+
+  if (file.is_open()) {
+    std::string fileContent((std::istreambuf_iterator<char>(file)),
+                            std::istreambuf_iterator<char>());
+    file.close();
+    ParsePcmConfig(fileContent);
+  }
+
+  if (env) {
+    _card = env[0] - CHAR_BASE;
+    _device = env[1] - CHAR_BASE;
+    _plugin = env[2] - CHAR_BASE;
+  }
+}
+
+template <bool PLAY>
+void AudioDeviceQnxALSA::PcmPreferences<PLAY>::ParsePcmConfig(
+    const std::string& config) {
+  if (config.empty())
+    return;
+  size_t begin_of_line = 0;
+  size_t end_of_line = config.find('\n', begin_of_line);
+  size_t pos_token = config.find('=', begin_of_line);
+  size_t begin;
+  size_t end;
+  std::string name;
+  std::string value;
+  int paras_mask(0);
+  while (end_of_line != std::string::npos && pos_token != std::string::npos) {
+    name = config.substr(begin_of_line, pos_token - begin_of_line);
+    begin = name.find_first_not_of(' ');
+    end = name.find_last_not_of(' ');
+    name = name.substr(begin, end - begin + 1);
+    // std::cout << "yodai " << name << std::endl;
+    if (auto it{s_pcm_params.find(name)}; it != std::end(s_pcm_params)) {
+      value = config.substr(pos_token + 1, end_of_line - pos_token - 1);
+      begin = value.find_first_not_of(' ');
+      end = value.find_last_not_of(' ');
+      value = value.substr(begin, end - begin + 1);
+      paras_mask |= it->second;
+      UpdatePcmPara(it->second, std::stoi(value));
+    }
+    begin_of_line = end_of_line + 1;
+    end_of_line = config.find('\n', begin_of_line);
+    pos_token = config.find('=', begin_of_line);
+  }
+  if ((paras_mask & SND_RATE) && !(paras_mask & SND_PERIOD))
+    UpdatePcmPara(SND_PERIOD, rate() / 100);
+  if (((paras_mask & SND_RATE) || (paras_mask & SND_PERIOD)) &&
+      !(paras_mask & SND_BUFFER))
+    UpdatePcmPara(SND_BUFFER, period() * 2);
+}
+
+template <bool PLAY>
+void AudioDeviceQnxALSA::PcmPreferences<PLAY>::UpdatePcmPara(PcmPara id, int value) {
+  switch (id) {
+    case SND_CARD:
+      _card = value;
+      break;
+    case SND_DEVICE:
+      _device = value;
+      break;
+    case SND_PLUGIN:
+      _plugin = value;
+      break;
+    case SND_FORMAT:
+      _format = static_cast<snd_pcm_format_t>(value);
+      break;
+    case SND_RATE:
+      _rate = value;
+      break;
+    case SND_CHANNELS:
+      _channels = value;
+      break;
+    case SND_PERIOD:
+      _period = value;
+      break;
+    case SND_BUFFER:
+      _buffer = value;
+      break;
+    default:
+      RTC_DCHECK_NOTREACHED();
+  }
+}
+
+template <>
+snd_pcm_uframes_t AudioDeviceQnxALSA::PcmPreferences<true>::CalculateBuffer(
+    snd_pcm_uframes_t perod) {
+  return 3 * perod;
+}
+
+template <>
+snd_pcm_uframes_t AudioDeviceQnxALSA::PcmPreferences<false>::CalculateBuffer(
+    snd_pcm_uframes_t perod) {
+  return 2 * perod;
+}
+
+AudioDeviceQnxALSA::AudioDeviceQnxALSA()
+    : _ptrAudioBuffer(NULL),
+      _inputDeviceIndex(0),
+      _outputDeviceIndex(0),
+      _inputDeviceIsSpecified(false),
+      _outputDeviceIsSpecified(false),
+      _handleRecord(NULL),
+      _handlePlayout(NULL),
+      _recordingBuffersizeInFrame(0),
+      _recordingPeriodSizeInFrame(0),
+      _playoutBufferSizeInFrame(0),
+      _playoutPeriodSizeInFrame(0),
+      _recordingBufferSizeIn10MS(0),
+      _playoutBufferSizeIn10MS(0),
+      _recordingFramesIn10MS(0),
+      _playoutFramesIn10MS(0),
+      _recordingFreq(ALSA_CAPTURE_FREQ),
+      _playoutFreq(ALSA_PLAYOUT_FREQ),
+      _recChannels(ALSA_CAPTURE_CH),
+      _playChannels(ALSA_PLAYOUT_CH),
+      _recordingBuffer(NULL),
+      _playoutBuffer(NULL),
+      _recordingFramesLeft(0),
+      _playoutFramesLeft(0),
+      _initialized(false),
+      _recording(false),
+      _playing(false),
+      _recIsInitialized(false),
+      _playIsInitialized(false),
+      _recordingDelay(0),
+      _playoutDelay(0) {
+  memset(_oldKeyState, 0, sizeof(_oldKeyState));
+  _playout_prefs.reset(new PcmPreferences<true>(ALSA_PLAYOUT_FREQ, ALSA_PLAYOUT_CH));
+  _capture_prefs.reset(new PcmPreferences<false>(ALSA_CAPTURE_FREQ, ALSA_CAPTURE_CH));
+  _playout_prefs->Initialize(palyout_pcm_config_path, targetedPlayDev());
+  _capture_prefs->Initialize(capture_pcm_config_path, targetedRecordDev());
+  RTC_DLOG(LS_INFO) << __FUNCTION__ << " created";
+}
+
+// ----------------------------------------------------------------------------
+//  AudioDeviceQnxALSA - dtor
+// ----------------------------------------------------------------------------
+
+AudioDeviceQnxALSA::~AudioDeviceQnxALSA() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__ << " destroyed";
+
+  Terminate();
+
+  // Clean up the recording buffer and playout buffer.
+  if (_recordingBuffer) {
+    delete[] _recordingBuffer;
+    _recordingBuffer = NULL;
+  }
+  if (_playoutBuffer) {
+    delete[] _playoutBuffer;
+    _playoutBuffer = NULL;
+  }
+}
+
+void AudioDeviceQnxALSA::AttachAudioBuffer(AudioDeviceBuffer* audioBuffer) {
+  MutexLock lock(&mutex_);
+
+  _ptrAudioBuffer = audioBuffer;
+
+  // Inform the AudioBuffer about default settings for this implementation.
+  // Set all values to zero here since the actual settings will be done by
+  // InitPlayout and InitRecording later.
+  _ptrAudioBuffer->SetRecordingSampleRate(0);
+  _ptrAudioBuffer->SetPlayoutSampleRate(0);
+  _ptrAudioBuffer->SetRecordingChannels(0);
+  _ptrAudioBuffer->SetPlayoutChannels(0);
+}
+
+int32_t AudioDeviceQnxALSA::ActiveAudioLayer(
+    AudioDeviceModule::AudioLayer& audioLayer) const {
+  audioLayer = AudioDeviceModule::kPlatformDefaultAudio;
+  return 0;
+}
+
+AudioDeviceGeneric::InitStatus AudioDeviceQnxALSA::Init() {
+  MutexLock lock(&mutex_);
+
+  // Load libasound
+  if (!GetAlsaSymbolTable()->Load()) {
+    // Alsa is not installed on this system
+    RTC_LOG(LS_ERROR) << "failed to load symbol table";
+    return InitStatus::OTHER_ERROR;
+  }
+
+  if (_initialized) {
+    return InitStatus::OK;
+  }
+
+  _initialized = true;
+
+  return InitStatus::OK;
+}
+
+int32_t AudioDeviceQnxALSA::Terminate() {
+  if (!_initialized) {
+    return 0;
+  }
+
+  MutexLock lock(&mutex_);
+
+  _mixerManager.Close();
+
+  // RECORDING
+  mutex_.Unlock();
+  _ptrThreadRec.Finalize();
+
+  // PLAYOUT
+  _ptrThreadPlay.Finalize();
+  mutex_.Lock();
+
+  _initialized = false;
+  _outputDeviceIsSpecified = false;
+  _inputDeviceIsSpecified = false;
+
+  return 0;
+}
+
+bool AudioDeviceQnxALSA::Initialized() const {
+  return (_initialized);
+}
+
+int32_t AudioDeviceQnxALSA::InitSpeaker() {
+  MutexLock lock(&mutex_);
+  return InitSpeakerLocked();
+}
+
+int32_t AudioDeviceQnxALSA::InitSpeakerLocked() {
+  if (_playing) {
+    return -1;
+  }
+
+  char devName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(2, true, _outputDeviceIndex, devName, kAdmMaxDeviceNameSize);
+  return _mixerManager.OpenSpeaker(devName);
+}
+
+int32_t AudioDeviceQnxALSA::InitMicrophone() {
+  MutexLock lock(&mutex_);
+  return InitMicrophoneLocked();
+}
+
+int32_t AudioDeviceQnxALSA::InitMicrophoneLocked() {
+  if (_recording) {
+    return -1;
+  }
+
+  char devName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(2, false, _inputDeviceIndex, devName, kAdmMaxDeviceNameSize);
+  return _mixerManager.OpenMicrophone(devName);
+}
+
+bool AudioDeviceQnxALSA::SpeakerIsInitialized() const {
+  return (_mixerManager.SpeakerIsInitialized());
+}
+
+bool AudioDeviceQnxALSA::MicrophoneIsInitialized() const {
+  return (_mixerManager.MicrophoneIsInitialized());
+}
+
+int32_t AudioDeviceQnxALSA::SpeakerVolumeIsAvailable(bool& available) {
+  bool wasInitialized = _mixerManager.SpeakerIsInitialized();
+
+  // Make an attempt to open up the
+  // output mixer corresponding to the currently selected output device.
+  if (!wasInitialized && InitSpeaker() == -1) {
+    // If we end up here it means that the selected speaker has no volume
+    // control.
+    available = false;
+    return 0;
+  }
+
+  // Given that InitSpeaker was successful, we know that a volume control
+  // exists
+  available = true;
+
+  // Close the initialized output mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseSpeaker();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetSpeakerVolume(uint32_t volume) {
+  return (_mixerManager.SetSpeakerVolume(volume));
+}
+
+int32_t AudioDeviceQnxALSA::SpeakerVolume(uint32_t& volume) const {
+  uint32_t level(0);
+
+  if (_mixerManager.SpeakerVolume(level) == -1) {
+    return -1;
+  }
+
+  volume = level;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MaxSpeakerVolume(uint32_t& maxVolume) const {
+  uint32_t maxVol(0);
+
+  if (_mixerManager.MaxSpeakerVolume(maxVol) == -1) {
+    return -1;
+  }
+
+  maxVolume = maxVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MinSpeakerVolume(uint32_t& minVolume) const {
+  uint32_t minVol(0);
+
+  if (_mixerManager.MinSpeakerVolume(minVol) == -1) {
+    return -1;
+  }
+
+  minVolume = minVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SpeakerMuteIsAvailable(bool& available) {
+  bool isAvailable(false);
+  bool wasInitialized = _mixerManager.SpeakerIsInitialized();
+
+  // Make an attempt to open up the
+  // output mixer corresponding to the currently selected output device.
+  //
+  if (!wasInitialized && InitSpeaker() == -1) {
+    // If we end up here it means that the selected speaker has no volume
+    // control, hence it is safe to state that there is no mute control
+    // already at this stage.
+    available = false;
+    return 0;
+  }
+
+  // Check if the selected speaker has a mute control
+  _mixerManager.SpeakerMuteIsAvailable(isAvailable);
+
+  available = isAvailable;
+
+  // Close the initialized output mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseSpeaker();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetSpeakerMute(bool enable) {
+  return (_mixerManager.SetSpeakerMute(enable));
+}
+
+int32_t AudioDeviceQnxALSA::SpeakerMute(bool& enabled) const {
+  bool muted(0);
+
+  if (_mixerManager.SpeakerMute(muted) == -1) {
+    return -1;
+  }
+
+  enabled = muted;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MicrophoneMuteIsAvailable(bool& available) {
+  bool isAvailable(false);
+  bool wasInitialized = _mixerManager.MicrophoneIsInitialized();
+
+  // Make an attempt to open up the
+  // input mixer corresponding to the currently selected input device.
+  //
+  if (!wasInitialized && InitMicrophone() == -1) {
+    // If we end up here it means that the selected microphone has no volume
+    // control, hence it is safe to state that there is no mute control
+    // already at this stage.
+    available = false;
+    return 0;
+  }
+
+  // Check if the selected microphone has a mute control
+  //
+  _mixerManager.MicrophoneMuteIsAvailable(isAvailable);
+  available = isAvailable;
+
+  // Close the initialized input mixer
+  //
+  if (!wasInitialized) {
+    _mixerManager.CloseMicrophone();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetMicrophoneMute(bool enable) {
+  return (_mixerManager.SetMicrophoneMute(enable));
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneMute
+// ----------------------------------------------------------------------------
+
+int32_t AudioDeviceQnxALSA::MicrophoneMute(bool& enabled) const {
+  bool muted(0);
+
+  if (_mixerManager.MicrophoneMute(muted) == -1) {
+    return -1;
+  }
+
+  enabled = muted;
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StereoRecordingIsAvailable(bool& available) {
+  MutexLock lock(&mutex_);
+
+  // If we already have initialized in stereo it's obviously available
+  if (_recIsInitialized && (2 == _recChannels)) {
+    available = true;
+    return 0;
+  }
+
+  // Save rec states and the number of rec channels
+  bool recIsInitialized = _recIsInitialized;
+  bool recording = _recording;
+  int recChannels = _recChannels;
+
+  available = false;
+
+  // Stop/uninitialize recording if initialized (and possibly started)
+  if (_recIsInitialized) {
+    StopRecordingLocked();
+  }
+
+  // Try init in stereo;
+  _recChannels = 2;
+  if (InitRecordingLocked() == 0) {
+    available = true;
+  }
+
+  // Stop/uninitialize recording
+  StopRecordingLocked();
+
+  // Recover previous states
+  _recChannels = recChannels;
+  if (recIsInitialized) {
+    InitRecordingLocked();
+  }
+  if (recording) {
+    StartRecording();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetStereoRecording(bool enable) {
+  if (enable)
+    _recChannels = 2;
+  else
+    _recChannels = 1;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StereoRecording(bool& enabled) const {
+  if (_recChannels == 2)
+    enabled = true;
+  else
+    enabled = false;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StereoPlayoutIsAvailable(bool& available) {
+  MutexLock lock(&mutex_);
+  // If we already have initialized in stereo it's obviously available
+  if (_playIsInitialized && (2 == _playChannels)) {
+    available = true;
+    return 0;
+  }
+
+  // Save rec states and the number of rec channels
+  bool playIsInitialized = _playIsInitialized;
+  bool playing = _playing;
+  int playChannels = _playChannels;
+
+  available = false;
+
+  // Stop/uninitialize recording if initialized (and possibly started)
+  if (_playIsInitialized) {
+    StopPlayoutLocked();
+  }
+
+  // Try init in stereo;
+  _playChannels = 2;
+  if (InitPlayoutLocked() == 0) {
+    available = true;
+  }
+
+  // Stop/uninitialize recording
+  StopPlayoutLocked();
+
+  // Recover previous states
+  _playChannels = playChannels;
+  if (playIsInitialized) {
+    InitPlayoutLocked();
+  }
+  if (playing) {
+    StartPlayout();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetStereoPlayout(bool enable) {
+  if (enable)
+    _playChannels = 2;
+  else
+    _playChannels = 1;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StereoPlayout(bool& enabled) const {
+  if (_playChannels == 2)
+    enabled = true;
+  else
+    enabled = false;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MicrophoneVolumeIsAvailable(bool& available) {
+  bool wasInitialized = _mixerManager.MicrophoneIsInitialized();
+
+  // Make an attempt to open up the
+  // input mixer corresponding to the currently selected output device.
+  if (!wasInitialized && InitMicrophone() == -1) {
+    // If we end up here it means that the selected microphone has no volume
+    // control.
+    available = false;
+    return 0;
+  }
+
+  // Given that InitMicrophone was successful, we know that a volume control
+  // exists
+  available = true;
+
+  // Close the initialized input mixer
+  if (!wasInitialized) {
+    _mixerManager.CloseMicrophone();
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetMicrophoneVolume(uint32_t volume) {
+  return (_mixerManager.SetMicrophoneVolume(volume));
+}
+
+int32_t AudioDeviceQnxALSA::MicrophoneVolume(uint32_t& volume) const {
+  uint32_t level(0);
+
+  if (_mixerManager.MicrophoneVolume(level) == -1) {
+    RTC_LOG(LS_WARNING) << "failed to retrive current microphone level";
+    return -1;
+  }
+
+  volume = level;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MaxMicrophoneVolume(uint32_t& maxVolume) const {
+  uint32_t maxVol(0);
+
+  if (_mixerManager.MaxMicrophoneVolume(maxVol) == -1) {
+    return -1;
+  }
+
+  maxVolume = maxVol;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::MinMicrophoneVolume(uint32_t& minVolume) const {
+  uint32_t minVol(0);
+
+  if (_mixerManager.MinMicrophoneVolume(minVol) == -1) {
+    return -1;
+  }
+
+  minVolume = minVol;
+
+  return 0;
+}
+
+int16_t AudioDeviceQnxALSA::PlayoutDevices() {
+  return (int16_t)GetDevicesInfo(0, true);
+}
+
+int32_t AudioDeviceQnxALSA::SetPlayoutDevice(uint16_t index) {
+  if (_playIsInitialized) {
+    return -1;
+  }
+
+  uint32_t nDevices = GetDevicesInfo(0, true);
+  RTC_LOG(LS_VERBOSE) << "number of available audio output devices is "
+                      << nDevices;
+
+  if (index > (nDevices - 1)) {
+    RTC_LOG(LS_ERROR) << "device index is out of range [0," << (nDevices - 1)
+                      << "]";
+    return -1;
+  }
+
+  _outputDeviceIndex = index;
+  _outputDeviceIsSpecified = true;
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::SetPlayoutDevice(
+    AudioDeviceModule::WindowsDeviceType /*device*/) {
+  RTC_LOG(LS_ERROR) << "WindowsDeviceType not supported";
+  return -1;
+}
+
+int32_t AudioDeviceQnxALSA::PlayoutDeviceName(uint16_t index,
+                                              char name[kAdmMaxDeviceNameSize],
+                                              char guid[kAdmMaxGuidSize]) {
+  const uint16_t nDevices(PlayoutDevices());
+
+  if ((index > (nDevices - 1)) || (name == NULL)) {
+    return -1;
+  }
+
+  memset(name, 0, kAdmMaxDeviceNameSize);
+
+  if (guid != NULL) {
+    memset(guid, 0, kAdmMaxGuidSize);
+  }
+
+  return GetDevicesInfo(1, true, index, name, kAdmMaxDeviceNameSize);
+}
+
+int32_t AudioDeviceQnxALSA::RecordingDeviceName(
+    uint16_t index,
+    char name[kAdmMaxDeviceNameSize],
+    char guid[kAdmMaxGuidSize]) {
+  const uint16_t nDevices(RecordingDevices());
+
+  if ((index > (nDevices - 1)) || (name == NULL)) {
+    return -1;
+  }
+
+  memset(name, 0, kAdmMaxDeviceNameSize);
+
+  if (guid != NULL) {
+    memset(guid, 0, kAdmMaxGuidSize);
+  }
+
+  return GetDevicesInfo(1, false, index, name, kAdmMaxDeviceNameSize);
+}
+
+int16_t AudioDeviceQnxALSA::RecordingDevices() {
+  return (int16_t)GetDevicesInfo(0, false);
+}
+
+int32_t AudioDeviceQnxALSA::SetRecordingDevice(uint16_t index) {
+  if (_recIsInitialized) {
+    return -1;
+  }
+
+  uint32_t nDevices = GetDevicesInfo(0, false);
+  RTC_LOG(LS_VERBOSE) << "number of availiable audio input devices is "
+                      << nDevices;
+
+  if (index > (nDevices - 1)) {
+    RTC_LOG(LS_ERROR) << "device index is out of range [0," << (nDevices - 1)
+                      << "]";
+    return -1;
+  }
+
+  _inputDeviceIndex = index;
+  _inputDeviceIsSpecified = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingDevice II (II)
+// ----------------------------------------------------------------------------
+
+int32_t AudioDeviceQnxALSA::SetRecordingDevice(
+    AudioDeviceModule::WindowsDeviceType /*device*/) {
+  RTC_LOG(LS_ERROR) << "WindowsDeviceType not supported";
+  return -1;
+}
+
+int32_t AudioDeviceQnxALSA::PlayoutIsAvailable(bool& available) {
+  available = false;
+
+  auto tryout = [&available, this](uint8_t channels) {
+    uint8_t old_channels = _playChannels;
+    _playChannels = channels;
+    int32_t res = InitPlayout();
+    StopPlayout();
+    if (res)
+      _playChannels = old_channels;
+    else
+      available = true;
+    return res;
+  };
+
+  uint8_t ch_num[] = {2, 1, _playout_prefs->channels()};
+  uint8_t count(3);
+  int32_t res(-1);
+  while (count && res) {
+    res = tryout(ch_num[--count]);
+  }
+
+  return res;
+}
+
+int32_t AudioDeviceQnxALSA::RecordingIsAvailable(bool& available) {
+  available = false;
+
+  auto tryout = [&available, this](uint8_t channels) {
+    uint8_t old_channels = _recChannels;
+    _recChannels = channels;
+    int32_t res = InitPlayout();
+    StopPlayout();
+    if (res)
+      _recChannels = old_channels;
+    else
+      available = true;
+    return res;
+  };
+
+  uint8_t ch_num[] = {2, 1, _capture_prefs->channels()};
+  uint8_t count(3);
+  int32_t res(-1);
+  while (count && res) {
+    res = tryout(ch_num[++count]);
+  }
+
+  return res;
+}
+
+int32_t AudioDeviceQnxALSA::InitPlayout() {
+  MutexLock lock(&mutex_);
+  return InitPlayoutLocked();
+}
+
+int32_t AudioDeviceQnxALSA::InitPlayoutLocked() {
+  int errVal = 0;
+
+  if (_playing) {
+    return -1;
+  }
+
+  if (!_outputDeviceIsSpecified) {
+    return -1;
+  }
+
+  if (_playIsInitialized) {
+    return 0;
+  }
+  // Initialize the speaker (devices might have been added or removed)
+  if (InitSpeakerLocked() == -1) {
+    RTC_LOG(LS_WARNING) << "InitSpeaker() failed";
+  }
+
+  // Start by closing any existing wave-output devices
+  //
+  if (_handlePlayout != NULL) {
+    LATE(snd_pcm_close)(_handlePlayout);
+    _handlePlayout = NULL;
+    _playIsInitialized = false;
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error closing current playout sound device, error: "
+                        << LATE(snd_strerror)(errVal);
+    }
+  }
+
+  // Open PCM device for playout
+  char deviceName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(2, true, _outputDeviceIndex, deviceName,
+                 kAdmMaxDeviceNameSize);
+
+  RTC_LOG(LS_VERBOSE) << "InitPlayout open (" << deviceName << ")";
+
+  errVal = LATE(snd_pcm_open)(&_handlePlayout, deviceName,
+                              SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK);
+
+  if (errVal == -EBUSY)  // Device busy - try some more!
+  {
+    for (int i = 0; i < 5; i++) {
+      SleepMs(1000);
+      errVal = LATE(snd_pcm_open)(&_handlePlayout, deviceName,
+                                  SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK);
+      if (errVal == 0) {
+        break;
+      }
+    }
+  }
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "unable to open playback device: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    _handlePlayout = NULL;
+    return -1;
+  }
+
+  _playoutFramesIn10MS = _playout_prefs->rate() / 100;
+  snd_pcm_uframes_t period_size = _playout_prefs->period();
+  snd_pcm_uframes_t buffer_size = _playout_prefs->buffer();
+  if (!SetParams(_handlePlayout, true, _playout_prefs->format(),
+                 _playout_prefs->rate(), _playout_prefs->channels(),
+                 period_size, buffer_size)) {
+    _playoutFramesIn10MS = 0;
+    RTC_LOG(LS_ERROR) << "unable to set playback device: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    ErrorRecovery(errVal, _handlePlayout);
+    errVal = LATE(snd_pcm_close)(_handlePlayout);
+    _handlePlayout = NULL;
+    return -1;
+  }
+  _playoutBufferSizeInFrame = buffer_size;
+  _playoutPeriodSizeInFrame = period_size;
+  _playoutFreq = _playout_prefs->rate();
+  _playChannels = _playout_prefs->channels();
+
+  if (_ptrAudioBuffer) {
+    // Update webrtc audio buffer with the selected parameters
+    _ptrAudioBuffer->SetPlayoutSampleRate(_playoutFreq);
+    _ptrAudioBuffer->SetPlayoutChannels(_playChannels);
+  }
+
+  // Set play buffer size
+  _playoutBufferSizeIn10MS =
+      LATE(snd_pcm_frames_to_bytes)(_handlePlayout, _playoutFramesIn10MS);
+
+  // Init varaibles used for play
+
+  if (_handlePlayout != NULL) {
+    _playIsInitialized = true;
+    return 0;
+  } else {
+    return -1;
+  }
+}
+
+int32_t AudioDeviceQnxALSA::InitRecording() {
+  MutexLock lock(&mutex_);
+  return InitRecordingLocked();
+}
+
+int32_t AudioDeviceQnxALSA::InitRecordingLocked() {
+  int errVal = 0;
+
+  if (_recording) {
+    return -1;
+  }
+
+  if (!_inputDeviceIsSpecified) {
+    return -1;
+  }
+
+  if (_recIsInitialized) {
+    return 0;
+  }
+
+  // Initialize the microphone (devices might have been added or removed)
+  if (InitMicrophoneLocked() == -1) {
+    RTC_LOG(LS_WARNING) << "InitMicrophone() failed";
+  }
+
+  // Start by closing any existing pcm-input devices
+  //
+  if (_handleRecord != NULL) {
+    int errVal = LATE(snd_pcm_close)(_handleRecord);
+    _handleRecord = NULL;
+    _recIsInitialized = false;
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR)
+          << "Error closing current recording sound device, error: "
+          << LATE(snd_strerror)(errVal);
+    }
+  }
+
+  // Open PCM device for recording
+  // The corresponding settings for playout are made after the record settings
+  char deviceName[kAdmMaxDeviceNameSize] = {0};
+  GetDevicesInfo(2, false, _inputDeviceIndex, deviceName,
+                 kAdmMaxDeviceNameSize);
+
+  RTC_LOG(LS_VERBOSE) << "InitRecording open (" << deviceName << ")";
+  errVal = LATE(snd_pcm_open)(&_handleRecord, deviceName,
+                              SND_PCM_STREAM_CAPTURE, SND_PCM_NONBLOCK);
+
+  // Available modes: 0 = blocking, SND_PCM_NONBLOCK, SND_PCM_ASYNC
+  if (errVal == -EBUSY)  // Device busy - try some more!
+  {
+    for (int i = 0; i < 5; i++) {
+      SleepMs(1000);
+      errVal = LATE(snd_pcm_open)(&_handleRecord, deviceName,
+                                  SND_PCM_STREAM_CAPTURE, SND_PCM_NONBLOCK);
+      if (errVal == 0) {
+        break;
+      }
+    }
+  }
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "unable to open record device: "
+                      << LATE(snd_strerror)(errVal);
+    _handleRecord = NULL;
+    return -1;
+  }
+
+  _recordingFramesIn10MS = _capture_prefs->rate() / 100;
+  snd_pcm_uframes_t period_size = _capture_prefs->period();
+  snd_pcm_uframes_t buffer_size = _capture_prefs->buffer();
+  if (!SetParams(_handleRecord, false, _capture_prefs->format(),
+                 _capture_prefs->rate(), _capture_prefs->channels(),
+                 period_size, buffer_size)) {
+    _recordingFramesIn10MS = 0;
+    RTC_LOG(LS_ERROR) << "unable to set record settings: "
+                      << LATE(snd_strerror)(errVal) << " (" << errVal << ")";
+    ErrorRecovery(errVal, _handleRecord);
+    errVal = LATE(snd_pcm_close)(_handleRecord);
+    _handleRecord = NULL;
+    return -1;
+  }
+  _recordingBuffersizeInFrame = buffer_size;
+  _recordingPeriodSizeInFrame = period_size;
+  _recordingFreq = _capture_prefs->rate();
+  _recChannels = _capture_prefs->channels();
+
+  if (_ptrAudioBuffer) {
+    // Update webrtc audio buffer with the selected parameters
+    _ptrAudioBuffer->SetRecordingSampleRate(_recordingFreq);
+    _ptrAudioBuffer->SetRecordingChannels(_recChannels);
+  }
+
+  // Set rec buffer size and create buffer
+  _recordingBufferSizeIn10MS =
+      LATE(snd_pcm_frames_to_bytes)(_handleRecord, _recordingFramesIn10MS);
+
+  if (_handleRecord != NULL) {
+    // Mark recording side as initialized
+    _recIsInitialized = true;
+    return 0;
+  } else {
+    return -1;
+  }
+}
+
+int32_t AudioDeviceQnxALSA::StartRecording() {
+  if (!_recIsInitialized) {
+    return -1;
+  }
+
+  if (_recording) {
+    return 0;
+  }
+
+  _recording = true;
+
+  int errVal = 0;
+  _recordingFramesLeft = _recordingFramesIn10MS;
+
+  // Make sure we only create the buffer once.
+  if (!_recordingBuffer)
+    _recordingBuffer = new int8_t[_recordingBufferSizeIn10MS];
+  if (!_recordingBuffer) {
+    RTC_LOG(LS_ERROR) << "failed to alloc recording buffer";
+    _recording = false;
+    return -1;
+  }
+
+  for (int i = 0; i < 5; i++) {
+    errVal = LATE(snd_pcm_prepare)(_handleRecord);
+
+    if (errVal == 0 || errVal != -EBUSY) {
+      break;
+    }
+    SleepMs(1000);
+  }
+
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "capture snd_pcm_prepare failed ("
+                      << LATE(snd_strerror)(errVal) << ")\n";
+    return -1;
+  }
+
+  // RECORDING
+  _ptrThreadRec = rtc::PlatformThread::SpawnJoinable(
+      [this] {
+        while (RecThreadProcess()) {
+        }
+      },
+      "webrtc_audio_module_capture_thread",
+      rtc::ThreadAttributes().SetPriority(rtc::ThreadPriority::kRealtime));
+
+  errVal = LATE(snd_pcm_start)(_handleRecord);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "capture snd_pcm_start err: "
+                      << LATE(snd_strerror)(errVal);
+    errVal = LATE(snd_pcm_start)(_handleRecord);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "capture snd_pcm_start 2nd try err: "
+                        << LATE(snd_strerror)(errVal);
+      StopRecording();
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StopRecording() {
+  MutexLock lock(&mutex_);
+  return StopRecordingLocked();
+}
+
+int32_t AudioDeviceQnxALSA::StopRecordingLocked() {
+  if (!_recIsInitialized) {
+    return 0;
+  }
+
+  if (_handleRecord == NULL) {
+    return -1;
+  }
+
+  // Make sure we don't start recording (it's asynchronous).
+  _recIsInitialized = false;
+  _recording = false;
+
+  _ptrThreadRec.Finalize();
+
+  _recordingFramesLeft = 0;
+  if (_recordingBuffer) {
+    delete[] _recordingBuffer;
+    _recordingBuffer = NULL;
+  }
+
+  // Stop and close pcm recording device.
+  int errVal = LATE(snd_pcm_drop)(_handleRecord);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error stop recording: " << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  errVal = LATE(snd_pcm_close)(_handleRecord);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error closing record sound device, error: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  // Check if we have muted and unmute if so.
+  bool muteEnabled = false;
+  MicrophoneMute(muteEnabled);
+  if (muteEnabled) {
+    SetMicrophoneMute(false);
+  }
+
+  // set the pcm input handle to NULL
+  _handleRecord = NULL;
+  return 0;
+}
+
+bool AudioDeviceQnxALSA::RecordingIsInitialized() const {
+  return (_recIsInitialized);
+}
+
+bool AudioDeviceQnxALSA::Recording() const {
+  return (_recording);
+}
+
+bool AudioDeviceQnxALSA::PlayoutIsInitialized() const {
+  return (_playIsInitialized);
+}
+
+int32_t AudioDeviceQnxALSA::StartPlayout() {
+  if (!_playIsInitialized) {
+    return -1;
+  }
+
+  if (_playing) {
+    return 0;
+  }
+
+  _playing = true;
+
+  _playoutFramesLeft = 0;
+  if (!_playoutBuffer)
+    _playoutBuffer = new int8_t[_playoutBufferSizeIn10MS];
+  if (!_playoutBuffer) {
+    RTC_LOG(LS_ERROR) << "failed to alloc playout buf";
+    _playing = false;
+    return -1;
+  }
+
+  int errVal;
+  for (int i = 0; i < 5; i++) {
+    errVal = LATE(snd_pcm_prepare)(_handlePlayout);
+    if (errVal == 0 || errVal != -EBUSY) {
+      break;
+    }
+    SleepMs(1000);
+  }
+
+  // PLAYOUT
+  _ptrThreadPlay = rtc::PlatformThread::SpawnJoinable(
+      [this] {
+        while (PlayThreadProcess()) {
+        }
+      },
+      "webrtc_audio_module_play_thread",
+      rtc::ThreadAttributes().SetPriority(rtc::ThreadPriority::kRealtime));
+
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "playout snd_pcm_prepare failed ("
+                      << LATE(snd_strerror)(errVal) << ")\n";
+    return -1;
+  }
+
+  errVal = LATE(snd_pcm_start)(_handlePlayout);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "playout snd_pcm_start err: "
+                      << LATE(snd_strerror)(errVal);
+    errVal = LATE(snd_pcm_start)(_handlePlayout);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "playout snd_pcm_start 2nd try err: "
+                        << LATE(snd_strerror)(errVal);
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::StopPlayout() {
+  MutexLock lock(&mutex_);
+  return StopPlayoutLocked();
+}
+
+int32_t AudioDeviceQnxALSA::StopPlayoutLocked() {
+  if (!_playIsInitialized) {
+    return 0;
+  }
+
+  if (_handlePlayout == NULL) {
+    return -1;
+  }
+
+  _playing = false;
+
+  // stop playout thread first
+  _ptrThreadPlay.Finalize();
+
+  _playoutFramesLeft = 0;
+  delete[] _playoutBuffer;
+  _playoutBuffer = NULL;
+
+  // stop and close pcm playout device
+  int errVal = LATE(snd_pcm_drop)(_handlePlayout);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error stop playing: " << LATE(snd_strerror)(errVal);
+  }
+
+  errVal = LATE(snd_pcm_close)(_handlePlayout);
+  if (errVal < 0)
+    RTC_LOG(LS_ERROR) << "Error closing playout sound device, error: "
+                      << LATE(snd_strerror)(errVal);
+
+  // set the pcm input handle to NULL
+  _playIsInitialized = false;
+  _handlePlayout = NULL;
+  RTC_LOG(LS_VERBOSE) << "handle_playout is now set to NULL";
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::PlayoutDelay(uint16_t& delayMS) const {
+  delayMS = (uint16_t)_playoutDelay * 1000 / _playoutFreq;
+  return 0;
+}
+
+bool AudioDeviceQnxALSA::Playing() const {
+  return (_playing);
+}
+
+// ============================================================================
+//                                 Private Methods
+// ============================================================================
+
+int32_t AudioDeviceQnxALSA::GetDevicesInfo(const int32_t function,
+                                           const bool playback,
+                                           const int32_t enumDeviceNo,
+                                           char* enumDeviceName,
+                                           const int32_t ednLen) const {
+  // Device enumeration based on libjingle implementation
+  // by Tristan Schmelcher at Google Inc.
+
+  const char* type = playback ? "Output" : "Input";
+  // dmix and dsnoop are only for playback and capture, respectively, but ALSA
+  // stupidly includes them in both lists.
+  const char* ignorePrefix = playback ? "dsnoop:" : "dmix:";
+  // (ALSA lists many more "devices" of questionable interest, but we show them
+  // just in case the weird devices may actually be desirable for some
+  // users/systems.)
+
+  int err;
+  int enumCount(0);
+  bool keepSearching(true);
+
+  int16_t targeted_card =
+      playback ? _playout_prefs->Card() : _capture_prefs->Card();
+  int16_t target_pcm_dev =
+      playback ? _playout_prefs->Device() : _capture_prefs->Device();
+  bool use_plugin =
+      playback ? _playout_prefs->Plugin() : _capture_prefs->Plugin();
+  if (target_pcm_dev > -1) {
+    switch (function) {
+      case FUNC_GET_NUM_OF_DEVICE:
+        return 1;
+      case FUNC_GET_DEVICE_NAME:
+      case FUNC_GET_DEVICE_NAME_FOR_AN_ENUM:
+        if (use_plugin)
+          sprintf(enumDeviceName, "plughw:CARD=%d,DEV=%d", targeted_card,
+                  target_pcm_dev);
+        else
+          sprintf(enumDeviceName, "CARD=%d,DEV=%d", targeted_card,
+                  target_pcm_dev);
+        enumDeviceName[ednLen - 1] = '\0';
+        return 0;
+      default:
+        RTC_CHECK_NOTREACHED();
+    }
+  }
+  int card = -1;
+  while (!(LATE(snd_card_next)(&card)) && (card >= 0) && keepSearching) {
+    if (targeted_card > -1 && card != targeted_card)
+      continue;
+    void** hints;
+    err = LATE(snd_device_name_hint)(card, "pcm", &hints);
+    if (err != 0) {
+      RTC_LOG(LS_ERROR) << "GetDevicesInfo - device name hint error: "
+                        << LATE(snd_strerror)(err);
+      return -1;
+    } else if (!hints) {
+      RTC_LOG(LS_WARNING) << "GetDevicesInfo - there is no hint for CARD "
+                          << card;
+      continue;
+    }
+
+    enumCount++;  // default is 0
+    if ((function == FUNC_GET_DEVICE_NAME ||
+         function == FUNC_GET_DEVICE_NAME_FOR_AN_ENUM) &&
+        enumDeviceNo == 0 && target_pcm_dev == -1) {
+      strcpy(enumDeviceName, "default");
+
+      err = LATE(snd_device_name_free_hint)(hints);
+      if (err != 0) {
+        RTC_LOG(LS_ERROR) << "GetDevicesInfo - device name free hint error: "
+                          << LATE(snd_strerror)(err);
+      }
+
+      return 0;
+    }
+
+    for (void** list = hints; *list != NULL; ++list) {
+      char* actualType = LATE(snd_device_name_get_hint)(*list, "IOID");
+      if (actualType) {  // NULL means it's both.
+        bool wrongType = (strcmp(actualType, type) != 0);
+        free(actualType);
+        if (wrongType) {
+          // Wrong type of device (i.e., input vs. output).
+          continue;
+        }
+      }
+
+      char* name = LATE(snd_device_name_get_hint)(*list, "NAME");
+      if (!name) {
+        RTC_LOG(LS_ERROR) << "Device has no name";
+        // Skip it.
+        continue;
+      }
+
+      if (target_pcm_dev > -1) {
+        if (use_plugin) {
+          if (!strstr(name, "plughw"))
+            continue;
+        }
+        char dev_str[10] = {0};
+        sprintf(dev_str, "%s%d", "DEV=", target_pcm_dev);
+        if (strstr(name, dev_str))
+          keepSearching = false;
+        else
+          continue;
+      }
+
+      // Now check if we actually want to show this device.
+      if (strcmp(name, "default") != 0 && strcmp(name, "null") != 0 &&
+          strcmp(name, "pulse") != 0 &&
+          strncmp(name, ignorePrefix, strlen(ignorePrefix)) != 0) {
+        // Yes, we do.
+        char* desc = LATE(snd_device_name_get_hint)(*list, "DESC");
+        if (!desc) {
+          // Virtual devices don't necessarily have descriptions.
+          // Use their names instead.
+          desc = name;
+        }
+
+        if (FUNC_GET_NUM_OF_DEVICE == function) {
+          RTC_LOG(LS_VERBOSE) << "Enum device " << enumCount << " - " << name;
+        }
+        if ((FUNC_GET_DEVICE_NAME == function) &&
+            (enumDeviceNo == enumCount || target_pcm_dev > -1)) {
+          // We have found the enum device, copy the name to buffer.
+          strncpy(enumDeviceName, desc, ednLen);
+          enumDeviceName[ednLen - 1] = '\0';
+          keepSearching = false;
+          // Replace '\n' with '-'.
+          char* pret = strchr(enumDeviceName, '\n' /*0xa*/);  // LF
+          if (pret)
+            *pret = '-';
+        }
+        if ((FUNC_GET_DEVICE_NAME_FOR_AN_ENUM == function) &&
+            (enumDeviceNo == enumCount || target_pcm_dev > -1)) {
+          // We have found the enum device, copy the name to buffer.
+          strncpy(enumDeviceName, name, ednLen);
+          enumDeviceName[ednLen - 1] = '\0';
+          keepSearching = false;
+        }
+
+        if (keepSearching)
+          ++enumCount;
+
+        if (desc != name)
+          free(desc);
+      }
+
+      free(name);
+
+      if (!keepSearching)
+        break;
+    }
+
+    err = LATE(snd_device_name_free_hint)(hints);
+    if (err != 0) {
+      RTC_LOG(LS_ERROR) << "GetDevicesInfo - device name free hint error: "
+                        << LATE(snd_strerror)(err);
+      // Continue and return true anyway, since we did get the whole list.
+    }
+  }
+
+  if (FUNC_GET_NUM_OF_DEVICE == function) {
+    if (enumCount == 1 && target_pcm_dev == -1)  // only default?
+      enumCount = 0;
+    return enumCount;  // Normal return point for function 0
+  }
+
+  if (keepSearching) {
+    // If we get here for function 1 and 2, we didn't find the specified
+    // enum device.
+    RTC_LOG(LS_ERROR)
+        << "GetDevicesInfo - Could not find device name or numbers";
+    return -1;
+  }
+
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::InputSanityCheckAfterUnlockedPeriod() const {
+  if (_handleRecord == NULL) {
+    RTC_LOG(LS_ERROR) << "input state has been modified during unlocked period";
+    return -1;
+  }
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::OutputSanityCheckAfterUnlockedPeriod() const {
+  if (_handlePlayout == NULL) {
+    RTC_LOG(LS_ERROR)
+        << "output state has been modified during unlocked period";
+    return -1;
+  }
+  return 0;
+}
+
+int32_t AudioDeviceQnxALSA::ErrorRecovery(int32_t error,
+                                          snd_pcm_t* deviceHandle) {
+  if (error == -EAGAIN)
+    return 0;
+  int st = LATE(snd_pcm_state)(deviceHandle);
+  RTC_LOG(LS_VERBOSE) << "Trying to recover from "
+                      << ((LATE(snd_pcm_stream)(deviceHandle) ==
+                           SND_PCM_STREAM_CAPTURE)
+                              ? "capture"
+                              : "playout")
+                      << " error: " << LATE(snd_strerror)(error) << " ("
+                      << error << ") (state " << st << ")";
+
+  // It is recommended to use snd_pcm_recover for all errors. If that function
+  // cannot handle the error, the input error code will be returned, otherwise
+  // 0 is returned. From snd_pcm_recover API doc: "This functions handles
+  // -EINTR (4) (interrupted system call), -EPIPE (32) (playout overrun or
+  // capture underrun) and -ESTRPIPE (86) (stream is suspended) error codes
+  // trying to prepare given stream for next I/O."
+
+  /** Open */
+  //    SND_PCM_STATE_OPEN = 0,
+  /** Setup installed */
+  //    SND_PCM_STATE_SETUP,
+  /** Ready to start */
+  //    SND_PCM_STATE_PREPARED,
+  /** Running */
+  //    SND_PCM_STATE_RUNNING,
+  /** Stopped: underrun (playback) or overrun (capture) detected */
+  //    SND_PCM_STATE_XRUN,= 4
+  /** Draining: running (playback) or stopped (capture) */
+  //    SND_PCM_STATE_DRAINING,
+  /** Paused */
+  //    SND_PCM_STATE_PAUSED,
+  /** Hardware is suspended */
+  //    SND_PCM_STATE_SUSPENDED,
+  //  ** Hardware is disconnected */
+  //    SND_PCM_STATE_DISCONNECTED,
+  //    SND_PCM_STATE_LAST = SND_PCM_STATE_DISCONNECTED
+
+  // snd_pcm_recover isn't available in older alsa, e.g. on the FC4 machine
+  // in Sthlm lab.
+
+  int res = LATE(snd_pcm_recover)(deviceHandle, error, 1);
+  if (0 == res) {
+    RTC_LOG(LS_VERBOSE) << "Recovery - snd_pcm_recover OK";
+
+    if ((error == -EPIPE || error == -ESTRPIPE) &&  // Buf underrun/overrun.
+        _recording &&
+        LATE(snd_pcm_stream)(deviceHandle) == SND_PCM_STREAM_CAPTURE) {
+      // For capture streams we also have to repeat the explicit start()
+      // to get data flowing again.
+      int err = LATE(snd_pcm_start)(deviceHandle);
+      if (err != 0) {
+        RTC_LOG(LS_ERROR) << "Recovery - snd_pcm_start error: " << err;
+        return -1;
+      }
+    }
+
+    if ((error == -EPIPE || error == -ESTRPIPE) &&  // Buf underrun/overrun.
+        _playing &&
+        LATE(snd_pcm_stream)(deviceHandle) == SND_PCM_STREAM_PLAYBACK) {
+      // For capture streams we also have to repeat the explicit start() to get
+      // data flowing again.
+      int err = LATE(snd_pcm_start)(deviceHandle);
+      if (err != 0) {
+        RTC_LOG(LS_ERROR) << "Recovery - snd_pcm_start error: "
+                          << LATE(snd_strerror)(err);
+        return -1;
+      }
+    }
+
+    return -EPIPE == error ? 1 : 0;
+  } else {
+    RTC_LOG(LS_ERROR) << "Unrecoverable alsa stream error: " << res;
+  }
+
+  return res;
+}
+
+// ============================================================================
+//                                  Thread Methods
+// ============================================================================
+
+bool AudioDeviceQnxALSA::PlayThreadProcess() {
+  if (!_playing)
+    return false;
+
+  if (PcmStatus(_handlePlayout) == SND_PCM_STATE_XRUN) {
+    int errVal = LATE(snd_pcm_prepare)(_handlePlayout);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "playout snd_pcm_prepare failed ("
+                        << LATE(snd_strerror)(errVal) << ")\n";
+    }
+    return true;
+  }
+
+  int err;
+  snd_pcm_sframes_t frames;
+  snd_pcm_sframes_t avail_frames;
+
+  Lock();
+
+  // return a positive number of frames ready otherwise a negative error code
+  avail_frames = LATE(snd_pcm_avail_update)(_handlePlayout);
+
+  if (avail_frames < 0) {
+    if (avail_frames != -EAGAIN) {
+      RTC_LOG(LS_ERROR) << "playout snd_pcm_avail_update error: "
+                        << LATE(snd_strerror)(avail_frames);
+      ErrorRecovery(avail_frames, _handlePlayout);
+    }
+    UnLock();
+    return true;
+  } else if (avail_frames == 0) {
+    UnLock();
+
+    // maximum tixe in milliseconds to wait, a negative value means infinity
+    err = LATE(snd_pcm_wait)(_handlePlayout, 2);
+    if (err == 0) {  // timeout occured
+      RTC_LOG(LS_VERBOSE) << "playout snd_pcm_wait timeout";
+    }
+
+    return true;
+  }
+
+  if (_playoutFramesLeft <= 0) {
+    UnLock();
+    _ptrAudioBuffer->RequestPlayoutData(_playoutFramesIn10MS);
+    Lock();
+
+    _playoutFramesLeft = _ptrAudioBuffer->GetPlayoutData(_playoutBuffer);
+    RTC_DCHECK_EQ(_playoutFramesLeft, _playoutFramesIn10MS);
+  }
+
+  if (static_cast<uint32_t>(avail_frames) > _playoutFramesLeft)
+    avail_frames = _playoutFramesLeft;
+
+  int size = LATE(snd_pcm_frames_to_bytes)(_handlePlayout, _playoutFramesLeft);
+  frames = LATE(snd_pcm_writei)(
+      _handlePlayout, &_playoutBuffer[_playoutBufferSizeIn10MS - size],
+      avail_frames);
+
+  if (frames < 0) {
+    RTC_LOG(LS_VERBOSE) << "playout snd_pcm_writei error: "
+                        << LATE(snd_strerror)(frames);
+    _playoutFramesLeft = 0;
+    ErrorRecovery(frames, _handlePlayout);
+    UnLock();
+    return true;
+  } else {
+    RTC_DCHECK_EQ(frames, avail_frames);
+    _playoutFramesLeft -= frames;
+  }
+
+  UnLock();
+  return true;
+}
+
+bool AudioDeviceQnxALSA::RecThreadProcess() {
+  if (!_recording)
+    return false;
+
+  if (PcmStatus(_handleRecord) == SND_PCM_STATE_XRUN) {
+    int errVal = LATE(snd_pcm_prepare)(_handleRecord);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "record snd_pcm_prepare failed ("
+                        << LATE(snd_strerror)(errVal) << ")\n";
+    }
+    return true;
+  }
+
+  int err;
+  snd_pcm_sframes_t frames;
+  snd_pcm_sframes_t avail_frames;
+  int8_t buffer[_recordingBufferSizeIn10MS];
+
+  Lock();
+
+  // return a positive number of frames ready otherwise a negative error code
+  avail_frames = LATE(snd_pcm_avail_update)(_handleRecord);
+  if (avail_frames < 0) {
+    RTC_LOG(LS_ERROR) << "capture snd_pcm_avail_update error: "
+                      << LATE(snd_strerror)(avail_frames);
+    ErrorRecovery(avail_frames, _handleRecord);
+    UnLock();
+    return true;
+  } else if (avail_frames == 0) {  // no frame is available now
+    UnLock();
+
+    // maximum time in milliseconds to wait, a negative value means infinity
+    err = LATE(snd_pcm_wait)(_handleRecord, ALSA_CAPTURE_WAIT_TIMEOUT);
+    if (err == 0)  // timeout occured
+      RTC_LOG(LS_VERBOSE) << "capture snd_pcm_wait timeout";
+
+    return true;
+  }
+
+  if (static_cast<uint32_t>(avail_frames) > _recordingFramesLeft)
+    avail_frames = _recordingFramesLeft;
+
+  frames = LATE(snd_pcm_readi)(_handleRecord, buffer,
+                               avail_frames);  // frames to be written
+  if (frames < 0) {
+    if (frames != -EAGAIN) {
+      RTC_LOG(LS_ERROR) << "capture snd_pcm_readi error: "
+                        << LATE(snd_strerror)(frames);
+      ErrorRecovery(frames, _handleRecord);
+    }
+    UnLock();
+    return true;
+  } else if (frames > 0) {
+    RTC_DCHECK_EQ(frames, avail_frames);
+
+    int left_size =
+        LATE(snd_pcm_frames_to_bytes)(_handleRecord, _recordingFramesLeft);
+    int size = LATE(snd_pcm_frames_to_bytes)(_handleRecord, frames);
+
+    memcpy(&_recordingBuffer[_recordingBufferSizeIn10MS - left_size], buffer,
+           size);
+    _recordingFramesLeft -= frames;
+
+    if (!_recordingFramesLeft) {  // buf is full
+      _recordingFramesLeft = _recordingFramesIn10MS;
+
+      // store the recorded buffer (no action will be taken if the
+      // #recorded samples is not a full buffer)
+      _ptrAudioBuffer->SetRecordedBuffer(_recordingBuffer,
+                                         _recordingFramesIn10MS);
+
+      // calculate delay
+      _playoutDelay = 0;
+      _recordingDelay = 0;
+      if (_handlePlayout) {
+        err = LATE(snd_pcm_delay)(_handlePlayout,
+                                  &_playoutDelay);  // returned delay in frames
+        if (err < 0) {
+          // TODO(xians): Shall we call ErrorRecovery() here?
+          _playoutDelay = 0;
+          RTC_LOG(LS_ERROR)
+              << "playout snd_pcm_delay: " << LATE(snd_strerror)(err);
+        }
+      }
+
+      err = LATE(snd_pcm_delay)(_handleRecord,
+                                &_recordingDelay);  // returned delay in frames
+      if (err < 0) {
+        // TODO(xians): Shall we call ErrorRecovery() here?
+        _recordingDelay = 0;
+        RTC_LOG(LS_ERROR) << "capture snd_pcm_delay: "
+                          << LATE(snd_strerror)(err);
+      }
+
+      // TODO(xians): Shall we add 10ms buffer delay to the record delay?
+      _ptrAudioBuffer->SetVQEData(_playoutDelay * 1000 / _playoutFreq,
+                                  _recordingDelay * 1000 / _recordingFreq);
+
+      _ptrAudioBuffer->SetTypingStatus(KeyPressed());
+
+      // Deliver recorded samples at specified sample rate, mic level etc.
+      // to the observer using callback.
+      UnLock();
+      _ptrAudioBuffer->DeliverRecordedData();
+      Lock();
+    }
+  }
+
+  UnLock();
+  return true;
+}
+
+bool AudioDeviceQnxALSA::KeyPressed() const {
+  return false;
+}
+
+snd_pcm_state_t AudioDeviceQnxALSA::PcmStatus(snd_pcm_t* handle) {
+  snd_pcm_status_t* status;
+  snd_pcm_status_alloca(&status);
+  int errVal = LATE(snd_pcm_status)(handle, status);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "playout snd_pcm_status failed ("
+                      << LATE(snd_strerror)(errVal) << ")\n";
+    return SND_PCM_STATE_PRIVATE1;
+  }
+  snd_pcm_state_t state = LATE(snd_pcm_status_get_state)(status);
+  return state;
+}
+
+bool AudioDeviceQnxALSA::SetParams(snd_pcm_t* handle,
+                                   bool playback,
+                                   snd_pcm_format_t format,
+                                   uint32_t rate,
+                                   uint8_t channels,
+                                   snd_pcm_uframes_t& periodSize,
+                                   snd_pcm_uframes_t& bufferSize) {
+  snd_pcm_hw_params_t* hw_params;
+  snd_pcm_hw_params_alloca(&hw_params);
+  int errVal = LATE(snd_pcm_hw_params_any)(handle, hw_params);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_any failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  errVal = LATE(snd_pcm_hw_params_set_access)(handle, hw_params,
+                                              SND_PCM_ACCESS_RW_INTERLEAVED);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_access failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  errVal = LATE(snd_pcm_hw_params_set_format)(handle, hw_params, format);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_format failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  errVal = LATE(snd_pcm_hw_params_set_channels)(handle, hw_params, channels);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_channels failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_hw_params_set_rate)(handle, hw_params, rate, 0);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_rate failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_hw_params_set_period_size_near)(handle, hw_params,
+                                                        &periodSize, NULL);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_period_size_near failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_hw_params_set_buffer_size_near)(handle, hw_params,
+                                                        &bufferSize);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_set_buffer_size_near failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  /* write the parameters to device */
+  errVal = LATE(snd_pcm_hw_params)(handle, hw_params);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal =
+      LATE(snd_pcm_hw_params_get_period_size)(hw_params, &periodSize, NULL);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_get_period_size failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  errVal = LATE(snd_pcm_hw_params_get_buffer_size)(hw_params, &bufferSize);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_hw_params_get_buffer_size failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+  snd_pcm_sw_params_t* sw_params;
+  snd_pcm_sw_params_alloca(&sw_params);
+  errVal = LATE(snd_pcm_sw_params_current)(handle, sw_params);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_sw_params_current failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_sw_params_set_start_threshold)(handle, sw_params,
+                                                       bufferSize);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_sw_params_set_start_threshold failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_sw_params_set_avail_min)(handle, sw_params, periodSize);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_sw_params_set_avail_min failed"
+                      << LATE(snd_strerror)(errVal);
+    return false;
+  }
+
+  errVal = LATE(snd_pcm_sw_params)(handle, sw_params);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_pcm_sw_params failed"
+                      << LATE(snd_strerror)(errVal);
+
+    return false;
+  }
+  return true;
+}
+
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/audio_device_alsa_snd_qnx.h b/modules/audio_device/qnx/audio_device_alsa_snd_qnx.h
new file mode 100644
index 0000000000..0c7ad207c2
--- /dev/null
+++ b/modules/audio_device/qnx/audio_device_alsa_snd_qnx.h
@@ -0,0 +1,252 @@
+/*
+ *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef AUDIO_DEVICE_AUDIO_DEVICE_ALSA_QNX_H_
+#define AUDIO_DEVICE_AUDIO_DEVICE_ALSA_QNX_H_
+
+#include <map>
+#include <memory>
+
+#include "modules/audio_device/audio_device_generic.h"
+#include "modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h"
+#include "rtc_base/platform_thread.h"
+#include "rtc_base/synchronization/mutex.h"
+
+#include <alsa/asoundlib.h>
+#include <sys/ioctl.h>
+
+typedef webrtc::adm_qnx_alsa::AlsaSymbolTable WebRTCAlsaSymbolTable;
+WebRTCAlsaSymbolTable* GetAlsaSymbolTable();
+
+namespace webrtc {
+
+class AudioDeviceQnxALSA : public AudioDeviceGeneric {
+ public:
+  enum PcmPara {
+    SND_CARD = 1 << 0,
+    SND_DEVICE = 1 << 1,
+    SND_PLUGIN = 1 << 2,
+    SND_FORMAT = 1 << 3,
+    SND_RATE = 1 << 4,
+    SND_CHANNELS = 1 << 5,
+    SND_PERIOD = 1 << 6,
+    SND_BUFFER = 1 << 7
+  };
+  template <bool PLAY>
+  class PcmPreferences {
+   public:
+    PcmPreferences(uint32_t rate, uint8_t channels);
+    ~PcmPreferences() {}
+    void Initialize(const char* path, const char* env);
+    const int16_t& Card() { return _card; }
+    const int16_t& Device() { return _device; }
+    const bool& Plugin() { return _plugin; }
+    const snd_pcm_format_t& format() { return _format; }
+    const uint32_t& rate() { return _rate; }
+    const uint8_t& channels() { return _channels; }
+    const snd_pcm_uframes_t& period() { return _period; }
+    const snd_pcm_uframes_t& buffer() { return _buffer; }
+
+   private:
+    void ParsePcmConfig(const std::string& config);
+    void UpdatePcmPara(PcmPara id, int value);
+    snd_pcm_uframes_t CalculateBuffer(snd_pcm_uframes_t perod);
+
+    int16_t _card;
+    int16_t _device;
+    bool _plugin;
+    snd_pcm_format_t _format;
+    uint32_t _rate;
+    uint8_t _channels;
+    snd_pcm_uframes_t _period;
+    snd_pcm_uframes_t _buffer;
+  };
+  AudioDeviceQnxALSA();
+  virtual ~AudioDeviceQnxALSA();
+
+  // Retrieve the currently utilized audio layer
+  int32_t ActiveAudioLayer(
+      AudioDeviceModule::AudioLayer& audioLayer) const override;
+
+  // Main initializaton and termination
+  InitStatus Init() RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t Terminate() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool Initialized() const override;
+
+  // Device enumeration
+  int16_t PlayoutDevices() override;
+  int16_t RecordingDevices() override;
+  int32_t PlayoutDeviceName(uint16_t index,
+                            char name[kAdmMaxDeviceNameSize],
+                            char guid[kAdmMaxGuidSize]) override;
+  int32_t RecordingDeviceName(uint16_t index,
+                              char name[kAdmMaxDeviceNameSize],
+                              char guid[kAdmMaxGuidSize]) override;
+
+  // Device selection
+  int32_t SetPlayoutDevice(uint16_t index) override;
+  int32_t SetPlayoutDevice(
+      AudioDeviceModule::WindowsDeviceType device) override;
+  int32_t SetRecordingDevice(uint16_t index) override;
+  int32_t SetRecordingDevice(
+      AudioDeviceModule::WindowsDeviceType device) override;
+
+  // Audio transport initialization
+  int32_t PlayoutIsAvailable(bool& available) override;
+  int32_t InitPlayout() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool PlayoutIsInitialized() const override;
+  int32_t RecordingIsAvailable(bool& available) override;
+  int32_t InitRecording() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool RecordingIsInitialized() const override;
+
+  // Audio transport control
+  int32_t StartPlayout() override;
+  int32_t StopPlayout() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool Playing() const override;
+  int32_t StartRecording() override;
+  int32_t StopRecording() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool Recording() const override;
+
+  // Audio mixer initialization
+  int32_t InitSpeaker() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool SpeakerIsInitialized() const override;
+  int32_t InitMicrophone() RTC_LOCKS_EXCLUDED(mutex_) override;
+  bool MicrophoneIsInitialized() const override;
+
+  // Speaker volume controls
+  int32_t SpeakerVolumeIsAvailable(bool& available) override;
+  int32_t SetSpeakerVolume(uint32_t volume) override;
+  int32_t SpeakerVolume(uint32_t& volume) const override;
+  int32_t MaxSpeakerVolume(uint32_t& maxVolume) const override;
+  int32_t MinSpeakerVolume(uint32_t& minVolume) const override;
+
+  // Microphone volume controls
+  int32_t MicrophoneVolumeIsAvailable(bool& available) override;
+  int32_t SetMicrophoneVolume(uint32_t volume) override;
+  int32_t MicrophoneVolume(uint32_t& volume) const override;
+  int32_t MaxMicrophoneVolume(uint32_t& maxVolume) const override;
+  int32_t MinMicrophoneVolume(uint32_t& minVolume) const override;
+
+  // Speaker mute control
+  int32_t SpeakerMuteIsAvailable(bool& available) override;
+  int32_t SetSpeakerMute(bool enable) override;
+  int32_t SpeakerMute(bool& enabled) const override;
+
+  // Microphone mute control
+  int32_t MicrophoneMuteIsAvailable(bool& available) override;
+  int32_t SetMicrophoneMute(bool enable) override;
+  int32_t MicrophoneMute(bool& enabled) const override;
+
+  // Stereo support
+  int32_t StereoPlayoutIsAvailable(bool& available)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t SetStereoPlayout(bool enable) override;
+  int32_t StereoPlayout(bool& enabled) const override;
+  int32_t StereoRecordingIsAvailable(bool& available)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+  int32_t SetStereoRecording(bool enable) override;
+  int32_t StereoRecording(bool& enabled) const override;
+
+  // Delay information and control
+  int32_t PlayoutDelay(uint16_t& delayMS) const override;
+
+  void AttachAudioBuffer(AudioDeviceBuffer* audioBuffer)
+      RTC_LOCKS_EXCLUDED(mutex_) override;
+
+ private:
+  int32_t InitRecordingLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t StopRecordingLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t StopPlayoutLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitPlayoutLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitSpeakerLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t InitMicrophoneLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t GetDevicesInfo(int32_t function,
+                         bool playback,
+                         int32_t enumDeviceNo = 0,
+                         char* enumDeviceName = NULL,
+                         int32_t ednLen = 0) const;
+  int32_t ErrorRecovery(int32_t error, snd_pcm_t* deviceHandle);
+
+  bool KeyPressed() const;
+
+  void Lock() RTC_EXCLUSIVE_LOCK_FUNCTION(mutex_) { mutex_.Lock(); }
+  void UnLock() RTC_UNLOCK_FUNCTION(mutex_) { mutex_.Unlock(); }
+
+  inline int32_t InputSanityCheckAfterUnlockedPeriod() const;
+  inline int32_t OutputSanityCheckAfterUnlockedPeriod() const;
+
+  static void RecThreadFunc(void*);
+  static void PlayThreadFunc(void*);
+  bool RecThreadProcess();
+  bool PlayThreadProcess();
+  snd_pcm_state_t PcmStatus(snd_pcm_t* handle);
+  bool SetParams(snd_pcm_t* handle,
+                 bool playback,
+                 snd_pcm_format_t format,
+                 uint32_t rate,
+                 uint8_t channels,
+                 snd_pcm_uframes_t& periodSize,
+                 snd_pcm_uframes_t& bufferSize);
+
+  AudioDeviceBuffer* _ptrAudioBuffer;
+
+  Mutex mutex_;
+
+  rtc::PlatformThread _ptrThreadRec;
+  rtc::PlatformThread _ptrThreadPlay;
+
+  AudioMixerManagerQnxALSA _mixerManager;
+
+  uint16_t _inputDeviceIndex;
+  uint16_t _outputDeviceIndex;
+  bool _inputDeviceIsSpecified;
+  bool _outputDeviceIsSpecified;
+
+  snd_pcm_t* _handleRecord;
+  snd_pcm_t* _handlePlayout;
+
+  snd_pcm_uframes_t _recordingBuffersizeInFrame;
+  snd_pcm_uframes_t _recordingPeriodSizeInFrame;
+  snd_pcm_uframes_t _playoutBufferSizeInFrame;
+  snd_pcm_uframes_t _playoutPeriodSizeInFrame;
+
+  ssize_t _recordingBufferSizeIn10MS;
+  ssize_t _playoutBufferSizeIn10MS;
+  uint32_t _recordingFramesIn10MS;
+  uint32_t _playoutFramesIn10MS;
+
+  uint32_t _recordingFreq;
+  uint32_t _playoutFreq;
+  uint8_t _recChannels;
+  uint8_t _playChannels;
+
+  int8_t* _recordingBuffer;  // in byte
+  int8_t* _playoutBuffer;    // in byte
+  uint32_t _recordingFramesLeft;
+  uint32_t _playoutFramesLeft;
+
+  bool _initialized;
+  bool _recording;
+  bool _playing;
+  bool _recIsInitialized;
+  bool _playIsInitialized;
+
+  snd_pcm_sframes_t _recordingDelay;
+  snd_pcm_sframes_t _playoutDelay;
+
+  char _oldKeyState[32];
+
+  std::unique_ptr<AudioDeviceQnxALSA::PcmPreferences<true>> _playout_prefs;
+  std::unique_ptr<AudioDeviceQnxALSA::PcmPreferences<false>> _capture_prefs;
+};
+
+}  // namespace webrtc
+
+#endif  // AUDIO_DEVICE_AUDIO_DEVICE_ALSA_QNX_H_
diff --git a/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.cc b/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.cc
new file mode 100644
index 0000000000..9c44040d22
--- /dev/null
+++ b/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.cc
@@ -0,0 +1,979 @@
+/*
+ *  Copyright (c) 2024 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h"
+
+#include "modules/audio_device/qnx/audio_device_alsa_snd_qnx.h"
+#include "rtc_base/logging.h"
+
+// Accesses ALSA functions through our late-binding symbol table instead of
+// directly. This way we don't have to link to libasound, which means our binary
+// will work on systems that don't have it.
+#define LATE(sym)                                                            \
+  LATESYM_GET(webrtc::adm_qnx_alsa::AlsaSymbolTable, GetAlsaSymbolTable(), \
+              sym)
+
+namespace webrtc {
+
+AudioMixerManagerQnxALSA::AudioMixerManagerQnxALSA()
+    : _outputMixerHandle(NULL),
+      _inputMixerHandle(NULL),
+      _outputMixerElement(NULL),
+      _inputMixerElement(NULL) {
+  RTC_DLOG(LS_INFO) << __FUNCTION__ << " created";
+
+  memset(_outputMixerStr, 0, kAdmMaxDeviceNameSize);
+  memset(_inputMixerStr, 0, kAdmMaxDeviceNameSize);
+}
+
+AudioMixerManagerQnxALSA::~AudioMixerManagerQnxALSA() {
+  RTC_DLOG(LS_INFO) << __FUNCTION__ << " destroyed";
+  Close();
+}
+
+// ============================================================================
+//                                    PUBLIC METHODS
+// ============================================================================
+
+int32_t AudioMixerManagerQnxALSA::Close() {
+  RTC_DLOG(LS_VERBOSE) << __FUNCTION__;
+
+  MutexLock lock(&mutex_);
+
+  CloseSpeakerLocked();
+  CloseMicrophoneLocked();
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::CloseSpeaker() {
+  MutexLock lock(&mutex_);
+  return CloseSpeakerLocked();
+}
+
+int32_t AudioMixerManagerQnxALSA::CloseSpeakerLocked() {
+  RTC_DLOG(LS_VERBOSE) << __FUNCTION__;
+
+  int errVal = 0;
+
+  if (_outputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing playout mixer";
+    LATE(snd_mixer_free)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error freeing playout mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    errVal = LATE(snd_mixer_detach)(_outputMixerHandle, _outputMixerStr);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error detaching playout mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    errVal = LATE(snd_mixer_close)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    _outputMixerHandle = NULL;
+    _outputMixerElement = NULL;
+  }
+  memset(_outputMixerStr, 0, kAdmMaxDeviceNameSize);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::CloseMicrophone() {
+  MutexLock lock(&mutex_);
+  return CloseMicrophoneLocked();
+}
+
+int32_t AudioMixerManagerQnxALSA::CloseMicrophoneLocked() {
+  RTC_DLOG(LS_VERBOSE) << __FUNCTION__;
+
+  int errVal = 0;
+
+  if (_inputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+
+    LATE(snd_mixer_free)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error freeing record mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer 2";
+
+    errVal = LATE(snd_mixer_detach)(_inputMixerHandle, _inputMixerStr);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error detaching record mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer 3";
+
+    errVal = LATE(snd_mixer_close)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer 4";
+    _inputMixerHandle = NULL;
+    _inputMixerElement = NULL;
+  }
+  memset(_inputMixerStr, 0, kAdmMaxDeviceNameSize);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::OpenSpeaker(char* deviceName) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::OpenSpeaker(name="
+                      << deviceName << ")";
+
+  MutexLock lock(&mutex_);
+
+  int errVal = 0;
+
+  // Close any existing output mixer handle
+  //
+  if (_outputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing playout mixer";
+
+    LATE(snd_mixer_free)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error freeing playout mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    errVal = LATE(snd_mixer_detach)(_outputMixerHandle, _outputMixerStr);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error detaching playout mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    errVal = LATE(snd_mixer_close)(_outputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+  }
+  _outputMixerHandle = NULL;
+  _outputMixerElement = NULL;
+
+  errVal = LATE(snd_mixer_open)(&_outputMixerHandle, 0);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_open(&_outputMixerHandle, 0) - error";
+    return -1;
+  }
+
+  char controlName[kAdmMaxDeviceNameSize] = {0};
+  GetControlName(controlName, deviceName);
+
+  RTC_LOG(LS_VERBOSE) << "snd_mixer_attach(_outputMixerHandle, " << controlName
+                      << ")";
+
+  errVal = LATE(snd_mixer_attach)(_outputMixerHandle, controlName);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_attach(_outputMixerHandle, " << controlName
+                      << ") error: " << LATE(snd_strerror)(errVal);
+    _outputMixerHandle = NULL;
+    return -1;
+  }
+  strcpy(_outputMixerStr, controlName);
+
+  errVal = LATE(snd_mixer_selem_register)(_outputMixerHandle, NULL, NULL);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR)
+        << "snd_mixer_selem_register(_outputMixerHandle, NULL, NULL), "
+           "error: "
+        << LATE(snd_strerror)(errVal);
+    _outputMixerHandle = NULL;
+    return -1;
+  }
+
+  // Load and find the proper mixer element
+  if (LoadSpeakerMixerElement() < 0) {
+    return -1;
+  }
+
+  if (_outputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "the output mixer device is now open ("
+                        << _outputMixerHandle << ")";
+  }
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::OpenMicrophone(char* deviceName) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::OpenMicrophone(name="
+                      << deviceName << ")";
+
+  MutexLock lock(&mutex_);
+
+  int errVal = 0;
+
+  // Close any existing input mixer handle
+  //
+  if (_inputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+
+    LATE(snd_mixer_free)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error freeing record mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+
+    errVal = LATE(snd_mixer_detach)(_inputMixerHandle, _inputMixerStr);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error detaching record mixer: "
+                        << LATE(snd_strerror)(errVal);
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+
+    errVal = LATE(snd_mixer_close)(_inputMixerHandle);
+    if (errVal < 0) {
+      RTC_LOG(LS_ERROR) << "Error snd_mixer_close(handleMixer) errVal="
+                        << errVal;
+    }
+    RTC_LOG(LS_VERBOSE) << "Closing record mixer";
+  }
+  _inputMixerHandle = NULL;
+  _inputMixerElement = NULL;
+
+  errVal = LATE(snd_mixer_open)(&_inputMixerHandle, 0);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_open(&_inputMixerHandle, 0) - error";
+    return -1;
+  }
+
+  char controlName[kAdmMaxDeviceNameSize] = {0};
+  GetControlName(controlName, deviceName);
+
+  RTC_LOG(LS_VERBOSE) << "snd_mixer_attach(_inputMixerHandle, " << controlName
+                      << ")";
+
+  errVal = LATE(snd_mixer_attach)(_inputMixerHandle, controlName);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_attach(_inputMixerHandle, " << controlName
+                      << ") error: " << LATE(snd_strerror)(errVal);
+
+    _inputMixerHandle = NULL;
+    return -1;
+  }
+  strcpy(_inputMixerStr, controlName);
+
+  errVal = LATE(snd_mixer_selem_register)(_inputMixerHandle, NULL, NULL);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR)
+        << "snd_mixer_selem_register(_inputMixerHandle, NULL, NULL), "
+           "error: "
+        << LATE(snd_strerror)(errVal);
+
+    _inputMixerHandle = NULL;
+    return -1;
+  }
+  // Load and find the proper mixer element
+  if (LoadMicMixerElement() < 0) {
+    return -1;
+  }
+
+  if (_inputMixerHandle != NULL) {
+    RTC_LOG(LS_VERBOSE) << "the input mixer device is now open ("
+                        << _inputMixerHandle << ")";
+  }
+
+  return 0;
+}
+
+bool AudioMixerManagerQnxALSA::SpeakerIsInitialized() const {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+
+  return (_outputMixerHandle != NULL);
+}
+
+bool AudioMixerManagerQnxALSA::MicrophoneIsInitialized() const {
+  RTC_DLOG(LS_INFO) << __FUNCTION__;
+
+  return (_inputMixerHandle != NULL);
+}
+
+int32_t AudioMixerManagerQnxALSA::SetSpeakerVolume(uint32_t volume) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::SetSpeakerVolume(volume="
+                      << volume << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  int errVal = LATE(snd_mixer_selem_set_playback_volume_all)(
+      _outputMixerElement, volume);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error changing master volume: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  return (0);
+}
+
+int32_t AudioMixerManagerQnxALSA::SpeakerVolume(uint32_t& volume) const {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  long int vol(0);
+
+  int errVal = LATE(snd_mixer_selem_get_playback_volume)(
+      _outputMixerElement, (snd_mixer_selem_channel_id_t)0, &vol);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error getting outputvolume: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::SpeakerVolume() => vol="
+                      << vol;
+
+  volume = static_cast<uint32_t>(vol);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MaxSpeakerVolume(
+    uint32_t& maxVolume) const {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avilable output mixer element exists";
+    return -1;
+  }
+
+  long int minVol(0);
+  long int maxVol(0);
+
+  int errVal = LATE(snd_mixer_selem_get_playback_volume_range)(
+      _outputMixerElement, &minVol, &maxVol);
+
+  RTC_LOG(LS_VERBOSE) << "Playout hardware volume range, min: " << minVol
+                      << ", max: " << maxVol;
+
+  if (maxVol <= minVol) {
+    RTC_LOG(LS_ERROR) << "Error getting get_playback_volume_range: "
+                      << LATE(snd_strerror)(errVal);
+  }
+
+  maxVolume = static_cast<uint32_t>(maxVol);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MinSpeakerVolume(
+    uint32_t& minVolume) const {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  long int minVol(0);
+  long int maxVol(0);
+
+  int errVal = LATE(snd_mixer_selem_get_playback_volume_range)(
+      _outputMixerElement, &minVol, &maxVol);
+
+  RTC_LOG(LS_VERBOSE) << "Playout hardware volume range, min: " << minVol
+                      << ", max: " << maxVol;
+
+  if (maxVol <= minVol) {
+    RTC_LOG(LS_ERROR) << "Error getting get_playback_volume_range: "
+                      << LATE(snd_strerror)(errVal);
+  }
+
+  minVolume = static_cast<uint32_t>(minVol);
+
+  return 0;
+}
+
+// TL: Have done testnig with these but they don't seem reliable and
+// they were therefore not added
+/*
+ // ----------------------------------------------------------------------------
+ //    SetMaxSpeakerVolume
+ // ----------------------------------------------------------------------------
+
+ int32_t AudioMixerManagerQnxALSA::SetMaxSpeakerVolume(
+     uint32_t maxVolume)
+ {
+
+ if (_outputMixerElement == NULL)
+ {
+ RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+ return -1;
+ }
+
+ long int minVol(0);
+ long int maxVol(0);
+
+ int errVal = snd_mixer_selem_get_playback_volume_range(
+ _outputMixerElement, &minVol, &maxVol);
+ if ((maxVol <= minVol) || (errVal != 0))
+ {
+ RTC_LOG(LS_WARNING) << "Error getting playback volume range: "
+                 << snd_strerror(errVal);
+ }
+
+ maxVol = maxVolume;
+ errVal = snd_mixer_selem_set_playback_volume_range(
+ _outputMixerElement, minVol, maxVol);
+ RTC_LOG(LS_VERBOSE) << "Playout hardware volume range, min: " << minVol
+                 << ", max: " << maxVol;
+ if (errVal != 0)
+ {
+ RTC_LOG(LS_ERROR) << "Error setting playback volume range: "
+               << snd_strerror(errVal);
+ return -1;
+ }
+
+ return 0;
+ }
+
+ // ----------------------------------------------------------------------------
+ //    SetMinSpeakerVolume
+ // ----------------------------------------------------------------------------
+
+ int32_t AudioMixerManagerQnxALSA::SetMinSpeakerVolume(
+     uint32_t minVolume)
+ {
+
+ if (_outputMixerElement == NULL)
+ {
+ RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+ return -1;
+ }
+
+ long int minVol(0);
+ long int maxVol(0);
+
+ int errVal = snd_mixer_selem_get_playback_volume_range(
+ _outputMixerElement, &minVol, &maxVol);
+ if ((maxVol <= minVol) || (errVal != 0))
+ {
+ RTC_LOG(LS_WARNING) << "Error getting playback volume range: "
+                 << snd_strerror(errVal);
+ }
+
+ minVol = minVolume;
+ errVal = snd_mixer_selem_set_playback_volume_range(
+ _outputMixerElement, minVol, maxVol);
+ RTC_LOG(LS_VERBOSE) << "Playout hardware volume range, min: " << minVol
+                 << ", max: " << maxVol;
+ if (errVal != 0)
+ {
+ RTC_LOG(LS_ERROR) << "Error setting playback volume range: "
+               << snd_strerror(errVal);
+ return -1;
+ }
+
+ return 0;
+ }
+ */
+
+int32_t AudioMixerManagerQnxALSA::SpeakerVolumeIsAvailable(bool& available) {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  available = LATE(snd_mixer_selem_has_playback_volume)(_outputMixerElement);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::SpeakerMuteIsAvailable(bool& available) {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  available = LATE(snd_mixer_selem_has_playback_switch)(_outputMixerElement);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::SetSpeakerMute(bool enable) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::SetSpeakerMute(enable="
+                      << enable << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+    return -1;
+  }
+
+  // Ensure that the selected speaker destination has a valid mute control.
+  bool available(false);
+  SpeakerMuteIsAvailable(available);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the speaker";
+    return -1;
+  }
+
+  // Note value = 0 (off) means muted
+  int errVal = LATE(snd_mixer_selem_set_playback_switch_all)(
+      _outputMixerElement, !enable);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error setting playback switch: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  return (0);
+}
+
+int32_t AudioMixerManagerQnxALSA::SpeakerMute(bool& enabled) const {
+  if (_outputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable output mixer exists";
+    return -1;
+  }
+
+  // Ensure that the selected speaker destination has a valid mute control.
+  bool available =
+      LATE(snd_mixer_selem_has_playback_switch)(_outputMixerElement);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the speaker";
+    return -1;
+  }
+
+  int value(false);
+
+  // Retrieve one boolean control value for a specified mute-control
+  //
+  int errVal = LATE(snd_mixer_selem_get_playback_switch)(
+      _outputMixerElement, (snd_mixer_selem_channel_id_t)0, &value);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error getting playback switch: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  // Note value = 0 (off) means muted
+  enabled = (bool)!value;
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MicrophoneMuteIsAvailable(bool& available) {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  available = LATE(snd_mixer_selem_has_capture_switch)(_inputMixerElement);
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::SetMicrophoneMute(bool enable) {
+  RTC_LOG(LS_VERBOSE) << "AudioMixerManagerQnxALSA::SetMicrophoneMute(enable="
+                      << enable << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  // Ensure that the selected microphone destination has a valid mute control.
+  bool available(false);
+  MicrophoneMuteIsAvailable(available);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the microphone";
+    return -1;
+  }
+
+  // Note value = 0 (off) means muted
+  int errVal =
+      LATE(snd_mixer_selem_set_capture_switch_all)(_inputMixerElement, !enable);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error setting capture switch: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  return (0);
+}
+
+int32_t AudioMixerManagerQnxALSA::MicrophoneMute(bool& enabled) const {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer exists";
+    return -1;
+  }
+
+  // Ensure that the selected microphone destination has a valid mute control.
+  bool available = LATE(snd_mixer_selem_has_capture_switch)(_inputMixerElement);
+  if (!available) {
+    RTC_LOG(LS_WARNING) << "it is not possible to mute the microphone";
+    return -1;
+  }
+
+  int value(false);
+
+  // Retrieve one boolean control value for a specified mute-control
+  //
+  int errVal = LATE(snd_mixer_selem_get_capture_switch)(
+      _inputMixerElement, (snd_mixer_selem_channel_id_t)0, &value);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error getting capture switch: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  // Note value = 0 (off) means muted
+  enabled = (bool)!value;
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MicrophoneVolumeIsAvailable(
+    bool& available) {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  available = LATE(snd_mixer_selem_has_capture_volume)(_inputMixerElement);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::SetMicrophoneVolume(uint32_t volume) {
+  RTC_LOG(LS_VERBOSE)
+      << "AudioMixerManagerQnxALSA::SetMicrophoneVolume(volume=" << volume
+      << ")";
+
+  MutexLock lock(&mutex_);
+
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  int errVal =
+      LATE(snd_mixer_selem_set_capture_volume_all)(_inputMixerElement, volume);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error changing microphone volume: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+
+  return (0);
+}
+
+// TL: Have done testnig with these but they don't seem reliable and
+// they were therefore not added
+/*
+ // ----------------------------------------------------------------------------
+ //    SetMaxMicrophoneVolume
+ // ----------------------------------------------------------------------------
+
+ int32_t AudioMixerManagerQnxALSA::SetMaxMicrophoneVolume(
+     uint32_t maxVolume)
+ {
+
+ if (_inputMixerElement == NULL)
+ {
+ RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+ return -1;
+ }
+
+ long int minVol(0);
+ long int maxVol(0);
+
+ int errVal = snd_mixer_selem_get_capture_volume_range(_inputMixerElement,
+  &minVol, &maxVol);
+ if ((maxVol <= minVol) || (errVal != 0))
+ {
+ RTC_LOG(LS_WARNING) << "Error getting capture volume range: "
+                 << snd_strerror(errVal);
+ }
+
+ maxVol = (long int)maxVolume;
+ printf("min %d max %d", minVol, maxVol);
+ errVal = snd_mixer_selem_set_capture_volume_range(_inputMixerElement, minVol,
+ maxVol); RTC_LOG(LS_VERBOSE) << "Capture hardware volume range, min: " <<
+ minVol
+                 << ", max: " << maxVol;
+ if (errVal != 0)
+ {
+ RTC_LOG(LS_ERROR) << "Error setting capture volume range: "
+               << snd_strerror(errVal);
+ return -1;
+ }
+
+ return 0;
+ }
+
+ // ----------------------------------------------------------------------------
+ //    SetMinMicrophoneVolume
+ // ----------------------------------------------------------------------------
+
+ int32_t AudioMixerManagerQnxALSA::SetMinMicrophoneVolume(
+ uint32_t minVolume)
+ {
+
+ if (_inputMixerElement == NULL)
+ {
+ RTC_LOG(LS_WARNING) << "no avaliable output mixer element exists";
+ return -1;
+ }
+
+ long int minVol(0);
+ long int maxVol(0);
+
+ int errVal = snd_mixer_selem_get_capture_volume_range(
+ _inputMixerElement, &minVol, &maxVol);
+ if (maxVol <= minVol)
+ {
+ //maxVol = 255;
+ RTC_LOG(LS_WARNING) << "Error getting capture volume range: "
+                 << snd_strerror(errVal);
+ }
+
+ printf("min %d max %d", minVol, maxVol);
+ minVol = (long int)minVolume;
+ errVal = snd_mixer_selem_set_capture_volume_range(
+ _inputMixerElement, minVol, maxVol);
+ RTC_LOG(LS_VERBOSE) << "Capture hardware volume range, min: " << minVol
+                 << ", max: " << maxVol;
+ if (errVal != 0)
+ {
+ RTC_LOG(LS_ERROR) << "Error setting capture volume range: "
+               << snd_strerror(errVal);
+ return -1;
+ }
+
+ return 0;
+ }
+ */
+
+int32_t AudioMixerManagerQnxALSA::MicrophoneVolume(uint32_t& volume) const {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  long int vol(0);
+
+  int errVal = LATE(snd_mixer_selem_get_capture_volume)(
+      _inputMixerElement, (snd_mixer_selem_channel_id_t)0, &vol);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "Error getting inputvolume: "
+                      << LATE(snd_strerror)(errVal);
+    return -1;
+  }
+  RTC_LOG(LS_VERBOSE)
+      << "AudioMixerManagerQnxALSA::MicrophoneVolume() => vol=" << vol;
+
+  volume = static_cast<uint32_t>(vol);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MaxMicrophoneVolume(
+    uint32_t& maxVolume) const {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  long int minVol(0);
+  long int maxVol(0);
+
+  // check if we have mic volume at all
+  if (!LATE(snd_mixer_selem_has_capture_volume)(_inputMixerElement)) {
+    RTC_LOG(LS_ERROR) << "No microphone volume available";
+    return -1;
+  }
+
+  int errVal = LATE(snd_mixer_selem_get_capture_volume_range)(
+      _inputMixerElement, &minVol, &maxVol);
+
+  RTC_LOG(LS_VERBOSE) << "Microphone hardware volume range, min: " << minVol
+                      << ", max: " << maxVol;
+  if (maxVol <= minVol) {
+    RTC_LOG(LS_ERROR) << "Error getting microphone volume range: "
+                      << LATE(snd_strerror)(errVal);
+  }
+
+  maxVolume = static_cast<uint32_t>(maxVol);
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::MinMicrophoneVolume(
+    uint32_t& minVolume) const {
+  if (_inputMixerElement == NULL) {
+    RTC_LOG(LS_WARNING) << "no avaliable input mixer element exists";
+    return -1;
+  }
+
+  long int minVol(0);
+  long int maxVol(0);
+
+  int errVal = LATE(snd_mixer_selem_get_capture_volume_range)(
+      _inputMixerElement, &minVol, &maxVol);
+
+  RTC_LOG(LS_VERBOSE) << "Microphone hardware volume range, min: " << minVol
+                      << ", max: " << maxVol;
+  if (maxVol <= minVol) {
+    RTC_LOG(LS_ERROR) << "Error getting microphone volume range: "
+                      << LATE(snd_strerror)(errVal);
+  }
+
+  minVolume = static_cast<uint32_t>(minVol);
+
+  return 0;
+}
+
+// ============================================================================
+//                                 Private Methods
+// ============================================================================
+
+int32_t AudioMixerManagerQnxALSA::LoadMicMixerElement() const {
+  int errVal = LATE(snd_mixer_load)(_inputMixerHandle);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_load(_inputMixerHandle), error: "
+                      << LATE(snd_strerror)(errVal);
+    _inputMixerHandle = NULL;
+    return -1;
+  }
+
+  snd_mixer_elem_t* elem = NULL;
+  snd_mixer_elem_t* micElem = NULL;
+  unsigned mixerIdx = 0;
+  const char* selemName = NULL;
+
+  // Find and store handles to the right mixer elements
+  for (elem = LATE(snd_mixer_first_elem)(_inputMixerHandle); elem;
+       elem = LATE(snd_mixer_elem_next)(elem), mixerIdx++) {
+    if (LATE(snd_mixer_selem_is_active)(elem)) {
+      selemName = LATE(snd_mixer_selem_get_name)(elem);
+      if (strcmp(selemName, "Capture") == 0)  // "Capture", "Mic"
+      {
+        _inputMixerElement = elem;
+        RTC_LOG(LS_VERBOSE) << "Capture element set";
+      } else if (strcmp(selemName, "Mic") == 0) {
+        micElem = elem;
+        RTC_LOG(LS_VERBOSE) << "Mic element found";
+      }
+    }
+
+    if (_inputMixerElement) {
+      // Use the first Capture element that is found
+      // The second one may not work
+      break;
+    }
+  }
+
+  if (_inputMixerElement == NULL) {
+    // We didn't find a Capture handle, use Mic.
+    if (micElem != NULL) {
+      _inputMixerElement = micElem;
+      RTC_LOG(LS_VERBOSE) << "Using Mic as capture volume.";
+    } else {
+      _inputMixerElement = NULL;
+      RTC_LOG(LS_ERROR) << "Could not find capture volume on the mixer.";
+
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+int32_t AudioMixerManagerQnxALSA::LoadSpeakerMixerElement() const {
+  int errVal = LATE(snd_mixer_load)(_outputMixerHandle);
+  if (errVal < 0) {
+    RTC_LOG(LS_ERROR) << "snd_mixer_load(_outputMixerHandle), error: "
+                      << LATE(snd_strerror)(errVal);
+    _outputMixerHandle = NULL;
+    return -1;
+  }
+
+  snd_mixer_elem_t* elem = NULL;
+  snd_mixer_elem_t* masterElem = NULL;
+  snd_mixer_elem_t* speakerElem = NULL;
+  unsigned mixerIdx = 0;
+  const char* selemName = NULL;
+
+  // Find and store handles to the right mixer elements
+  for (elem = LATE(snd_mixer_first_elem)(_outputMixerHandle); elem;
+       elem = LATE(snd_mixer_elem_next)(elem), mixerIdx++) {
+    if (LATE(snd_mixer_selem_is_active)(elem)) {
+      selemName = LATE(snd_mixer_selem_get_name)(elem);
+      RTC_LOG(LS_VERBOSE) << "snd_mixer_selem_get_name " << mixerIdx << ": "
+                          << selemName << " =" << elem;
+
+      // "Master", "PCM", "Wave", "Master Mono", "PC Speaker", "PCM", "Wave"
+      if (strcmp(selemName, "PCM") == 0) {
+        _outputMixerElement = elem;
+        RTC_LOG(LS_VERBOSE) << "PCM element set";
+      } else if (strcmp(selemName, "Master") == 0) {
+        masterElem = elem;
+        RTC_LOG(LS_VERBOSE) << "Master element found";
+      } else if (strcmp(selemName, "Speaker") == 0) {
+        speakerElem = elem;
+        RTC_LOG(LS_VERBOSE) << "Speaker element found";
+      }
+    }
+
+    if (_outputMixerElement) {
+      // We have found the element we want
+      break;
+    }
+  }
+
+  // If we didn't find a PCM Handle, use Master or Speaker
+  if (_outputMixerElement == NULL) {
+    if (masterElem != NULL) {
+      _outputMixerElement = masterElem;
+      RTC_LOG(LS_VERBOSE) << "Using Master as output volume.";
+    } else if (speakerElem != NULL) {
+      _outputMixerElement = speakerElem;
+      RTC_LOG(LS_VERBOSE) << "Using Speaker as output volume.";
+    } else {
+      _outputMixerElement = NULL;
+      RTC_LOG(LS_ERROR) << "Could not find output volume in the mixer.";
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+void AudioMixerManagerQnxALSA::GetControlName(char* controlName,
+                                                char* deviceName) const {
+  // Example
+  // deviceName: "front:CARD=Intel,DEV=0"
+  // controlName: "hw:CARD=Intel"
+  char* pos1 = strchr(deviceName, ':');
+  char* pos2 = strchr(deviceName, ',');
+  if (!pos2) {
+    // Can also be default:CARD=Intel
+    pos2 = &deviceName[strlen(deviceName)];
+  }
+  if (pos1 && pos2) {
+    strcpy(controlName, "hw");
+    int nChar = (int)(pos2 - pos1);
+    strncpy(&controlName[2], pos1, nChar);
+    controlName[2 + nChar] = '\0';
+  } else {
+    strcpy(controlName, deviceName);
+  }
+}
+
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h b/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h
new file mode 100644
index 0000000000..7934b6cd75
--- /dev/null
+++ b/modules/audio_device/qnx/audio_mixer_manager_alsa_snd_qnx.h
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (c) 2011 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef AUDIO_DEVICE_AUDIO_MIXER_MANAGER_ALSA_QNX_H_
+#define AUDIO_DEVICE_AUDIO_MIXER_MANAGER_ALSA_QNX_H_
+
+#include <alsa/asoundlib.h>
+
+#include "modules/audio_device/include/audio_device.h"
+#include "modules/audio_device/qnx/alsasymboltable_snd_qnx.h"
+#include "rtc_base/synchronization/mutex.h"
+
+namespace webrtc {
+
+class AudioMixerManagerQnxALSA {
+ public:
+  int32_t OpenSpeaker(char* deviceName) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t OpenMicrophone(char* deviceName) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t SetSpeakerVolume(uint32_t volume) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t SpeakerVolume(uint32_t& volume) const;
+  int32_t MaxSpeakerVolume(uint32_t& maxVolume) const;
+  int32_t MinSpeakerVolume(uint32_t& minVolume) const;
+  int32_t SpeakerVolumeIsAvailable(bool& available);
+  int32_t SpeakerMuteIsAvailable(bool& available);
+  int32_t SetSpeakerMute(bool enable) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t SpeakerMute(bool& enabled) const;
+  int32_t MicrophoneMuteIsAvailable(bool& available);
+  int32_t SetMicrophoneMute(bool enable) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t MicrophoneMute(bool& enabled) const;
+  int32_t MicrophoneVolumeIsAvailable(bool& available);
+  int32_t SetMicrophoneVolume(uint32_t volume) RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t MicrophoneVolume(uint32_t& volume) const;
+  int32_t MaxMicrophoneVolume(uint32_t& maxVolume) const;
+  int32_t MinMicrophoneVolume(uint32_t& minVolume) const;
+  int32_t Close() RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t CloseSpeaker() RTC_LOCKS_EXCLUDED(mutex_);
+  int32_t CloseMicrophone() RTC_LOCKS_EXCLUDED(mutex_);
+  bool SpeakerIsInitialized() const;
+  bool MicrophoneIsInitialized() const;
+
+ public:
+  AudioMixerManagerQnxALSA();
+  ~AudioMixerManagerQnxALSA();
+
+ private:
+  int32_t CloseSpeakerLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t CloseMicrophoneLocked() RTC_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  int32_t LoadMicMixerElement() const;
+  int32_t LoadSpeakerMixerElement() const;
+  void GetControlName(char* controlName, char* deviceName) const;
+
+ private:
+  Mutex mutex_;
+  mutable snd_mixer_t* _outputMixerHandle;
+  char _outputMixerStr[kAdmMaxDeviceNameSize];
+  mutable snd_mixer_t* _inputMixerHandle;
+  char _inputMixerStr[kAdmMaxDeviceNameSize];
+  mutable snd_mixer_elem_t* _outputMixerElement;
+  mutable snd_mixer_elem_t* _inputMixerElement;
+};
+
+}  // namespace webrtc
+
+#endif  // AUDIO_DEVICE_AUDIO_MIXER_MANAGER_ALSA_QNX_H_
diff --git a/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.cc b/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.cc
new file mode 100644
index 0000000000..ea388bd6a9
--- /dev/null
+++ b/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.cc
@@ -0,0 +1,106 @@
+/*
+ *  Copyright (c) 2024 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h"
+
+#include "absl/strings/string_view.h"
+#include "rtc_base/logging.h"
+
+#ifdef WEBRTC_QNX
+#include <dlfcn.h>
+#endif
+
+namespace webrtc {
+namespace adm_qnx {
+
+inline static const char* GetDllError() {
+#ifdef WEBRTC_QNX
+  char* err = dlerror();
+  if (err) {
+    return err;
+  } else {
+    return "No error";
+  }
+#else
+#error Not implemented
+#endif
+}
+
+DllHandle InternalLoadDll(absl::string_view dll_name) {
+#ifdef WEBRTC_QNX
+  DllHandle handle = dlopen(std::string(dll_name).c_str(), RTLD_NOW);
+#else
+#error Not implemented
+#endif
+  if (handle == kInvalidDllHandle) {
+    RTC_LOG(LS_WARNING) << "Can't load " << dll_name << " : " << GetDllError();
+  }
+  return handle;
+}
+
+void InternalUnloadDll(DllHandle handle) {
+#ifdef WEBRTC_QNX
+// TODO(pbos): Remove this dlclose() exclusion when leaks and suppressions from
+// here are gone (or AddressSanitizer can display them properly).
+//
+// Skip dlclose() on AddressSanitizer as leaks including this module in the
+// stack trace gets displayed as <unknown module> instead of the actual library
+// -> it can not be suppressed.
+// https://code.google.com/p/address-sanitizer/issues/detail?id=89
+#if !defined(ADDRESS_SANITIZER)
+  if (dlclose(handle) != 0) {
+    RTC_LOG(LS_ERROR) << GetDllError();
+  }
+#endif  // !defined(ADDRESS_SANITIZER)
+#else
+#error Not implemented
+#endif
+}
+
+static bool LoadSymbol(DllHandle handle,
+                       absl::string_view symbol_name,
+                       void** symbol) {
+#ifdef WEBRTC_QNX
+  *symbol = dlsym(handle, std::string(symbol_name).c_str());
+  char* err = dlerror();
+  if (err) {
+    RTC_LOG(LS_ERROR) << "Error loading symbol " << symbol_name << " : " << err;
+    return false;
+  } else if (!*symbol) {
+    RTC_LOG(LS_ERROR) << "Symbol " << symbol_name << " is NULL";
+    return false;
+  }
+  return true;
+#else
+#error Not implemented
+#endif
+}
+
+// This routine MUST assign SOME value for every symbol, even if that value is
+// NULL, or else some symbols may be left with uninitialized data that the
+// caller may later interpret as a valid address.
+bool InternalLoadSymbols(DllHandle handle,
+                         int num_symbols,
+                         const char* const symbol_names[],
+                         void* symbols[]) {
+#ifdef WEBRTC_QNX
+  // Clear any old errors.
+  dlerror();
+#endif
+  for (int i = 0; i < num_symbols; ++i) {
+    if (!LoadSymbol(handle, symbol_names[i], &symbols[i])) {
+      return false;
+    }
+  }
+  return true;
+}
+
+}  // namespace adm_qnx
+}  // namespace webrtc
diff --git a/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h b/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h
new file mode 100644
index 0000000000..04982afe3b
--- /dev/null
+++ b/modules/audio_device/qnx/latebindingsymboltable_snd_qnx.h
@@ -0,0 +1,165 @@
+/*
+ *  Copyright (c) 2010 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef AUDIO_DEVICE_LATEBINDINGSYMBOLTABLE_QNX_H_
+#define AUDIO_DEVICE_LATEBINDINGSYMBOLTABLE_QNX_H_
+
+#include <stddef.h>  // for NULL
+#include <string.h>
+
+#include "absl/strings/string_view.h"
+#include "rtc_base/checks.h"
+
+// This file provides macros for creating "symbol table" classes to simplify the
+// dynamic loading of symbols from DLLs.
+namespace webrtc {
+namespace adm_qnx {
+
+#ifdef WEBRTC_QNX
+typedef void* DllHandle;
+
+const DllHandle kInvalidDllHandle = NULL;
+#else
+#error Not implemented
+#endif
+
+// These are helpers for use only by the class below.
+DllHandle InternalLoadDll(absl::string_view);
+
+void InternalUnloadDll(DllHandle handle);
+
+bool InternalLoadSymbols(DllHandle handle,
+                         int num_symbols,
+                         const char* const symbol_names[],
+                         void* symbols[]);
+
+template <int SYMBOL_TABLE_SIZE,
+          const char kDllName[],
+          const char* const kSymbolNames[]>
+class LateBindingSymbolTable {
+ public:
+  LateBindingSymbolTable()
+      : handle_(kInvalidDllHandle), undefined_symbols_(false) {
+    memset(symbols_, 0, sizeof(symbols_));
+  }
+
+  ~LateBindingSymbolTable() { Unload(); }
+
+  LateBindingSymbolTable(const LateBindingSymbolTable&) = delete;
+  LateBindingSymbolTable& operator=(LateBindingSymbolTable&) = delete;
+
+  static int NumSymbols() { return SYMBOL_TABLE_SIZE; }
+
+  // We do not use this, but we offer it for theoretical convenience.
+  static const char* GetSymbolName(int index) {
+    RTC_DCHECK_LT(index, NumSymbols());
+    return kSymbolNames[index];
+  }
+
+  bool IsLoaded() const { return handle_ != kInvalidDllHandle; }
+
+  // Loads the DLL and the symbol table. Returns true iff the DLL and symbol
+  // table loaded successfully.
+  bool Load() {
+    if (IsLoaded()) {
+      return true;
+    }
+    if (undefined_symbols_) {
+      // We do not attempt to load again because repeated attempts are not
+      // likely to succeed and DLL loading is costly.
+      return false;
+    }
+    handle_ = InternalLoadDll(kDllName);
+    if (!IsLoaded()) {
+      return false;
+    }
+    if (!InternalLoadSymbols(handle_, NumSymbols(), kSymbolNames, symbols_)) {
+      undefined_symbols_ = true;
+      Unload();
+      return false;
+    }
+    return true;
+  }
+
+  void Unload() {
+    if (!IsLoaded()) {
+      return;
+    }
+    InternalUnloadDll(handle_);
+    handle_ = kInvalidDllHandle;
+    memset(symbols_, 0, sizeof(symbols_));
+  }
+
+  // Retrieves the given symbol. NOTE: Recommended to use LATESYM_GET below
+  // instead of this.
+  void* GetSymbol(int index) const {
+    RTC_DCHECK(IsLoaded());
+    RTC_DCHECK_LT(index, NumSymbols());
+    return symbols_[index];
+  }
+
+ private:
+  DllHandle handle_;
+  bool undefined_symbols_;
+  void* symbols_[SYMBOL_TABLE_SIZE];
+};
+
+// This macro must be invoked in a header to declare a symbol table class.
+#define LATE_BINDING_SYMBOL_TABLE_DECLARE_BEGIN(ClassName) enum {
+// This macro must be invoked in the header declaration once for each symbol
+// (recommended to use an X-Macro to avoid duplication).
+// This macro defines an enum with names built from the symbols, which
+// essentially creates a hash table in the compiler from symbol names to their
+// indices in the symbol table class.
+#define LATE_BINDING_SYMBOL_TABLE_DECLARE_ENTRY(ClassName, sym) \
+  ClassName##_SYMBOL_TABLE_INDEX_##sym,
+
+// This macro completes the header declaration.
+#define LATE_BINDING_SYMBOL_TABLE_DECLARE_END(ClassName)       \
+  ClassName##_SYMBOL_TABLE_SIZE                                \
+  }                                                            \
+  ;                                                            \
+                                                               \
+  extern const char ClassName##_kDllName[];                    \
+  extern const char* const                                     \
+      ClassName##_kSymbolNames[ClassName##_SYMBOL_TABLE_SIZE]; \
+                                                               \
+  typedef ::webrtc::adm_qnx::LateBindingSymbolTable<         \
+      ClassName##_SYMBOL_TABLE_SIZE, ClassName##_kDllName,     \
+      ClassName##_kSymbolNames>                                \
+      ClassName;
+
+// This macro must be invoked in a .cc file to define a previously-declared
+// symbol table class.
+#define LATE_BINDING_SYMBOL_TABLE_DEFINE_BEGIN(ClassName, dllName) \
+  const char ClassName##_kDllName[] = dllName;                     \
+  const char* const ClassName##_kSymbolNames[ClassName##_SYMBOL_TABLE_SIZE] = {
+// This macro must be invoked in the .cc definition once for each symbol
+// (recommended to use an X-Macro to avoid duplication).
+// This would have to use the mangled name if we were to ever support C++
+// symbols.
+#define LATE_BINDING_SYMBOL_TABLE_DEFINE_ENTRY(ClassName, sym) #sym,
+
+#define LATE_BINDING_SYMBOL_TABLE_DEFINE_END(ClassName) \
+  }                                                     \
+  ;
+
+// Index of a given symbol in the given symbol table class.
+#define LATESYM_INDEXOF(ClassName, sym) (ClassName##_SYMBOL_TABLE_INDEX_##sym)
+
+// Returns a reference to the given late-binded symbol, with the correct type.
+#define LATESYM_GET(ClassName, inst, sym) \
+  (*reinterpret_cast<__typeof__(&sym)>(   \
+      (inst)->GetSymbol(LATESYM_INDEXOF(ClassName, sym))))
+
+}  // namespace adm_qnx
+}  // namespace webrtc
+
+#endif  // ADM_LATEBINDINGSYMBOLTABLE_QNX_H_
-- 
2.34.1

