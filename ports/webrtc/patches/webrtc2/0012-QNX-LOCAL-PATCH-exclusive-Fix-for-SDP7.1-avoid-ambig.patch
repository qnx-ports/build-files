From 58df413037fc3253410bd4d47a85b517a269c167 Mon Sep 17 00:00:00 2001
From: Yongxin Dai <yodai@blackberry.com>
Date: Wed, 19 Feb 2025 20:39:19 -0500
Subject: [QNX LOCAL PATCH] exclusive Fix for SDP7.1: avoid ambiguous class
 name

all tests got compiled on SDP7 after this fix
---
 ...oder_software_fallback_wrapper_unittest.cc |  13 +-
 call/rtp_video_sender_unittest.cc             |  13 +-
 .../audio_processing_impl_unittest.cc         |   9 ++
 .../goog_cc_network_control_unittest.cc       |   4 +
 .../goog_cc/probe_controller_unittest.cc      | 117 +++++++++---------
 .../transport_feedback_adapter_unittest.cc    |  19 +--
 modules/pacing/pacing_controller_unittest.cc  |  31 +++--
 .../task_queue_paced_sender_unittest.cc       |  11 +-
 .../remote_ntp_time_estimator_unittest.cc     |   5 +
 .../source/rtp_sender_audio_unittest.cc       |  21 ++--
 .../source/rtp_sender_video_unittest.cc       |   9 +-
 .../codecs/test/video_codec_test.cc           |   5 +
 net/dcsctp/packet/sctp_packet_test.cc         |  11 +-
 net/dcsctp/rx/reassembly_queue_test.cc        |  11 +-
 net/dcsctp/socket/dcsctp_socket_test.cc       |  27 ++--
 .../socket/stream_reset_handler_test.cc       |  17 ++-
 net/dcsctp/tx/retransmission_queue_test.cc    |  13 +-
 test/network/simulated_network_unittest.cc    |  55 ++++----
 test/video_codec_tester_unittest.cc           |  51 ++++----
 .../config/encoder_stream_factory_unittest.cc |  29 +++--
 .../resolution_bitrate_limits_tests.cc        | 107 ++++++++--------
 video/full_stack_tests.cc                     |  23 ++--
 22 files changed, 362 insertions(+), 239 deletions(-)

diff --git a/api/video_codecs/test/video_encoder_software_fallback_wrapper_unittest.cc b/api/video_codecs/test/video_encoder_software_fallback_wrapper_unittest.cc
index c08b3e44ec..9a46daf467 100644
--- a/api/video_codecs/test/video_encoder_software_fallback_wrapper_unittest.cc
+++ b/api/video_codecs/test/video_encoder_software_fallback_wrapper_unittest.cc
@@ -48,6 +48,11 @@
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_ResolutionBasedFallbackTestParams ResolutionBasedFallbackTestParams
+#else
+#define EXPLICIT_TYPE_ResolutionBasedFallbackTestParams
+#endif
 
 using test::ExplicitKeyValueConfig;
 using ::testing::_;
@@ -1123,17 +1128,17 @@ INSTANTIATE_TEST_SUITE_P(
     VideoEncoderFallbackTest,
     ResolutionBasedFallbackTest,
     ValuesIn<ResolutionBasedFallbackTestParams>(
-        {{.test_name = "FallbackNotConfigured",
+        {EXPLICIT_TYPE_ResolutionBasedFallbackTestParams {.test_name = "FallbackNotConfigured",
           .expect_implementation_name = "primary"},
-         {.test_name = "ResolutionAboveFallbackThreshold",
+         EXPLICIT_TYPE_ResolutionBasedFallbackTestParams {.test_name = "ResolutionAboveFallbackThreshold",
           .field_trials = "WebRTC-Video-EncoderFallbackSettings/"
                           "resolution_threshold_px:255/",
           .expect_implementation_name = "primary"},
-         {.test_name = "ResolutionEqualFallbackThreshold",
+         EXPLICIT_TYPE_ResolutionBasedFallbackTestParams {.test_name = "ResolutionEqualFallbackThreshold",
           .field_trials = "WebRTC-Video-EncoderFallbackSettings/"
                           "resolution_threshold_px:256/",
           .expect_implementation_name = "fallback"},
-         {.test_name = "GenericFallbackSettingsTakePrecedence",
+         EXPLICIT_TYPE_ResolutionBasedFallbackTestParams {.test_name = "GenericFallbackSettingsTakePrecedence",
           .field_trials =
               "WebRTC-Video-EncoderFallbackSettings/"
               "resolution_threshold_px:255/"
diff --git a/call/rtp_video_sender_unittest.cc b/call/rtp_video_sender_unittest.cc
index b35b332fbf..fae12b85a3 100644
--- a/call/rtp_video_sender_unittest.cc
+++ b/call/rtp_video_sender_unittest.cc
@@ -73,6 +73,11 @@
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_VideoLayersAllocation VideoLayersAllocation
+#else
+#define EXPLICIT_TYPE_VideoLayersAllocation
+#endif
 
 using ::testing::_;
 using ::testing::Ge;
@@ -342,7 +347,7 @@ TEST(RtpVideoSenderTest,
   test.SetSending(true);
   // A layer is sent on both rtp streams.
   test.router()->OnVideoLayersAllocationUpdated(
-      {.active_spatial_layers = {{.rtp_stream_index = 0},
+      EXPLICIT_TYPE_VideoLayersAllocation {.active_spatial_layers = {{.rtp_stream_index = 0},
                                  {.rtp_stream_index = 1}}});
 
   EXPECT_EQ(EncodedImageCallback::Result::OK,
@@ -352,7 +357,7 @@ TEST(RtpVideoSenderTest,
 
   // Only rtp stream index 0 is configured to send a stream.
   test.router()->OnVideoLayersAllocationUpdated(
-      {.active_spatial_layers = {{.rtp_stream_index = 0}}});
+      EXPLICIT_TYPE_VideoLayersAllocation {.active_spatial_layers = {{.rtp_stream_index = 0}}});
   test.AdvanceTime(TimeDelta::Millis(33));
   EXPECT_EQ(EncodedImageCallback::Result::OK,
             test.router()->OnEncodedImage(encoded_image_1, &codec_info).error);
@@ -1457,14 +1462,14 @@ TEST(RtpVideoSenderTest,
   // Disable the 1st sending module and advance time slightly. No packets should
   // be sent.
   test.router()->OnVideoLayersAllocationUpdated(
-      {.active_spatial_layers = {{.rtp_stream_index = 1}}});
+      EXPLICIT_TYPE_VideoLayersAllocation {.active_spatial_layers = {{.rtp_stream_index = 1}}});
   test.AdvanceTime(TimeDelta::Millis(20));
   EXPECT_THAT(sent_packets, IsEmpty());
 
   // Reactive the send module - any packets should have been removed, so nothing
   // should be transmitted.
   test.router()->OnVideoLayersAllocationUpdated(
-      {.active_spatial_layers = {{.rtp_stream_index = 0},
+      EXPLICIT_TYPE_VideoLayersAllocation {.active_spatial_layers = {{.rtp_stream_index = 0},
                                  {.rtp_stream_index = 1}}});
   test.AdvanceTime(TimeDelta::Millis(33));
   EXPECT_THAT(sent_packets, IsEmpty());
diff --git a/modules/audio_processing/audio_processing_impl_unittest.cc b/modules/audio_processing/audio_processing_impl_unittest.cc
index d4503389fd..cdafd297fa 100644
--- a/modules/audio_processing/audio_processing_impl_unittest.cc
+++ b/modules/audio_processing/audio_processing_impl_unittest.cc
@@ -826,12 +826,21 @@ TEST(AudioProcessingImplTest,
 TEST(AudioProcessingImplTest,
      DISABLED_RecommendAppliedInputVolumeWithNoAgcWithEmulation) {
   auto apm = BuiltinAudioProcessingBuilder(
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+                 webrtc::AudioProcessing::Config {.capture_level_adjustment = {.enabled = true,
+                                               .analog_mic_gain_emulation{
+                                                   .enabled = true,
+                                                   .initial_level = 255}},
+                  .gain_controller1 = {.enabled = false}})
+                 .Build(CreateEnvironment());
+#else
                  {.capture_level_adjustment = {.enabled = true,
                                                .analog_mic_gain_emulation{
                                                    .enabled = true,
                                                    .initial_level = 255}},
                   .gain_controller1 = {.enabled = false}})
                  .Build(CreateEnvironment());
+#endif
 
   constexpr int kOneFrame = 1;
   EXPECT_EQ(ProcessInputVolume(*apm, kOneFrame, /*initial_volume=*/123), 123);
diff --git a/modules/congestion_controller/goog_cc/goog_cc_network_control_unittest.cc b/modules/congestion_controller/goog_cc/goog_cc_network_control_unittest.cc
index e34dfeedf0..3a8f583778 100644
--- a/modules/congestion_controller/goog_cc/goog_cc_network_control_unittest.cc
+++ b/modules/congestion_controller/goog_cc/goog_cc_network_control_unittest.cc
@@ -470,7 +470,11 @@ TEST(GoogCcNetworkControllerTest, PaceAtMaxOfLowerLinkCapacityAndBwe) {
   current_time += TimeDelta::Millis(100);
   // Set a low link capacity estimate and verify that pacing rate is set
   // relative to loss based/delay based estimate.
+  #if defined(WEBRTC_QNX) && __QNX__ < 800
+  network_estimate = NetworkStateEstimate {.link_capacity_lower = 0.5 * kInitialBitrate};
+  #else
   network_estimate = {.link_capacity_lower = 0.5 * kInitialBitrate};
+  #endif
   update = controller->OnNetworkStateEstimate(network_estimate);
   // Again, we need to inject a dummy loss report to trigger an update of the
   // BWE in the next process interval.
diff --git a/modules/congestion_controller/goog_cc/probe_controller_unittest.cc b/modules/congestion_controller/goog_cc/probe_controller_unittest.cc
index bb3c79c466..1d2242024b 100644
--- a/modules/congestion_controller/goog_cc/probe_controller_unittest.cc
+++ b/modules/congestion_controller/goog_cc/probe_controller_unittest.cc
@@ -33,6 +33,11 @@ namespace webrtc {
 namespace test {
 
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_NetworkAvailability NetworkAvailability
+#else
+#define EXPLICIT_TYPE_NetworkAvailability
+#endif
 
 constexpr DataRate kMinBitrate = DataRate::BitsPerSec(100);
 constexpr DataRate kStartBitrate = DataRate::BitsPerSec(300);
@@ -68,7 +73,7 @@ TEST(ProbeControllerTest, InitiatesProbingAfterSetBitrates) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -84,7 +89,7 @@ TEST(ProbeControllerTest, InitiatesProbingWhenNetworkAvailable) {
   std::vector<ProbeClusterConfig> probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
   EXPECT_THAT(probes, IsEmpty());
-  probes = probe_controller->OnNetworkAvailability({.network_available = true});
+  probes = probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true});
   EXPECT_GE(probes.size(), 2u);
 }
 
@@ -93,7 +98,7 @@ TEST(ProbeControllerTest, SetsDefaultTargetDurationAndTargetProbeCount) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   std::vector<ProbeClusterConfig> probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -111,7 +116,7 @@ TEST(ProbeControllerTest,
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   std::vector<ProbeClusterConfig> probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -140,7 +145,7 @@ TEST(ProbeControllerTest, CanConfigureInitialProbeRateFactor) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -154,7 +159,7 @@ TEST(ProbeControllerTest, DisableSecondInitialProbeIfRateFactorZero) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -167,7 +172,7 @@ TEST(ProbeControllerTest, InitiatesProbingOnMaxBitrateIncrease) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -189,7 +194,7 @@ TEST(ProbeControllerTest, ProbesOnMaxAllocatedBitrateIncreaseOnlyWhenInAlr) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -224,7 +229,7 @@ TEST(ProbeControllerTest, ProbesOnMaxAllocatedBitrateLimitedByCurrentBwe) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -259,7 +264,7 @@ TEST(ProbeControllerTest, CanDisableProbingOnMaxTotalAllocatedBitrateIncrease) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -283,7 +288,7 @@ TEST(ProbeControllerTest, InitiatesProbingOnMaxBitrateIncreaseAtMaxBitrate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -309,7 +314,7 @@ TEST(ProbeControllerTest, TestExponentialProbing) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -334,7 +339,7 @@ TEST(ProbeControllerTest, ExponentialProbingStopIfMaxBitrateLow) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -360,7 +365,7 @@ TEST(ProbeControllerTest, ExponentialProbingStopIfMaxAllocatedBitrateLow) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -384,7 +389,7 @@ TEST(ProbeControllerTest, InitialProbingToLowMaxAllocatedbitrate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -410,7 +415,7 @@ TEST(ProbeControllerTest, InitialProbingTimeout) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -431,7 +436,7 @@ TEST(ProbeControllerTest, RepeatedInitialProbingSendsNewProbeAfterTimeout) {
       fixture.CreateController();
   probe_controller->EnableRepeatedInitialProbing(true);
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -464,7 +469,7 @@ TEST(ProbeControllerTest, RepeatedInitialProbingStopIfMaxAllocatedBitrateSet) {
       fixture.CreateController();
   probe_controller->EnableRepeatedInitialProbing(true);
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -485,7 +490,7 @@ TEST(ProbeControllerTest, RequestProbeInAlr) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -511,7 +516,7 @@ TEST(ProbeControllerTest, RequestProbeWhenAlrEndedRecently) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -539,7 +544,7 @@ TEST(ProbeControllerTest, RequestProbeWhenAlrNotEndedRecently) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -565,7 +570,7 @@ TEST(ProbeControllerTest, RequestProbeWhenBweDropNotRecent) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -590,7 +595,7 @@ TEST(ProbeControllerTest, PeriodicProbing) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -637,7 +642,7 @@ TEST(ProbeControllerTest, PeriodicProbingAfterReset) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   Timestamp alr_start_time = fixture.CurrentTime();
 
@@ -672,7 +677,7 @@ TEST(ProbeControllerTest, NoProbesWhenTransportIsNotWritable) {
   probe_controller->EnablePeriodicAlrProbing(true);
 
   std::vector<ProbeClusterConfig> probes =
-      probe_controller->OnNetworkAvailability({.network_available = false});
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = false});
   EXPECT_THAT(probes, IsEmpty());
   EXPECT_THAT(probe_controller->SetBitrates(kMinBitrate, kStartBitrate,
                                             kMaxBitrate, fixture.CurrentTime()),
@@ -698,7 +703,7 @@ TEST(ProbeControllerTest, TestExponentialProbingOverflow) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   const DataRate kMbpsMultiplier = DataRate::KilobitsPerSec(1000);
   auto probes = probe_controller->SetBitrates(kMinBitrate, 10 * kMbpsMultiplier,
@@ -722,7 +727,7 @@ TEST(ProbeControllerTest, TestAllocatedBitrateCap) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   const DataRate kMbpsMultiplier = DataRate::KilobitsPerSec(1000);
   const DataRate kMaxBitrate = 100 * kMbpsMultiplier;
@@ -770,7 +775,7 @@ TEST(ProbeControllerTest, ConfigurableProbingFieldTrial) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(kMinBitrate, kStartBitrate,
@@ -810,7 +815,7 @@ TEST(ProbeControllerTest, LimitAlrProbeWhenLossBasedBweLimited) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -847,7 +852,7 @@ TEST(ProbeControllerTest, PeriodicProbeAtUpperNetworkStateEstimate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -878,7 +883,7 @@ TEST(ProbeControllerTest,
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -910,7 +915,7 @@ TEST(ProbeControllerTest, AlrProbesLimitedByNetworkStateEstimate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -941,7 +946,7 @@ TEST(ProbeControllerTest, CanSetLongerProbeDurationAfterNetworkStateEstimate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -966,7 +971,7 @@ TEST(ProbeControllerTest, ProbeInAlrIfLossBasedIncreasing) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -993,7 +998,7 @@ TEST(ProbeControllerTest, NotProbeWhenInAlrIfLossBasedDecreases) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -1019,7 +1024,7 @@ TEST(ProbeControllerTest, NotProbeIfLossBasedIncreasingOutsideAlr) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -1046,7 +1051,7 @@ TEST(ProbeControllerTest, ProbeFurtherWhenLossBasedIsSameAsDelayBasedEstimate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -1086,7 +1091,7 @@ TEST(ProbeControllerTest, ProbeIfEstimateLowerThanNetworkStateEstimate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -1133,7 +1138,7 @@ TEST(ProbeControllerTest, DontProbeFurtherWhenLossLimited) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -1166,7 +1171,7 @@ TEST(ProbeControllerTest, ProbeFurtherWhenDelayBasedLimited) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -1202,7 +1207,7 @@ TEST(ProbeControllerTest,
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -1247,14 +1252,14 @@ TEST(ProbeControllerTest, SkipProbeFurtherIfAlreadyProbedToMaxRate) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
   ASSERT_FALSE(probes.empty());
 
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = 2 * kMaxBitrate});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = 2 * kMaxBitrate});
 
   // Attempt to probe up to max rate.
   probes = probe_controller->SetEstimatedBitrate(
@@ -1284,7 +1289,7 @@ TEST(ProbeControllerTest, MaxAllocatedBitrateNotReset) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
@@ -1307,7 +1312,7 @@ TEST(ProbeControllerTest, SkipAlrProbeIfEstimateLargerThanMaxProbe) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -1338,7 +1343,7 @@ TEST(ProbeControllerTest,
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -1371,14 +1376,14 @@ TEST(ProbeControllerTest, SkipNetworkStateProbeIfEstimateLargerThanMaxProbe) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
   ASSERT_FALSE(probes.empty());
 
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = 2 * kMaxBitrate});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = 2 * kMaxBitrate});
   probes = probe_controller->SetEstimatedBitrate(
       kMaxBitrate, BandwidthLimitedCause::kDelayBasedLimited,
       fixture.CurrentTime());
@@ -1397,13 +1402,13 @@ TEST(ProbeControllerTest, SendsProbeIfNetworkStateEstimateLowerThanMaxProbe) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   auto probes = probe_controller->SetBitrates(
       kMinBitrate, kStartBitrate, kMaxBitrate, fixture.CurrentTime());
   ASSERT_FALSE(probes.empty());
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = 2 * kMaxBitrate});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = 2 * kMaxBitrate});
   probes = probe_controller->SetEstimatedBitrate(
       kMaxBitrate, BandwidthLimitedCause::kDelayBasedLimited,
       fixture.CurrentTime());
@@ -1417,7 +1422,7 @@ TEST(ProbeControllerTest, SendsProbeIfNetworkStateEstimateLowerThanMaxProbe) {
       fixture.CurrentTime());
   EXPECT_TRUE(probes.empty());
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = 2 * kStartBitrate});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = 2 * kStartBitrate});
   probes = probe_controller->Process(fixture.CurrentTime());
   EXPECT_FALSE(probes.empty());
 }
@@ -1430,7 +1435,7 @@ TEST(ProbeControllerTest,
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
   probe_controller->EnablePeriodicAlrProbing(true);
   auto probes = probe_controller->SetBitrates(
@@ -1439,7 +1444,7 @@ TEST(ProbeControllerTest,
       kStartBitrate, BandwidthLimitedCause::kDelayBasedLimited,
       fixture.CurrentTime());
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = kStartBitrate});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = kStartBitrate});
   // Need to wait at least one second before process can trigger a new probe.
   fixture.AdvanceTime(TimeDelta::Millis(1100));
   probes = probe_controller->Process(fixture.CurrentTime());
@@ -1447,7 +1452,7 @@ TEST(ProbeControllerTest,
 
   probe_controller->SetAlrStartTimeMs(fixture.CurrentTime().ms());
   probe_controller->SetNetworkStateEstimate(
-      {.link_capacity_upper = kStartBitrate / 2});
+      (webrtc::NetworkStateEstimate){.link_capacity_upper = kStartBitrate / 2});
   fixture.AdvanceTime(TimeDelta::Seconds(6));
   probes = probe_controller->Process(fixture.CurrentTime());
   ASSERT_FALSE(probes.empty());
@@ -1459,7 +1464,7 @@ TEST(ProbeControllerTest, DontProbeIfDelayIncreased) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
@@ -1489,7 +1494,7 @@ TEST(ProbeControllerTest, DontProbeIfHighRtt) {
   std::unique_ptr<ProbeController> probe_controller =
       fixture.CreateController();
   ASSERT_THAT(
-      probe_controller->OnNetworkAvailability({.network_available = true}),
+      probe_controller->OnNetworkAvailability(EXPLICIT_TYPE_NetworkAvailability {.network_available = true}),
       IsEmpty());
 
   auto probes = probe_controller->SetBitrates(
diff --git a/modules/congestion_controller/rtp/transport_feedback_adapter_unittest.cc b/modules/congestion_controller/rtp/transport_feedback_adapter_unittest.cc
index ca7ebc3e2c..8cf43c9e3f 100644
--- a/modules/congestion_controller/rtp/transport_feedback_adapter_unittest.cc
+++ b/modules/congestion_controller/rtp/transport_feedback_adapter_unittest.cc
@@ -36,6 +36,11 @@
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_PacketTemplate PacketTemplate
+#else
+#define EXPLICIT_TYPE_PacketTemplate
+#endif
 
 using ::testing::Bool;
 using ::testing::NotNull;
@@ -72,7 +77,7 @@ std::vector<PacketTemplate> CreatePacketTemplates(
     for (int rtp_sequence_number = ssrc * 10;
          rtp_sequence_number < static_cast<int>(ssrc * 10 + packets_per_ssrc);
          ++rtp_sequence_number) {
-      packets.push_back({
+      packets.push_back(EXPLICIT_TYPE_PacketTemplate {
           .ssrc = ssrc,
           .transport_sequence_number = transport_sequence_number++,
           .rtp_sequence_number = static_cast<uint16_t>(rtp_sequence_number),
@@ -316,15 +321,15 @@ TEST_P(TransportFeedbackAdapterTest, ReceiveTimeWrapsBothWays) {
       rtcp::TransportFeedback::kDeltaTick * (1 << 8) * ((1 << 23) - 1);
 
   std::vector<PacketTemplate> packets = {
-      {.transport_sequence_number = 0,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 0,
        .rtp_sequence_number = 102,
        .receive_timestamp =
            Timestamp::Zero() + kHighArrivalTime + TimeDelta::Millis(64)},
-      {.transport_sequence_number = 1,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 1,
        .rtp_sequence_number = 103,
        .receive_timestamp =
            Timestamp::Zero() + kHighArrivalTime - TimeDelta::Millis(64)},
-      {.transport_sequence_number = 2,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 2,
        .rtp_sequence_number = 104,
        .receive_timestamp = Timestamp::Zero() + kHighArrivalTime}};
 
@@ -368,15 +373,15 @@ TEST_P(TransportFeedbackAdapterTest, HandlesArrivalReordering) {
   TransportFeedbackAdapter adapter;
 
   std::vector<PacketTemplate> packets = {
-      {.transport_sequence_number = 0,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 0,
        .rtp_sequence_number = 101,
        .send_timestamp = Timestamp::Millis(200),
        .receive_timestamp = Timestamp::Millis(120)},
-      {.transport_sequence_number = 1,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 1,
        .rtp_sequence_number = 102,
        .send_timestamp = Timestamp::Millis(210),
        .receive_timestamp = Timestamp::Millis(110)},
-      {.transport_sequence_number = 2,
+      EXPLICIT_TYPE_PacketTemplate {.transport_sequence_number = 2,
        .rtp_sequence_number = 103,
        .send_timestamp = Timestamp::Millis(220),
        .receive_timestamp = Timestamp::Millis(100)}};
diff --git a/modules/pacing/pacing_controller_unittest.cc b/modules/pacing/pacing_controller_unittest.cc
index 38af5c7b7d..5809f593d2 100644
--- a/modules/pacing/pacing_controller_unittest.cc
+++ b/modules/pacing/pacing_controller_unittest.cc
@@ -47,6 +47,11 @@ using ::webrtc::test::ExplicitKeyValueConfig;
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_ProbeClusterConfig ProbeClusterConfig
+#else
+#define EXPLICIT_TYPE_ProbeClusterConfig
+#endif
 constexpr DataRate kFirstClusterRate = DataRate::KilobitsPerSec(900);
 constexpr DataRate kSecondClusterRate = DataRate::KilobitsPerSec(1800);
 
@@ -1186,12 +1191,12 @@ TEST_F(PacingControllerTest, ProbingWithInsertedPackets) {
   auto pacer =
       std::make_unique<PacingController>(&clock_, &packet_sender, trials_);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
        .id = 0},
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kSecondClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1264,7 +1269,7 @@ TEST_F(PacingControllerTest, SkipsProbesWhenProcessIntervalTooLarge) {
 
   // Probe at a very high rate.
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = DataRate::KilobitsPerSec(10000),  // 10 Mbps,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1334,7 +1339,7 @@ TEST_F(PacingControllerTest, ProbingWithPaddingSupport) {
   auto pacer =
       std::make_unique<PacingController>(&clock_, &packet_sender, trials_);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1378,7 +1383,7 @@ TEST_F(PacingControllerTest, CanProbeWithPaddingBeforeFirstMediaPacket) {
       std::make_unique<PacingController>(&clock_, &packet_sender, trials_);
   pacer->SetAllowProbeWithoutMediaPacket(true);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1407,7 +1412,7 @@ TEST_F(PacingControllerTest, ProbeSentAfterSetAllowProbeWithoutMediaPacket) {
   auto pacer =
       std::make_unique<PacingController>(&clock_, &packet_sender, trials_);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1441,7 +1446,7 @@ TEST_F(PacingControllerTest, CanNotProbeWithPaddingIfGeneratePaddingFails) {
       std::make_unique<PacingController>(&clock_, &packet_sender, trials_);
   pacer->SetAllowProbeWithoutMediaPacket(true);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1515,12 +1520,12 @@ TEST_F(PacingControllerTest, ProbeClusterId) {
 
   auto pacer = std::make_unique<PacingController>(&clock_, &callback, trials_);
   pacer->CreateProbeClusters(std::vector<ProbeClusterConfig>(
-      {{.at_time = clock_.CurrentTime(),
+      {EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
         .target_data_rate = kFirstClusterRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 5,
         .id = 0},
-       {.at_time = clock_.CurrentTime(),
+       EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
         .target_data_rate = kSecondClusterRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 5,
@@ -1633,7 +1638,7 @@ TEST_F(PacingControllerTest, SmallFirstProbePacket) {
   MockPacketSender callback;
   auto pacer = std::make_unique<PacingController>(&clock_, &callback, trials_);
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = kFirstClusterRate,
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
@@ -1721,12 +1726,12 @@ TEST_F(PacingControllerTest, NoProbingWhilePaused) {
   pacer->SetProbingEnabled(true);
   pacer->SetPacingRates(kTargetRate * kPaceMultiplier, DataRate::Zero());
   pacer->CreateProbeClusters(std::vector<ProbeClusterConfig>(
-      {{.at_time = clock_.CurrentTime(),
+      {EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
         .target_data_rate = kFirstClusterRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 5,
         .id = 0},
-       {.at_time = clock_.CurrentTime(),
+       EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
         .target_data_rate = kSecondClusterRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 5,
@@ -1742,7 +1747,7 @@ TEST_F(PacingControllerTest, NoProbingWhilePaused) {
 
   // Trigger probing.
   std::vector<ProbeClusterConfig> probe_clusters = {
-      {.at_time = clock_.CurrentTime(),
+      EXPLICIT_TYPE_ProbeClusterConfig {.at_time = clock_.CurrentTime(),
        .target_data_rate = DataRate::KilobitsPerSec(10000),  // 10 Mbps.
        .target_duration = TimeDelta::Millis(15),
        .target_probe_count = 5,
diff --git a/modules/pacing/task_queue_paced_sender_unittest.cc b/modules/pacing/task_queue_paced_sender_unittest.cc
index 061cf1dd26..57c58f91e1 100644
--- a/modules/pacing/task_queue_paced_sender_unittest.cc
+++ b/modules/pacing/task_queue_paced_sender_unittest.cc
@@ -40,6 +40,11 @@ using ::testing::NiceMock;
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_ProbeClusterConfig ProbeClusterConfig
+#else
+#define EXPLICIT_TYPE_ProbeClusterConfig
+#endif
 constexpr uint32_t kAudioSsrc = 12345;
 constexpr uint32_t kVideoSsrc = 234565;
 constexpr uint32_t kVideoRtxSsrc = 34567;
@@ -350,7 +355,7 @@ TEST(TaskQueuePacedSenderTest, ProbingOverridesCoalescingWindow) {
   // are clear. This will also trigger the probe to start.
   EXPECT_CALL(packet_router, SendPacket).Times(AtLeast(1));
   pacer.CreateProbeClusters(
-      {{.at_time = time_controller.GetClock()->CurrentTime(),
+      {EXPLICIT_TYPE_ProbeClusterConfig {.at_time = time_controller.GetClock()->CurrentTime(),
         .target_data_rate = kPacingDataRate * 2,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 5,
@@ -404,7 +409,7 @@ TEST(TaskQueuePacedSenderTest, SchedulesProbeAtSentTime) {
   const DataRate kProbeRate = 2 * kPacingDataRate;
   const int kProbeClusterId = 1;
   pacer.CreateProbeClusters(
-      {{.at_time = time_controller.GetClock()->CurrentTime(),
+      {EXPLICIT_TYPE_ProbeClusterConfig {.at_time = time_controller.GetClock()->CurrentTime(),
         .target_data_rate = kProbeRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 4,
@@ -630,7 +635,7 @@ TEST(TaskQueuePacedSenderTest, ProbingStopDuringSendLoop) {
   const DataRate kProbingRate = kPacingDataRate;
 
   pacer.CreateProbeClusters(
-      {{.at_time = time_controller.GetClock()->CurrentTime(),
+      {EXPLICIT_TYPE_ProbeClusterConfig {.at_time = time_controller.GetClock()->CurrentTime(),
         .target_data_rate = kProbingRate,
         .target_duration = TimeDelta::Millis(15),
         .target_probe_count = 4,
diff --git a/modules/rtp_rtcp/source/remote_ntp_time_estimator_unittest.cc b/modules/rtp_rtcp/source/remote_ntp_time_estimator_unittest.cc
index e9e8ce9fcc..360ddc7232 100644
--- a/modules/rtp_rtcp/source/remote_ntp_time_estimator_unittest.cc
+++ b/modules/rtp_rtcp/source/remote_ntp_time_estimator_unittest.cc
@@ -25,8 +25,13 @@ constexpr TimeDelta kTestRtt = TimeDelta::Millis(10);
 constexpr Timestamp kLocalClockInitialTime = Timestamp::Millis(123);
 constexpr Timestamp kRemoteClockInitialTime = Timestamp::Millis(373);
 constexpr uint32_t kTimestampOffset = 567;
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+int64_t kRemoteToLocalClockOffsetNtp =
+    ToNtpUnits(kLocalClockInitialTime - kRemoteClockInitialTime);
+#else
 constexpr int64_t kRemoteToLocalClockOffsetNtp =
     ToNtpUnits(kLocalClockInitialTime - kRemoteClockInitialTime);
+#endif
 
 class RemoteNtpTimeEstimatorTest : public ::testing::Test {
  protected:
diff --git a/modules/rtp_rtcp/source/rtp_sender_audio_unittest.cc b/modules/rtp_rtcp/source/rtp_sender_audio_unittest.cc
index e86401e23e..246d916932 100644
--- a/modules/rtp_rtcp/source/rtp_sender_audio_unittest.cc
+++ b/modules/rtp_rtcp/source/rtp_sender_audio_unittest.cc
@@ -27,6 +27,11 @@
 namespace webrtc {
 
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_RtpAudioFrame RTPSenderAudio::RtpAudioFrame
+#else
+#define EXPLICIT_TYPE_RtpAudioFrame
+#endif
 enum : int {  // The first valid value is 1.
   kAudioLevelExtensionId = 1,
   kAbsoluteCaptureTimeExtensionId = 2,
@@ -69,7 +74,7 @@ class RtpSenderAudioTest : public ::testing::Test {
       : fake_clock_(kStartTime),
         env_(CreateEnvironment(&fake_clock_)),
         rtp_module_(env_,
-                    {.audio = true,
+                    (const RtpRtcpInterface::Configuration&){.audio = true,
                      .outgoing_transport = &transport_,
                      .local_media_ssrc = kSsrc}),
         rtp_sender_audio_(
@@ -94,7 +99,7 @@ TEST_F(RtpSenderAudioTest, SendAudio) {
   uint8_t payload[] = {47, 11, 32, 93, 89};
 
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.payload = payload, .payload_id = payload_type}));
+       EXPLICIT_TYPE_RtpAudioFrame {.payload = payload, .payload_id = payload_type}));
 
   auto sent_payload = transport_.last_sent_packet().payload();
   EXPECT_THAT(sent_payload, ElementsAreArray(payload));
@@ -137,7 +142,7 @@ TEST_F(RtpSenderAudioTest, SendAudioWithoutAbsoluteCaptureTime) {
   uint8_t payload[] = {47, 11, 32, 93, 89};
 
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.payload = payload,
+      EXPLICIT_TYPE_RtpAudioFrame {.payload = payload,
        .payload_id = payload_type,
        .capture_time = kAbsoluteCaptureTimestamp}));
 
@@ -158,7 +163,7 @@ TEST_F(RtpSenderAudioTest,
   uint8_t payload[] = {47, 11, 32, 93, 89};
 
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.payload = payload,
+      EXPLICIT_TYPE_RtpAudioFrame {.payload = payload,
        .payload_id = payload_type,
        .capture_time = kAbsoluteCaptureTimestamp}));
 
@@ -197,7 +202,7 @@ TEST_F(RtpSenderAudioTest, CheckMarkerBitForTelephoneEvents) {
   // The duration is calculated as the difference of current and last sent
   // timestamp. So for first call it will skip since the duration is zero.
   ASSERT_TRUE(
-      rtp_sender_audio_->SendAudio({.type = AudioFrameType::kEmptyFrame,
+      rtp_sender_audio_->SendAudio(EXPLICIT_TYPE_RtpAudioFrame {.type = AudioFrameType::kEmptyFrame,
                                     .payload_id = kPayloadType,
                                     .rtp_timestamp = capture_timestamp}));
 
@@ -205,7 +210,7 @@ TEST_F(RtpSenderAudioTest, CheckMarkerBitForTelephoneEvents) {
   // So in this case, it is (8000/1000) * 500 = 4000.
   // Sending it as two packets.
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.type = AudioFrameType::kEmptyFrame,
+      EXPLICIT_TYPE_RtpAudioFrame {.type = AudioFrameType::kEmptyFrame,
        .payload_id = kPayloadType,
        .rtp_timestamp = capture_timestamp + 2000}));
 
@@ -213,7 +218,7 @@ TEST_F(RtpSenderAudioTest, CheckMarkerBitForTelephoneEvents) {
   EXPECT_TRUE(transport_.last_sent_packet().Marker());
 
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.type = AudioFrameType::kEmptyFrame,
+      EXPLICIT_TYPE_RtpAudioFrame {.type = AudioFrameType::kEmptyFrame,
        .payload_id = kPayloadType,
        .rtp_timestamp = capture_timestamp + 4000}));
 
@@ -231,7 +236,7 @@ TEST_F(RtpSenderAudioTest, SendsCsrcs) {
   std::vector<uint32_t> csrcs({123, 456, 789});
 
   ASSERT_TRUE(rtp_sender_audio_->SendAudio(
-      {.payload = payload, .payload_id = payload_type, .csrcs = csrcs}));
+      EXPLICIT_TYPE_RtpAudioFrame {.payload = payload, .payload_id = payload_type, .csrcs = csrcs}));
 
   EXPECT_EQ(transport_.last_sent_packet().Csrcs(), csrcs);
 }
diff --git a/modules/rtp_rtcp/source/rtp_sender_video_unittest.cc b/modules/rtp_rtcp/source/rtp_sender_video_unittest.cc
index cadda289ef..f3875cf4f3 100644
--- a/modules/rtp_rtcp/source/rtp_sender_video_unittest.cc
+++ b/modules/rtp_rtcp/source/rtp_sender_video_unittest.cc
@@ -58,6 +58,11 @@
 namespace webrtc {
 
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_Configuration RtpRtcpInterface::Configuration
+#else
+#define EXPLICIT_TYPE_Configuration
+#endif
 
 using ::testing::_;
 using ::testing::ContainerEq;
@@ -171,7 +176,7 @@ class RtpSenderVideoTest : public ::testing::Test {
         retransmission_rate_limiter_(&fake_clock_, 1000),
         rtp_module_(
             env_,
-            {.outgoing_transport = &transport_,
+            EXPLICIT_TYPE_Configuration {.outgoing_transport = &transport_,
              .retransmission_rate_limiter = &retransmission_rate_limiter_,
              .local_media_ssrc = kSsrc,
              .rtx_send_ssrc = kRtxSsrc,
@@ -1525,7 +1530,7 @@ class RtpSenderVideoWithFrameTransformerTest : public ::testing::Test {
         retransmission_rate_limiter_(time_controller_.GetClock(), 1000),
         rtp_module_(
             env_,
-            {.outgoing_transport = &transport_,
+            EXPLICIT_TYPE_Configuration {.outgoing_transport = &transport_,
              .retransmission_rate_limiter = &retransmission_rate_limiter_,
              .local_media_ssrc = kSsrc}) {
     rtp_module_.SetSequenceNumber(kSeqNum);
diff --git a/modules/video_coding/codecs/test/video_codec_test.cc b/modules/video_coding/codecs/test/video_codec_test.cc
index 48d6becf57..3445c8e87b 100644
--- a/modules/video_coding/codecs/test/video_codec_test.cc
+++ b/modules/video_coding/codecs/test/video_codec_test.cc
@@ -619,8 +619,13 @@ TEST(VideoCodecTest, DISABLED_EncodeDecode) {
     for (int tidx = 0; tidx < num_temporal_layers; ++tidx) {
       std::string metric_name_prefix =
           (rtc::StringBuilder() << "s" << sidx << "t" << tidx << "_").str();
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+      stream = stats->Aggregate(
+          Filter {.layer_id = {{.spatial_idx = sidx, .temporal_idx = tidx}}});
+#else
       stream = stats->Aggregate(
           {.layer_id = {{.spatial_idx = sidx, .temporal_idx = tidx}}});
+#endif
       stream.LogMetrics(GetGlobalMetricsLogger(), TestName(),
                         metric_name_prefix,
                         /*metadata=*/{});
diff --git a/net/dcsctp/packet/sctp_packet_test.cc b/net/dcsctp/packet/sctp_packet_test.cc
index aab01df19c..7340ce3a1f 100644
--- a/net/dcsctp/packet/sctp_packet_test.cc
+++ b/net/dcsctp/packet/sctp_packet_test.cc
@@ -32,6 +32,11 @@
 
 namespace dcsctp {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_DcSctpOptions DcSctpOptions
+#else
+#define EXPLICIT_TYPE_DcSctpOptions
+#endif
 using ::testing::ElementsAre;
 using ::testing::SizeIs;
 
@@ -210,7 +215,7 @@ TEST(SctpPacketTest, DeserializePacketDontValidateChecksum) {
   ASSERT_HAS_VALUE_AND_ASSIGN(
       SctpPacket packet,
       SctpPacket::Parse(
-          data, {.disable_checksum_verification = true,
+          data, EXPLICIT_TYPE_DcSctpOptions {.disable_checksum_verification = true,
                  .zero_checksum_alternate_error_detection_method =
                      ZeroChecksumAlternateErrorDetectionMethod::None()}));
   EXPECT_EQ(packet.common_header().source_port, 5000);
@@ -380,7 +385,7 @@ TEST(SctpPacketTest, AcceptsZeroSetZeroChecksum) {
       SctpPacket packet,
       SctpPacket::Parse(
           data,
-          {.disable_checksum_verification = false,
+          EXPLICIT_TYPE_DcSctpOptions {.disable_checksum_verification = false,
            .zero_checksum_alternate_error_detection_method =
                ZeroChecksumAlternateErrorDetectionMethod::LowerLayerDtls()}));
   EXPECT_EQ(packet.common_header().source_port, 5000);
@@ -418,7 +423,7 @@ TEST(SctpPacketTest, RejectsNonZeroIncorrectChecksumWhenZeroChecksumIsActive) {
   EXPECT_FALSE(
       SctpPacket::Parse(
           data,
-          {.disable_checksum_verification = false,
+          EXPLICIT_TYPE_DcSctpOptions {.disable_checksum_verification = false,
            .zero_checksum_alternate_error_detection_method =
                ZeroChecksumAlternateErrorDetectionMethod::LowerLayerDtls()})
           .has_value());
diff --git a/net/dcsctp/rx/reassembly_queue_test.cc b/net/dcsctp/rx/reassembly_queue_test.cc
index b0b2c063fd..4c4ec053fb 100644
--- a/net/dcsctp/rx/reassembly_queue_test.cc
+++ b/net/dcsctp/rx/reassembly_queue_test.cc
@@ -31,6 +31,11 @@
 
 namespace dcsctp {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_DataGeneratorOptions DataGeneratorOptions
+#else
+#define EXPLICIT_TYPE_DataGeneratorOptions
+#endif
 using ::testing::ElementsAre;
 using ::testing::SizeIs;
 using ::testing::UnorderedElementsAre;
@@ -254,8 +259,8 @@ TEST_F(ReassemblyQueueTest, ForwardTSNRemoveALotOrdered) {
 
 TEST_F(ReassemblyQueueTest, NotReadyForHandoverWhenResetStreamIsDeferred) {
   ReassemblyQueue reasm("log: ", kBufferSize);
-  reasm.Add(TSN(10), gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(0)}));
-  reasm.Add(TSN(11), gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(1)}));
+  reasm.Add(TSN(10), gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0)}));
+  reasm.Add(TSN(11), gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(1)}));
   EXPECT_THAT(reasm.FlushMessages(), SizeIs(2));
 
   reasm.EnterDeferredReset(TSN(12), std::vector<StreamID>({StreamID(1)}));
@@ -263,7 +268,7 @@ TEST_F(ReassemblyQueueTest, NotReadyForHandoverWhenResetStreamIsDeferred) {
             HandoverReadinessStatus().Add(
                 HandoverUnreadinessReason::kStreamResetDeferred));
 
-  reasm.Add(TSN(12), gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(2)}));
+  reasm.Add(TSN(12), gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(2)}));
 
   reasm.ResetStreamsAndLeaveDeferredReset(std::vector<StreamID>({StreamID(1)}));
   EXPECT_EQ(reasm.GetHandoverReadiness(), HandoverReadinessStatus());
diff --git a/net/dcsctp/socket/dcsctp_socket_test.cc b/net/dcsctp/socket/dcsctp_socket_test.cc
index 8413c05db6..6096cccd6d 100644
--- a/net/dcsctp/socket/dcsctp_socket_test.cc
+++ b/net/dcsctp/socket/dcsctp_socket_test.cc
@@ -63,6 +63,13 @@ ABSL_FLAG(bool, dcsctp_capture_packets, false, "Print packet capture.");
 
 namespace dcsctp {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_SendOptions SendOptions
+#define EXPLICIT_TYPE_DcSctpOptions DcSctpOptions
+#else
+#define EXPLICIT_TYPE_SendOptions
+#define EXPLICIT_TYPE_DcSctpOptions
+#endif
 using ::testing::_;
 using ::testing::AllOf;
 using ::testing::ElementsAre;
@@ -2638,7 +2645,7 @@ TEST(DcSctpSocketTest, LifecycleEventsAreGeneratedForAckedMessages) {
 
   a.socket.Send(DcSctpMessage(StreamID(2), PPID(101),
                               std::vector<uint8_t>(kLargeMessageSize)),
-                {.lifecycle_id = LifecycleId(41)});
+                EXPLICIT_TYPE_SendOptions {.lifecycle_id = LifecycleId(41)});
 
   a.socket.Send(DcSctpMessage(StreamID(2), PPID(102),
                               std::vector<uint8_t>(kLargeMessageSize)),
@@ -2646,7 +2653,7 @@ TEST(DcSctpSocketTest, LifecycleEventsAreGeneratedForAckedMessages) {
 
   a.socket.Send(DcSctpMessage(StreamID(2), PPID(103),
                               std::vector<uint8_t>(kLargeMessageSize)),
-                {.lifecycle_id = LifecycleId(42)});
+                EXPLICIT_TYPE_SendOptions {.lifecycle_id = LifecycleId(42)});
 
   EXPECT_CALL(a.cb, OnLifecycleMessageDelivered(LifecycleId(41)));
   EXPECT_CALL(a.cb, OnLifecycleEnd(LifecycleId(41)));
@@ -2667,17 +2674,17 @@ TEST(DcSctpSocketTest, LifecycleEventsForFailMaxRetransmissions) {
 
   std::vector<uint8_t> payload(a.options.mtu - 100);
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(51), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .max_retransmissions = 0,
                     .lifecycle_id = LifecycleId(1),
                 });
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(52), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .max_retransmissions = 0,
                     .lifecycle_id = LifecycleId(2),
                 });
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(53), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .max_retransmissions = 0,
                     .lifecycle_id = LifecycleId(3),
                 });
@@ -2720,7 +2727,7 @@ TEST(DcSctpSocketTest, LifecycleEventsForExpiredMessageWithRetransmitLimit) {
   // need to wait for SACKs to be received for more fragments to be sent.
   std::vector<uint8_t> payload(kLargeMessageSize);
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(51), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .max_retransmissions = 0,
                     .lifecycle_id = LifecycleId(1),
                 });
@@ -2747,7 +2754,7 @@ TEST(DcSctpSocketTest, LifecycleEventsForExpiredMessageWithLifetimeLimit) {
   // send it in full.
   std::vector<uint8_t> payload(kSmallMessageSize);
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(51), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .lifetime = DurationMs(100),
                     .lifecycle_id = LifecycleId(1),
                 });
@@ -3103,13 +3110,13 @@ TEST_P(DcSctpSocketParametrizedTest, AllPacketsAfterConnectHaveZeroChecksum) {
 TEST(DcSctpSocketTest, HandlesForwardTsnOutOfOrderWithStreamResetting) {
   // This test ensures that receiving FORWARD-TSN and RECONFIG out of order is
   // handled correctly.
-  SocketUnderTest a("A", {.heartbeat_interval = DurationMs(0)});
-  SocketUnderTest z("Z", {.heartbeat_interval = DurationMs(0)});
+  SocketUnderTest a("A", EXPLICIT_TYPE_DcSctpOptions {.heartbeat_interval = DurationMs(0)});
+  SocketUnderTest z("Z", EXPLICIT_TYPE_DcSctpOptions {.heartbeat_interval = DurationMs(0)});
 
   ConnectSockets(a, z);
   std::vector<uint8_t> payload(kSmallMessageSize);
   a.socket.Send(DcSctpMessage(StreamID(1), PPID(51), payload),
-                {
+                EXPLICIT_TYPE_SendOptions {
                     .max_retransmissions = 0,
                 });
 
diff --git a/net/dcsctp/socket/stream_reset_handler_test.cc b/net/dcsctp/socket/stream_reset_handler_test.cc
index 480acbe51e..54f0b3b5bc 100644
--- a/net/dcsctp/socket/stream_reset_handler_test.cc
+++ b/net/dcsctp/socket/stream_reset_handler_test.cc
@@ -42,6 +42,11 @@
 
 namespace dcsctp {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_DataGeneratorOptions DataGeneratorOptions
+#else
+#define EXPLICIT_TYPE_DataGeneratorOptions
+#endif
 using ::testing::IsEmpty;
 using ::testing::NiceMock;
 using ::testing::Property;
@@ -293,10 +298,10 @@ TEST_F(StreamResetHandlerTest, ResetStreamsNotDeferred) {
 TEST_F(StreamResetHandlerTest, ResetStreamsDeferred) {
   constexpr StreamID kStreamId = StreamID(1);
   data_tracker_->Observe(TSN(10));
-  reasm_->Add(TSN(10), gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(0)}));
+  reasm_->Add(TSN(10), gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0)}));
 
   data_tracker_->Observe(TSN(11));
-  reasm_->Add(TSN(11), gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(1)}));
+  reasm_->Add(TSN(11), gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(1)}));
 
   EXPECT_THAT(
       reasm_->FlushMessages(),
@@ -312,19 +317,19 @@ TEST_F(StreamResetHandlerTest, ResetStreamsDeferred) {
 
   data_tracker_->Observe(TSN(15));
   reasm_->Add(TSN(15), gen_.Ordered({1, 2, 3, 4}, "BE",
-                                    {.mid = MID(1), .ppid = PPID(5)}));
+                                    EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(1), .ppid = PPID(5)}));
 
   data_tracker_->Observe(TSN(14));
   reasm_->Add(TSN(14), gen_.Ordered({1, 2, 3, 4}, "BE",
-                                    {.mid = MID(0), .ppid = PPID(4)}));
+                                    EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0), .ppid = PPID(4)}));
 
   data_tracker_->Observe(TSN(13));
   reasm_->Add(TSN(13), gen_.Ordered({1, 2, 3, 4}, "BE",
-                                    {.mid = MID(3), .ppid = PPID(3)}));
+                                    EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(3), .ppid = PPID(3)}));
 
   data_tracker_->Observe(TSN(12));
   reasm_->Add(TSN(12), gen_.Ordered({1, 2, 3, 4}, "BE",
-                                    {.mid = MID(2), .ppid = PPID(2)}));
+                                    EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(2), .ppid = PPID(2)}));
 
   builder.Add(OutgoingSSNResetRequestParameter(
       ReconfigRequestSN(11), ReconfigRequestSN(4), TSN(13), {kStreamId}));
diff --git a/net/dcsctp/tx/retransmission_queue_test.cc b/net/dcsctp/tx/retransmission_queue_test.cc
index cc68a9b725..22b9ba9a19 100644
--- a/net/dcsctp/tx/retransmission_queue_test.cc
+++ b/net/dcsctp/tx/retransmission_queue_test.cc
@@ -41,6 +41,11 @@
 
 namespace dcsctp {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_DataGeneratorOptions DataGeneratorOptions
+#else
+#define EXPLICIT_TYPE_DataGeneratorOptions
+#endif
 using ::testing::MockFunction;
 using State = ::dcsctp::RetransmissionQueue::State;
 using ::testing::_;
@@ -1125,14 +1130,14 @@ TEST_F(RetransmissionQueueTest, ExpireCorrectMessageFromSendQueue) {
       .WillOnce([&](Timestamp, size_t) {
         SendQueue::DataToSend dts(
             OutgoingMessageId(42),
-            gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(0)}));
+            gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0)}));
         dts.expires_at = Timestamp(test_start + TimeDelta::Millis(10));
         return dts;
       })
       .WillOnce([&](Timestamp, size_t) {
         SendQueue::DataToSend dts(
             OutgoingMessageId(43),
-            gen_.Ordered({1, 2, 3, 4}, "BE", {.mid = MID(1)}));
+            gen_.Ordered({1, 2, 3, 4}, "BE", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(1)}));
         dts.expires_at = Timestamp(test_start + TimeDelta::Millis(10));
         return dts;
       })
@@ -1140,14 +1145,14 @@ TEST_F(RetransmissionQueueTest, ExpireCorrectMessageFromSendQueue) {
       .WillOnce([&](Timestamp, size_t) {
         SendQueue::DataToSend dts(
             OutgoingMessageId(44),
-            gen_.Ordered({1, 2, 3, 4}, "B", {.mid = MID(0)}));
+            gen_.Ordered({1, 2, 3, 4}, "B", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0)}));
         dts.expires_at = Timestamp(test_start + TimeDelta::Millis(10));
         return dts;
       })
       .WillOnce([&](Timestamp, size_t) {
         SendQueue::DataToSend dts(
             OutgoingMessageId(44),
-            gen_.Ordered({5, 6, 7, 8}, "", {.mid = MID(0)}));
+            gen_.Ordered({5, 6, 7, 8}, "", EXPLICIT_TYPE_DataGeneratorOptions {.mid = MID(0)}));
         dts.expires_at = Timestamp(test_start + TimeDelta::Millis(10));
         return dts;
       })
diff --git a/test/network/simulated_network_unittest.cc b/test/network/simulated_network_unittest.cc
index 21d70ecec9..bfc2b3812e 100644
--- a/test/network/simulated_network_unittest.cc
+++ b/test/network/simulated_network_unittest.cc
@@ -26,6 +26,11 @@
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_Config SimulatedNetwork::Config
+#else
+#define EXPLICIT_TYPE_Config
+#endif
 
 using ::testing::ElementsAre;
 using ::testing::MockFunction;
@@ -53,7 +58,7 @@ TEST(SimulatedNetworkTest, EnqueueFirstPacketOnNetworkWithLimitedCapacity) {
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps capacity
   // should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(PacketWithSize(125)));
 
   EXPECT_EQ(network.NextDeliveryTimeUs(), TimeDelta::Seconds(1).us());
@@ -64,7 +69,7 @@ TEST(SimulatedNetworkTest,
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps capacity
   // should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1)));
   EXPECT_EQ(network.NextDeliveryTimeUs(), TimeDelta::Seconds(1).us());
@@ -85,7 +90,7 @@ TEST(SimulatedNetworkTest,
 
 TEST(SimulatedNetworkTest, EnqueueFailsWhenQueueLengthIsReached) {
   SimulatedNetwork network =
-      SimulatedNetwork({.queue_length_packets = 1,
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.queue_length_packets = 1,
                         .link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1)));
@@ -114,7 +119,7 @@ TEST(SimulatedNetworkTest, PacketOverhead) {
   // should be ready to exit the network in 1 second, but since there is an
   // overhead per packet of 125 bytes, it will exit the network after 2 seconds.
   SimulatedNetwork network = SimulatedNetwork(
-      {.link_capacity = DataRate::KilobitsPerSec(1), .packet_overhead = 125});
+    EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1), .packet_overhead = 125});
   ASSERT_TRUE(network.EnqueuePacket(PacketWithSize(125)));
 
   EXPECT_EQ(network.NextDeliveryTimeUs(), TimeDelta::Seconds(2).us());
@@ -125,7 +130,7 @@ TEST(SimulatedNetworkTest,
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps capacity
   // should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1)));
   // Enqueue another packet of 125 bytes (this one should exit after 2 seconds).
@@ -156,7 +161,7 @@ TEST(SimulatedNetworkTest,
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps capacity
   // should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   const PacketInFlightInfo packet_1 =
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1);
   ASSERT_TRUE(network.EnqueuePacket(packet_1));
@@ -175,7 +180,7 @@ TEST(SimulatedNetworkTest,
 
   // Since the link capacity changes from 1 kbps to 10 kbps, packets will take
   // 100 ms each to leave the network.
-  network.SetConfig({.link_capacity = DataRate::KilobitsPerSec(10)});
+  network.SetConfig(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(10)});
 
   // The next delivery time doesn't change (it will be updated, if needed at
   // DequeueDeliverablePackets time).
@@ -208,7 +213,7 @@ TEST(SimulatedNetworkTest,
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps capacity
   // should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   MockFunction<void()> delivery_time_changed_callback;
   network.RegisterDeliveryTimeChangedCallback(
       delivery_time_changed_callback.AsStdFunction());
@@ -223,14 +228,14 @@ TEST(SimulatedNetworkTest,
   EXPECT_CALL(delivery_time_changed_callback, Call).WillOnce([&]() {
     EXPECT_EQ(network.NextDeliveryTimeUs(), TimeDelta::Millis(500 + 50).us());
   });
-  network.SetConfig({.link_capacity = DataRate::KilobitsPerSec(10)},
+  network.SetConfig(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(10)},
                     /*config_update_time*/ Timestamp::Millis(500));
 }
 
 TEST(SimulatedNetworkTest,
      SetConfigUpdateNextDeliveryTimeIfLinkCapacityChangeFromZero) {
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::Zero()});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::Zero()});
   MockFunction<void()> delivery_time_changed_callback;
   network.RegisterDeliveryTimeChangedCallback(
       delivery_time_changed_callback.AsStdFunction());
@@ -262,11 +267,11 @@ TEST(SimulatedNetworkTest,
         EXPECT_EQ(network.NextDeliveryTimeUs(),
                   TimeDelta::Millis(610 + 90).us());
       });
-  network.SetConfig({.link_capacity = DataRate::KilobitsPerSec(10)},
+  network.SetConfig(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(10)},
                     /*config_update_time*/ Timestamp::Millis(500));
-  network.SetConfig({.link_capacity = DataRate::Zero()},
+  network.SetConfig(EXPLICIT_TYPE_Config {.link_capacity = DataRate::Zero()},
                     /*config_update_time*/ Timestamp::Millis(510));
-  network.SetConfig({.link_capacity = DataRate::KilobitsPerSec(10)},
+  network.SetConfig(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(10)},
                     /*config_update_time*/ Timestamp::Millis(610));
 }
 
@@ -274,7 +279,7 @@ TEST(SimulatedNetworkTest, SetConfigUpdateQueueDelayAfterDelivery) {
   // A packet of 125 bytes that gets enqueued on a network with 1000 kbps
   // capacity should be ready to exit the narrow section in 1 ms.
   SimulatedNetwork network =
-      SimulatedNetwork({.queue_delay_ms = 1000,
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.queue_delay_ms = 1000,
                         .link_capacity = DataRate::KilobitsPerSec(1000)});
   MockFunction<void()> delivery_time_changed_callback;
   network.RegisterDeliveryTimeChangedCallback(
@@ -293,7 +298,7 @@ TEST(SimulatedNetworkTest, SetConfigUpdateQueueDelayAfterDelivery) {
 
   // Changing the queue time does not change the next delivery time.
   network.SetConfig(
-      {.queue_delay_ms = 1, .link_capacity = DataRate::KilobitsPerSec(100)},
+    EXPLICIT_TYPE_Config {.queue_delay_ms = 1, .link_capacity = DataRate::KilobitsPerSec(100)},
       /*config_update_time*/ Timestamp::Millis(500));
   EXPECT_EQ(network.NextDeliveryTimeUs(), TimeDelta::Millis(1000 + 1).us());
 
@@ -319,7 +324,7 @@ TEST(SimulatedNetworkTest, NetworkEmptyAfterLastPacketDequeued) {
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps
   // capacity should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(PacketWithSize(125)));
 
   // Collecting all the delivered packets ...
@@ -336,7 +341,7 @@ TEST(SimulatedNetworkTest, DequeueDeliverablePacketsOnLateCall) {
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps
   // capacity should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1)));
 
@@ -360,7 +365,7 @@ TEST(SimulatedNetworkTest,
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps
   // capacity should be ready to exit the network in 1 second.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(PacketWithSize(125)));
 
   // Collecting delivered packets after 0.5 seconds will result in the
@@ -378,7 +383,7 @@ TEST(SimulatedNetworkTest, QueueDelayMsWithoutStandardDeviation) {
   // A packet of 125 bytes that gets enqueued on a network with 1 kbps
   // capacity should be ready to exit the network in 1 second.
   SimulatedNetwork network = SimulatedNetwork(
-      {.queue_delay_ms = 100, .link_capacity = DataRate::KilobitsPerSec(1)});
+    EXPLICIT_TYPE_Config {.queue_delay_ms = 100, .link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(PacketWithSize(125)));
   // The next delivery time is still 1 second even if there are 100 ms of
   // extra delay but this will be applied at DequeueDeliverablePackets time.
@@ -403,7 +408,7 @@ TEST(SimulatedNetworkTest, QueueDelayMsWithoutStandardDeviation) {
 TEST(SimulatedNetworkTest,
      QueueDelayMsWithStandardDeviationAndReorderNotAllowed) {
   SimulatedNetwork network =
-      SimulatedNetwork({.queue_delay_ms = 100,
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.queue_delay_ms = 100,
                         .delay_standard_deviation_ms = 90,
                         .link_capacity = DataRate::KilobitsPerSec(1),
                         .allow_reordering = false});
@@ -441,7 +446,7 @@ TEST(SimulatedNetworkTest,
 
 TEST(SimulatedNetworkTest, QueueDelayMsWithStandardDeviationAndReorderAllowed) {
   SimulatedNetwork network =
-      SimulatedNetwork({.queue_delay_ms = 100,
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.queue_delay_ms = 100,
                         .delay_standard_deviation_ms = 90,
                         .link_capacity = DataRate::KilobitsPerSec(1),
                         .allow_reordering = true},
@@ -507,7 +512,7 @@ TEST(SimulatedNetworkTest, PacketLoss) {
 TEST(SimulatedNetworkTest, NextDeliveryTimeSetAfterLostPackets) {
   // On a network with 50% probablility of packet loss ...
   SimulatedNetwork network =
-      SimulatedNetwork({.queue_delay_ms = 10,
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.queue_delay_ms = 10,
                         .link_capacity = DataRate::KilobitsPerSec(1000),
                         .loss_percent = 50},
                        /*random_seed =*/1);
@@ -583,7 +588,7 @@ TEST(SimulatedNetworkTest, PauseTransmissionUntil) {
   // capacity should be ready to exit the network after 1, 2 and 3 seconds
   // respectively.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(
       PacketInFlightInfo(/*size=*/125, /*send_time_us=*/0, /*packet_id=*/1)));
   ASSERT_TRUE(network.EnqueuePacket(
@@ -621,7 +626,7 @@ TEST(SimulatedNetworkTest, PauseTransmissionUntil) {
 
 TEST(SimulatedNetworkTest, CongestedNetworkRespectsLinkCapacity) {
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   for (size_t i = 0; i < 1'000; ++i) {
     ASSERT_TRUE(network.EnqueuePacket(PacketInFlightInfo(
         /*size=*/125, /*send_time_us=*/0, /*packet_id=*/i)));
@@ -649,7 +654,7 @@ TEST(SimulatedNetworkTest, EnqueuePacketWithSubSecondNonMonotonicBehaviour) {
   // checks that when a non monotonic packet enqueue, the network continues to
   // work and the out of order packet is sent anyway.
   SimulatedNetwork network =
-      SimulatedNetwork({.link_capacity = DataRate::KilobitsPerSec(1)});
+      SimulatedNetwork(EXPLICIT_TYPE_Config {.link_capacity = DataRate::KilobitsPerSec(1)});
   ASSERT_TRUE(network.EnqueuePacket(PacketInFlightInfo(
       /*size=*/125, /*send_time_us=*/TimeDelta::Seconds(1).us(),
       /*packet_id=*/0)));
diff --git a/test/video_codec_tester_unittest.cc b/test/video_codec_tester_unittest.cc
index df2ac23cc3..40bd118105 100644
--- a/test/video_codec_tester_unittest.cc
+++ b/test/video_codec_tester_unittest.cc
@@ -45,6 +45,13 @@ namespace webrtc {
 namespace test {
 
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_Frame Frame
+#define EXPLICIT_TYPE_Filter Filter
+#else
+#define EXPLICIT_TYPE_Frame
+#define EXPLICIT_TYPE_Filter
+#endif
 using ::testing::_;
 using ::testing::ElementsAre;
 using ::testing::Field;
@@ -296,13 +303,13 @@ class MockCodedVideoSource : public CodedVideoSource {
 TEST_F(VideoCodecTesterTest, Slice) {
   std::unique_ptr<VideoCodecStats> stats =
       RunEncodeDecodeTest("VP9", ScalabilityMode::kL2T2,
-                          {{{.timestamp_rtp = 0,
+                          {{EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(1)},
-                            {.timestamp_rtp = 0,
+                             EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 1, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(2)}},
-                           {{.timestamp_rtp = 1,
+                           {EXPLICIT_TYPE_Frame {.timestamp_rtp = 1,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 1},
                              .frame_size = DataSize::Bytes(3)}}});
   std::vector<Frame> slice = stats->Slice(Filter{}, /*merge=*/false);
@@ -322,12 +329,12 @@ TEST_F(VideoCodecTesterTest, Slice) {
               ElementsAre(Field(&Frame::frame_size, DataSize::Bytes(1)),
                           Field(&Frame::frame_size, DataSize::Bytes(2))));
 
-  slice = stats->Slice({.layer_id = {{.spatial_idx = 0, .temporal_idx = 0}}},
+  slice = stats->Slice(EXPLICIT_TYPE_Filter {.layer_id = {{.spatial_idx = 0, .temporal_idx = 0}}},
                        /*merge=*/false);
   EXPECT_THAT(slice,
               ElementsAre(Field(&Frame::frame_size, DataSize::Bytes(1))));
 
-  slice = stats->Slice({.layer_id = {{.spatial_idx = 0, .temporal_idx = 1}}},
+  slice = stats->Slice(EXPLICIT_TYPE_Filter {.layer_id = {{.spatial_idx = 0, .temporal_idx = 1}}},
                        /*merge=*/false);
   EXPECT_THAT(slice,
               ElementsAre(Field(&Frame::frame_size, DataSize::Bytes(1)),
@@ -337,17 +344,17 @@ TEST_F(VideoCodecTesterTest, Slice) {
 TEST_F(VideoCodecTesterTest, Merge) {
   std::unique_ptr<VideoCodecStats> stats =
       RunEncodeDecodeTest("VP8", ScalabilityMode::kL2T2_KEY,
-                          {{{.timestamp_rtp = 0,
+                          {{EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(1),
                              .keyframe = true},
-                            {.timestamp_rtp = 0,
+                             EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 1, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(2)}},
-                           {{.timestamp_rtp = 1,
+                           {EXPLICIT_TYPE_Frame {.timestamp_rtp = 1,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 1},
                              .frame_size = DataSize::Bytes(4)},
-                            {.timestamp_rtp = 1,
+                             EXPLICIT_TYPE_Frame {.timestamp_rtp = 1,
                              .layer_id = {.spatial_idx = 1, .temporal_idx = 1},
                              .frame_size = DataSize::Bytes(8)}}});
 
@@ -379,24 +386,24 @@ TEST_P(VideoCodecTesterTestAggregation, Aggregate) {
   std::unique_ptr<VideoCodecStats> stats =
       RunEncodeDecodeTest("VP8", ScalabilityMode::kL2T2_KEY,
                           {{// L0T0
-                            {.timestamp_rtp = 0,
+                            EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(1),
                              .keyframe = true},
                             // L1T0
-                            {.timestamp_rtp = 0,
+                            EXPLICIT_TYPE_Frame {.timestamp_rtp = 0,
                              .layer_id = {.spatial_idx = 1, .temporal_idx = 0},
                              .frame_size = DataSize::Bytes(2)}},
                            // Emulate frame drop (frame_size = 0).
-                           {{.timestamp_rtp = 3000,
+                           {EXPLICIT_TYPE_Frame {.timestamp_rtp = 3000,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 0},
                              .frame_size = DataSize::Zero()}},
                            {// L0T1
-                            {.timestamp_rtp = 87000,
+                            EXPLICIT_TYPE_Frame {.timestamp_rtp = 87000,
                              .layer_id = {.spatial_idx = 0, .temporal_idx = 1},
                              .frame_size = DataSize::Bytes(4)},
                             // L1T1
-                            {.timestamp_rtp = 87000,
+                            EXPLICIT_TYPE_Frame {.timestamp_rtp = 87000,
                              .layer_id = {.spatial_idx = 1, .temporal_idx = 1},
                              .frame_size = DataSize::Bytes(8)}}});
 
@@ -475,8 +482,8 @@ INSTANTIATE_TEST_SUITE_P(
 TEST_F(VideoCodecTesterTest, Psnr) {
   std::unique_ptr<VideoCodecStats> stats = RunEncodeDecodeTest(
       "VP8", ScalabilityMode::kL1T1,
-      {{{.timestamp_rtp = 0, .frame_size = DataSize::Bytes(2)}},
-       {{.timestamp_rtp = 3000, .frame_size = DataSize::Bytes(6)}}});
+      {{EXPLICIT_TYPE_Frame {.timestamp_rtp = 0, .frame_size = DataSize::Bytes(2)}},
+      {EXPLICIT_TYPE_Frame {.timestamp_rtp = 3000, .frame_size = DataSize::Bytes(6)}}});
 
   std::vector<Frame> slice = stats->Slice(Filter{}, /*merge=*/false);
   ASSERT_THAT(slice, SizeIs(2));
@@ -493,12 +500,12 @@ TEST_F(VideoCodecTesterTest, Psnr) {
 TEST_F(VideoCodecTesterTest, ReversePlayback) {
   std::unique_ptr<VideoCodecStats> stats = RunEncodeDecodeTest(
       "VP8", ScalabilityMode::kL1T1,
-      {{{.timestamp_rtp = 0, .frame_size = DataSize::Bytes(1)}},
-       {{.timestamp_rtp = 1, .frame_size = DataSize::Bytes(1)}},
-       {{.timestamp_rtp = 2, .frame_size = DataSize::Bytes(1)}},
-       {{.timestamp_rtp = 3, .frame_size = DataSize::Bytes(1)}},
-       {{.timestamp_rtp = 4, .frame_size = DataSize::Bytes(1)}},
-       {{.timestamp_rtp = 5, .frame_size = DataSize::Bytes(1)}}},
+      {{EXPLICIT_TYPE_Frame {.timestamp_rtp = 0, .frame_size = DataSize::Bytes(1)}},
+       {EXPLICIT_TYPE_Frame {.timestamp_rtp = 1, .frame_size = DataSize::Bytes(1)}},
+       {EXPLICIT_TYPE_Frame {.timestamp_rtp = 2, .frame_size = DataSize::Bytes(1)}},
+       {EXPLICIT_TYPE_Frame {.timestamp_rtp = 3, .frame_size = DataSize::Bytes(1)}},
+       {EXPLICIT_TYPE_Frame {.timestamp_rtp = 4, .frame_size = DataSize::Bytes(1)}},
+       {EXPLICIT_TYPE_Frame {.timestamp_rtp = 5, .frame_size = DataSize::Bytes(1)}}},
       /*num_source_frames=*/3);
 
   std::vector<Frame> slice = stats->Slice(Filter{}, /*merge=*/false);
diff --git a/video/config/encoder_stream_factory_unittest.cc b/video/config/encoder_stream_factory_unittest.cc
index 25ba15a579..3dd465a80b 100644
--- a/video/config/encoder_stream_factory_unittest.cc
+++ b/video/config/encoder_stream_factory_unittest.cc
@@ -21,6 +21,13 @@
 
 namespace webrtc {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_StreamResolutionTestParams StreamResolutionTestParams
+#define EXPLICIT_TYPE_CreateVideoStreamParams CreateVideoStreamParams
+#else
+#define EXPLICIT_TYPE_StreamResolutionTestParams
+#define EXPLICIT_TYPE_CreateVideoStreamParams
+#endif
 using ::cricket::EncoderStreamFactory;
 using test::ExplicitKeyValueConfig;
 using ::testing::Combine;
@@ -285,7 +292,7 @@ std::vector<Resolution> CreateStreamResolutions(
 
 TEST(EncoderStreamFactory, KeepsResolutionUnchangedWhenAligned) {
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 2,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 2,
                                .resolution = {.width = 516, .height = 526}}),
       ElementsAre(Resolution{.width = 516 / 2, .height = 526 / 2},
                   Resolution{.width = 516, .height = 526}));
@@ -297,7 +304,7 @@ TEST(EncoderStreamFactory, AdjustsResolutionWhenUnaligned) {
   // simulcast stream is adjusted to be multiple of (2 ^ (number_of_streams -
   // 1)) by rounding down.
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 2,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 2,
                                .resolution = {.width = 515, .height = 517}}),
       ElementsAre(Resolution{.width = 514 / 2, .height = 516 / 2},
                   Resolution{.width = 514, .height = 516}));
@@ -315,21 +322,21 @@ TEST(EncoderStreamFactory, MakesResolutionDivisibleBy4) {
 
 TEST(EncoderStreamFactory, KeepsStreamCountUnchangedWhenResolutionIsHigh) {
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 3,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 3,
                                .resolution = {.width = 1000, .height = 1000}}),
       SizeIs(3));
 }
 
 TEST(EncoderStreamFactory, ReducesStreamCountWhenResolutionIsLow) {
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 3,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 3,
                                .resolution = {.width = 100, .height = 100}}),
       SizeIs(1));
 }
 
 TEST(EncoderStreamFactory, ReducesStreamCountDownToFirstActiveStream) {
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 3,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 3,
                                .resolution = {.width = 100, .height = 100},
                                .first_active_layer_idx = 1}),
       SizeIs(2));
@@ -339,7 +346,7 @@ TEST(EncoderStreamFactory,
      ReducesLegacyScreencastStreamCountWhenResolutionIsLow) {
   // At least 2 streams are expected to be configured in legacy screencast mode.
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 3,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 3,
                                .resolution = {.width = 100, .height = 100},
                                .is_legacy_screencast = true}),
       SizeIs(2));
@@ -355,7 +362,7 @@ TEST(EncoderStreamFactory, KeepsStreamCountUnchangedWhenLegacyLimitIsDisabled) {
 
 TEST(EncoderStreamFactory, KeepsHighResolutionWhenStreamCountIsReduced) {
   EXPECT_THAT(
-      CreateStreamResolutions({.number_of_streams = 3,
+      CreateStreamResolutions(EXPLICIT_TYPE_StreamResolutionTestParams {.number_of_streams = 3,
                                .resolution = {.width = 640, .height = 360}}),
       ElementsAre(Resolution{.width = 320, .height = 180},
                   Resolution{.width = 640, .height = 360}));
@@ -405,18 +412,18 @@ INSTANTIATE_TEST_SUITE_P(
                 .content_type = VideoEncoderConfig::ContentType::kScreen,
                 .requested_streams =
                     {CreateVideoStream(
-                         {.max_framerate_fps = 5,
+                         EXPLICIT_TYPE_CreateVideoStreamParams {.max_framerate_fps = 5,
                           .max_bitrate_bps = 420'000,
                           .scale_resolution_down_by = 1,
                           .scalability_mode = ScalabilityMode::kL1T2}),
                      CreateVideoStream(
-                         {.max_framerate_fps = 30,
+                         EXPLICIT_TYPE_CreateVideoStreamParams {.max_framerate_fps = 30,
                           .max_bitrate_bps = 2'500'000,
                           .scale_resolution_down_by = 1,
                           .scalability_mode = ScalabilityMode::kL1T2})},
                 .expected_streams =
                     {CreateVideoStream(
-                         {.width = 1920,
+                         EXPLICIT_TYPE_CreateVideoStreamParams {.width = 1920,
                           .height = 1080,
                           .max_framerate_fps = 5,
                           .min_bitrate_bps = 30'000,
@@ -424,7 +431,7 @@ INSTANTIATE_TEST_SUITE_P(
                           .max_bitrate_bps = 420'000,
                           .scalability_mode = ScalabilityMode::kL1T2}),
                      CreateVideoStream(
-                         {.width = 1920,
+                         EXPLICIT_TYPE_CreateVideoStreamParams {.width = 1920,
                           .height = 1080,
                           .max_framerate_fps = 30,
                           .min_bitrate_bps = 800'000,
diff --git a/video/end_to_end_tests/resolution_bitrate_limits_tests.cc b/video/end_to_end_tests/resolution_bitrate_limits_tests.cc
index 06eb71e366..418e4d987b 100644
--- a/video/end_to_end_tests/resolution_bitrate_limits_tests.cc
+++ b/video/end_to_end_tests/resolution_bitrate_limits_tests.cc
@@ -24,6 +24,13 @@
 namespace webrtc {
 namespace test {
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_TestConfig InitEncodeTest::TestConfig
+#define EXPLICIT_TYPE_Expectation InitEncodeTest::Expectation
+#else
+#define EXPLICIT_TYPE_TestConfig
+#define EXPLICIT_TYPE_Expectation
+#endif
 void SetEncoderSpecific(VideoEncoderConfig* encoder_config,
                         VideoCodecType type,
                         size_t num_spatial_layers) {
@@ -266,9 +273,9 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "VP9",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL1T1}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL1T1}},
       // Expectations:
-      {{.pixels = 1280 * 720,
+      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .eq_bitrate = {DataRate::KilobitsPerSec(32),
                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -285,12 +292,12 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "VP9",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL2T1}},
+      {InitEncodeTest::TestConfig{.active = true, .scalability_mode = ScalabilityMode::kL2T1}},
       // Expectations:
-      {{.pixels = 640 * 360,
+      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
         .ne_bitrate = {DataRate::KilobitsPerSec(31),
                        DataRate::KilobitsPerSec(2222)}},
-       {.pixels = 1280 * 720,
+       EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .ne_bitrate = {DataRate::KilobitsPerSec(32),
                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -298,11 +305,11 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
 TEST_P(ResolutionBitrateLimitsTest, EncodingsApplied) {
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = true,
+                      {EXPLICIT_TYPE_TestConfig {.active = true,
                         .bitrate = {DataRate::KilobitsPerSec(22),
                                     DataRate::KilobitsPerSec(3555)}}},
                       // Expectations:
-                      {{.pixels = 1280 * 720,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .eq_bitrate = {DataRate::KilobitsPerSec(22),
                                        DataRate::KilobitsPerSec(3555)}}});
   RunBaseTest(&test);
@@ -317,11 +324,11 @@ TEST_P(ResolutionBitrateLimitsTest, IntersectionApplied) {
       "max_bitrate_bps:3333000/");
 
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = true,
+                      {EXPLICIT_TYPE_TestConfig {.active = true,
                         .bitrate = {DataRate::KilobitsPerSec(22),
                                     DataRate::KilobitsPerSec(1555)}}},
                       // Expectations:
-                      {{.pixels = 1280 * 720,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .eq_bitrate = {DataRate::KilobitsPerSec(32),
                                        DataRate::KilobitsPerSec(1555)}}});
   RunBaseTest(&test);
@@ -336,9 +343,9 @@ TEST_P(ResolutionBitrateLimitsTest, LimitsAppliedMiddleActive) {
       "max_bitrate_bps:2222000|3333000/");
 
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = false}, {.active = true}, {.active = false}},
+                      {EXPLICIT_TYPE_TestConfig {.active = false}, {.active = true}, {.active = false}},
                       // Expectations:
-                      {{.pixels = 640 * 360,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
                         .eq_bitrate = {DataRate::KilobitsPerSec(21),
                                        DataRate::KilobitsPerSec(2222)}}});
   RunBaseTest(&test);
@@ -354,15 +361,15 @@ TEST_P(ResolutionBitrateLimitsTest, EncodingMinBitrateAppliedMiddleActive) {
 
   // Max bitrate: min of encoding and bitrate limits used.
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = false,
+                      {EXPLICIT_TYPE_TestConfig {.active = false,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(1000)}},
-                       {.active = true,
+                       EXPLICIT_TYPE_TestConfig {.active = true,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(1555)}},
-                       {.active = false}},
+                       EXPLICIT_TYPE_TestConfig {.active = false}},
                       // Expectations:
-                      {{.pixels = 640 * 360,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
                         .eq_bitrate = {DataRate::KilobitsPerSec(28),
                                        DataRate::KilobitsPerSec(1555)}}});
   RunBaseTest(&test);
@@ -376,9 +383,9 @@ TEST_P(ResolutionBitrateLimitsTest, DefaultLimitsAppliedMiddleActive) {
 
   InitEncodeTest test(
       env(), payload_name_,
-      {{.active = false}, {.active = true}, {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = false}, {.active = true}, {.active = false}},
       // Expectations:
-      {{.pixels = 640 * 360,
+      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
         .eq_bitrate = {
             DataRate::BitsPerSec(kDefaultSinglecastLimits360p->min_bitrate_bps),
             DataRate::BitsPerSec(
@@ -395,10 +402,10 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "VP9",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL1T3},
-       {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL1T3},
+       EXPLICIT_TYPE_TestConfig {.active = false}},
       // Expectations:
-      {{.pixels = 1280 * 720,
+      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .eq_bitrate = {
             DataRate::BitsPerSec(kDefaultSinglecastLimits720p->min_bitrate_bps),
             DataRate::BitsPerSec(
@@ -415,9 +422,9 @@ TEST_P(ResolutionBitrateLimitsTest, LimitsAppliedHighestActive) {
       "max_bitrate_bps:2222000|3333000/");
 
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = false}, {.active = false}, {.active = true}},
+                      {EXPLICIT_TYPE_TestConfig {.active = false}, {.active = false}, {.active = true}},
                       // Expectations:
-                      {{.pixels = 1280 * 720,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .eq_bitrate = {DataRate::KilobitsPerSec(32),
                                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -433,17 +440,17 @@ TEST_P(ResolutionBitrateLimitsTest, EncodingMinBitrateAppliedHighestActive) {
 
   // Max bitrate: min of encoding and bitrate limits used.
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = false,
+                      {EXPLICIT_TYPE_TestConfig {.active = false,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(500)}},
-                       {.active = false,
+                       EXPLICIT_TYPE_TestConfig {.active = false,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(1000)}},
-                       {.active = true,
+                       EXPLICIT_TYPE_TestConfig {.active = true,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(1555)}}},
                       // Expectations:
-                      {{.pixels = 1280 * 720,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .eq_bitrate = {DataRate::KilobitsPerSec(28),
                                        DataRate::KilobitsPerSec(1555)}}});
   RunBaseTest(&test);
@@ -458,12 +465,12 @@ TEST_P(ResolutionBitrateLimitsTest, LimitsNotAppliedLowestActive) {
       "max_bitrate_bps:2222000|3333000/");
 
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = true}, {.active = false}},
+                      {EXPLICIT_TYPE_TestConfig {.active = true}, {.active = false}},
                       // Expectations:
-                      {{.pixels = 640 * 360,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
                         .ne_bitrate = {DataRate::KilobitsPerSec(31),
                                        DataRate::KilobitsPerSec(2222)}},
-                       {.pixels = 1280 * 720,
+                       EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .ne_bitrate = {DataRate::KilobitsPerSec(32),
                                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -480,10 +487,10 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "VP9",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL1T1},
-       {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL1T1},
+       EXPLICIT_TYPE_TestConfig {.active = false}},
       // Expectations:
-      {{.pixels = 1280 * 720,
+      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .eq_bitrate = {DataRate::KilobitsPerSec(32),
                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -500,13 +507,13 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "VP9",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL2T1},
-       {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL2T1},
+       EXPLICIT_TYPE_TestConfig {.active = false}},
       // Expectations:
-      {{.pixels = 640 * 360,
+      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
         .ne_bitrate = {DataRate::KilobitsPerSec(31),
                        DataRate::KilobitsPerSec(2222)}},
-       {.pixels = 1280 * 720,
+       EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .ne_bitrate = {DataRate::KilobitsPerSec(32),
                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
@@ -523,9 +530,9 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "AV1",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL1T1}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL1T1}},
       // Expectations:
-      {{.pixels = 1280 * 720,
+      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .eq_bitrate = {DataRate::KilobitsPerSec(32),
                        DataRate::KilobitsPerSec(133)}}});
   RunBaseTest(&test);
@@ -542,10 +549,10 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "AV1",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL1T1},
-       {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL1T1},
+       EXPLICIT_TYPE_TestConfig {.active = false}},
       // Expectations:
-      {{.pixels = 1280 * 720,
+      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .eq_bitrate = {DataRate::KilobitsPerSec(80),
                        DataRate::KilobitsPerSec(1200)}}});
   RunBaseTest(&test);
@@ -562,13 +569,13 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   // Max bitrate: min of encoding and bitrate limits used.
   InitEncodeTest test(env(), "AV1",
-                      {{.active = true,
+                      {EXPLICIT_TYPE_TestConfig {.active = true,
                         .bitrate = {DataRate::KilobitsPerSec(28),
                                     DataRate::KilobitsPerSec(100)},
                         .scalability_mode = ScalabilityMode::kL1T1},
-                       {.active = false}},
+                       EXPLICIT_TYPE_TestConfig {.active = false}},
                       // Expectations:
-                      {{.pixels = 1280 * 720,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .eq_bitrate = {DataRate::KilobitsPerSec(28),
                                        DataRate::KilobitsPerSec(100)}}});
   RunBaseTest(&test);
@@ -585,13 +592,13 @@ TEST_F(ResolutionBitrateLimitsWithScalabilityModeTest,
 
   InitEncodeTest test(
       env(), "AV1",
-      {{.active = true, .scalability_mode = ScalabilityMode::kL2T1},
-       {.active = false}},
+      {EXPLICIT_TYPE_TestConfig {.active = true, .scalability_mode = ScalabilityMode::kL2T1},
+       EXPLICIT_TYPE_TestConfig {.active = false}},
       // Expectations:
       {{.pixels = 640 * 360,
         .ne_bitrate = {DataRate::KilobitsPerSec(20),
                        DataRate::KilobitsPerSec(900)}},
-       {.pixels = 1280 * 720,
+       EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
         .ne_bitrate = {DataRate::KilobitsPerSec(25),
                        DataRate::KilobitsPerSec(1333)}}});
   RunBaseTest(&test);
@@ -606,12 +613,12 @@ TEST_P(ResolutionBitrateLimitsTest, LimitsNotAppliedSimulcast) {
       "max_bitrate_bps:2222000|3333000/");
 
   InitEncodeTest test(env(), payload_name_,
-                      {{.active = true}, {.active = true}},
+                      {EXPLICIT_TYPE_TestConfig {.active = true}, {.active = true}},
                       // Expectations:
-                      {{.pixels = 640 * 360,
+                      {EXPLICIT_TYPE_Expectation {.pixels = 640 * 360,
                         .ne_bitrate = {DataRate::KilobitsPerSec(31),
                                        DataRate::KilobitsPerSec(2222)}},
-                       {.pixels = 1280 * 720,
+                       EXPLICIT_TYPE_Expectation {.pixels = 1280 * 720,
                         .ne_bitrate = {DataRate::KilobitsPerSec(32),
                                        DataRate::KilobitsPerSec(3333)}}});
   RunBaseTest(&test);
diff --git a/video/full_stack_tests.cc b/video/full_stack_tests.cc
index 7e462605e1..86553cc364 100644
--- a/video/full_stack_tests.cc
+++ b/video/full_stack_tests.cc
@@ -48,6 +48,13 @@ ABSL_FLAG(std::string,
 namespace webrtc {
 
 namespace {
+#if defined(WEBRTC_QNX) && __QNX__ < 800
+#define EXPLICIT_TYPE_Video VideoQualityTest::Params::Video
+#define EXPLICIT_TYPE_Analyzer VideoQualityTest::Params::Analyzer
+#else
+#define EXPLICIT_TYPE_Video
+#define EXPLICIT_TYPE_Analyzer
+#endif
 static const int kFullStackTestDurationSecs = 45;
 
 struct ParamsWithLogging : public VideoQualityTest::Params {
@@ -654,7 +661,7 @@ TEST(FullStackTest, Foreman_Cif_30kbps_AV1) {
   auto fixture = CreateVideoQualityTestFixture();
   ParamsWithLogging foreman_cif;
   foreman_cif.call.send_side_bwe = true;
-  foreman_cif.video[0] = {.enabled = true,
+  foreman_cif.video[0] = EXPLICIT_TYPE_Video {.enabled = true,
                           .width = 352,
                           .height = 288,
                           .fps = 10,
@@ -665,7 +672,7 @@ TEST(FullStackTest, Foreman_Cif_30kbps_AV1) {
                           .num_temporal_layers = 1,
                           .selected_tl = 0,
                           .clip_path = ClipNameToClipPath("foreman_cif")};
-  foreman_cif.analyzer = {.test_label = "foreman_cif_30kbps_AV1",
+  foreman_cif.analyzer = EXPLICIT_TYPE_Analyzer {.test_label = "foreman_cif_30kbps_AV1",
                           .test_durations_secs = kFullStackTestDurationSecs};
   foreman_cif.config->link_capacity = DataRate::KilobitsPerSec(30);
   foreman_cif.call.generic_descriptor = true;
@@ -676,7 +683,7 @@ TEST(FullStackTest, Conference_Motion_Hd_3tl_AV1) {
   auto fixture = CreateVideoQualityTestFixture();
   ParamsWithLogging conf_motion_hd;
   conf_motion_hd.call.send_side_bwe = true;
-  conf_motion_hd.video[0] = {
+  conf_motion_hd.video[0] = EXPLICIT_TYPE_Video {
       .enabled = true,
       .width = 1280,
       .height = 720,
@@ -688,7 +695,7 @@ TEST(FullStackTest, Conference_Motion_Hd_3tl_AV1) {
       .num_temporal_layers = 3,
       .clip_path = ClipNameToClipPath("ConferenceMotion_1280_720_50")};
 
-  conf_motion_hd.analyzer = {.test_label = "conference_motion_hd_3tl_AV1",
+  conf_motion_hd.analyzer = EXPLICIT_TYPE_Analyzer {.test_label = "conference_motion_hd_3tl_AV1",
                              .test_durations_secs = kFullStackTestDurationSecs};
   conf_motion_hd.config->queue_length_packets = 50;
   conf_motion_hd.config->loss_percent = 3;
@@ -708,11 +715,11 @@ TEST(FullStackTest, Conference_Motion_Hd_3tl_AV1) {
 TEST(FullStackTest, MAYBE_Screenshare_Slides_Simulcast_AV1) {
   auto fixture = CreateVideoQualityTestFixture();
   ParamsWithLogging screenshare;
-  screenshare.analyzer = {.test_label = "screenshare_slides_simulcast_AV1",
+  screenshare.analyzer = EXPLICIT_TYPE_Analyzer {.test_label = "screenshare_slides_simulcast_AV1",
                           .test_durations_secs = kFullStackTestDurationSecs};
   screenshare.call.send_side_bwe = true;
   screenshare.screenshare[0] = {.enabled = true};
-  screenshare.video[0] = {.enabled = true,
+  screenshare.video[0] = EXPLICIT_TYPE_Video {.enabled = true,
                           .width = 1850,
                           .height = 1110,
                           .fps = 30,
@@ -725,7 +732,7 @@ TEST(FullStackTest, MAYBE_Screenshare_Slides_Simulcast_AV1) {
   // Set `min_bitrate_bps` and `target_bitrate_bps` to zero to use WebRTC
   // defaults.
   VideoQualityTest::Params screenshare_params_low;
-  screenshare_params_low.video[0] = {.enabled = true,
+  screenshare_params_low.video[0] = EXPLICIT_TYPE_Video {.enabled = true,
                                      .width = 1850,
                                      .height = 1110,
                                      .fps = 5,
@@ -736,7 +743,7 @@ TEST(FullStackTest, MAYBE_Screenshare_Slides_Simulcast_AV1) {
                                      .num_temporal_layers = 2};
 
   VideoQualityTest::Params screenshare_params_high;
-  screenshare_params_high.video[0] = {.enabled = true,
+  screenshare_params_high.video[0] = EXPLICIT_TYPE_Video {.enabled = true,
                                       .width = 1850,
                                       .height = 1110,
                                       .fps = 30,
-- 
2.34.1

