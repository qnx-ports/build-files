/* Generated by wayland-scanner 1.23.1 */

#ifndef WESTON_TEST_SERVER_PROTOCOL_H
#define WESTON_TEST_SERVER_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-server.h"

#ifdef  __cplusplus
extern "C" {
#endif

struct wl_client;
struct wl_resource;

/**
 * @page page_weston_test The weston_test protocol
 * @section page_ifaces_weston_test Interfaces
 * - @subpage page_iface_weston_test - weston internal testing
 * - @subpage page_iface_weston_test_runner - weston internal testing
 * @section page_copyright_weston_test Copyright
 * <pre>
 *
 * Copyright Â© 2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct weston_test;
struct weston_test_runner;
struct wl_surface;

#ifndef WESTON_TEST_INTERFACE
#define WESTON_TEST_INTERFACE
/**
 * @page page_iface_weston_test weston_test
 * @section page_iface_weston_test_desc Description
 *
 * Internal testing facilities for the weston compositor.
 *
 * It can't be stressed enough that these should never ever be used
 * outside of running weston's tests.  The weston-test.so module should
 * never be installed.
 *
 * These requests may allow clients to do very bad things.
 * @section page_iface_weston_test_api API
 * See @ref iface_weston_test.
 */
/**
 * @defgroup iface_weston_test The weston_test interface
 *
 * Internal testing facilities for the weston compositor.
 *
 * It can't be stressed enough that these should never ever be used
 * outside of running weston's tests.  The weston-test.so module should
 * never be installed.
 *
 * These requests may allow clients to do very bad things.
 */
extern const struct wl_interface weston_test_interface;
#endif
#ifndef WESTON_TEST_RUNNER_INTERFACE
#define WESTON_TEST_RUNNER_INTERFACE
/**
 * @page page_iface_weston_test_runner weston_test_runner
 * @section page_iface_weston_test_runner_desc Description
 *
 * This is a global singleton interface for Weston internal tests.
 *
 * This interface allows a test client to trigger compositor-side
 * test procedures. This is useful for cases, where the actual tests
 * are in compositor plugins, but they also require the presence of
 * a particular client.
 *
 * This interface is implemented by the compositor plugins containing
 * the testing code.
 *
 * A test client starts a test with the "run" request. It must not send
 * another "run" request until receiving the "finished" event. If the
 * compositor-side test succeeds, the "finished" event is sent. If the
 * compositor-side test fails, the compositor should send the protocol
 * error "test_failed", but it may also exit with an error (e.g. SEGV).
 *
 * Unknown test name will raise "unknown_test" protocol error.
 * @section page_iface_weston_test_runner_api API
 * See @ref iface_weston_test_runner.
 */
/**
 * @defgroup iface_weston_test_runner The weston_test_runner interface
 *
 * This is a global singleton interface for Weston internal tests.
 *
 * This interface allows a test client to trigger compositor-side
 * test procedures. This is useful for cases, where the actual tests
 * are in compositor plugins, but they also require the presence of
 * a particular client.
 *
 * This interface is implemented by the compositor plugins containing
 * the testing code.
 *
 * A test client starts a test with the "run" request. It must not send
 * another "run" request until receiving the "finished" event. If the
 * compositor-side test succeeds, the "finished" event is sent. If the
 * compositor-side test fails, the compositor should send the protocol
 * error "test_failed", but it may also exit with an error (e.g. SEGV).
 *
 * Unknown test name will raise "unknown_test" protocol error.
 */
extern const struct wl_interface weston_test_runner_interface;
#endif

#ifndef WESTON_TEST_ERROR_ENUM
#define WESTON_TEST_ERROR_ENUM
enum weston_test_error {
	/**
	 * invalid coordinate
	 */
	WESTON_TEST_ERROR_TOUCH_UP_WITH_COORDINATE = 0,
};
/**
 * @ingroup iface_weston_test
 * Validate a weston_test error value.
 *
 * @return true on success, false on error.
 * @ref weston_test_error
 */
static inline bool
weston_test_error_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case WESTON_TEST_ERROR_TOUCH_UP_WITH_COORDINATE:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* WESTON_TEST_ERROR_ENUM */

#ifndef WESTON_TEST_BREAKPOINT_ENUM
#define WESTON_TEST_BREAKPOINT_ENUM
enum weston_test_breakpoint {
	/**
	 * after output repaint (filter type: wl_output)
	 */
	WESTON_TEST_BREAKPOINT_POST_REPAINT = 0,
};
/**
 * @ingroup iface_weston_test
 * Validate a weston_test breakpoint value.
 *
 * @return true on success, false on error.
 * @ref weston_test_breakpoint
 */
static inline bool
weston_test_breakpoint_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case WESTON_TEST_BREAKPOINT_POST_REPAINT:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* WESTON_TEST_BREAKPOINT_ENUM */

/**
 * @ingroup iface_weston_test
 * @struct weston_test_interface
 */
struct weston_test_interface {
	/**
	 */
	void (*move_surface)(struct wl_client *client,
			     struct wl_resource *resource,
			     struct wl_resource *surface,
			     int32_t x,
			     int32_t y);
	/**
	 */
	void (*move_pointer)(struct wl_client *client,
			     struct wl_resource *resource,
			     uint32_t tv_sec_hi,
			     uint32_t tv_sec_lo,
			     uint32_t tv_nsec,
			     int32_t x,
			     int32_t y);
	/**
	 */
	void (*send_button)(struct wl_client *client,
			    struct wl_resource *resource,
			    uint32_t tv_sec_hi,
			    uint32_t tv_sec_lo,
			    uint32_t tv_nsec,
			    int32_t button,
			    uint32_t state);
	/**
	 */
	void (*send_axis)(struct wl_client *client,
			  struct wl_resource *resource,
			  uint32_t tv_sec_hi,
			  uint32_t tv_sec_lo,
			  uint32_t tv_nsec,
			  uint32_t axis,
			  wl_fixed_t value);
	/**
	 */
	void (*activate_surface)(struct wl_client *client,
				 struct wl_resource *resource,
				 struct wl_resource *surface);
	/**
	 */
	void (*send_key)(struct wl_client *client,
			 struct wl_resource *resource,
			 uint32_t tv_sec_hi,
			 uint32_t tv_sec_lo,
			 uint32_t tv_nsec,
			 uint32_t key,
			 uint32_t state);
	/**
	 */
	void (*device_release)(struct wl_client *client,
			       struct wl_resource *resource,
			       const char *device);
	/**
	 */
	void (*device_add)(struct wl_client *client,
			   struct wl_resource *resource,
			   const char *device);
	/**
	 */
	void (*send_touch)(struct wl_client *client,
			   struct wl_resource *resource,
			   uint32_t tv_sec_hi,
			   uint32_t tv_sec_lo,
			   uint32_t tv_nsec,
			   int32_t touch_id,
			   wl_fixed_t x,
			   wl_fixed_t y,
			   uint32_t touch_type);
	/**
	 * request compositor pause at a certain point
	 *
	 * Request that the compositor pauses execution at a certain
	 * point. When execution is paused, the compositor will signal the
	 * shared semaphore to the client.
	 * @param breakpoint event type to wait for
	 * @param resource_id optional Wayland resource ID to filter for (type-specific)
	 */
	void (*client_break)(struct wl_client *client,
			     struct wl_resource *resource,
			     uint32_t breakpoint,
			     uint32_t resource_id);
};

#define WESTON_TEST_POINTER_POSITION 0

/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_POINTER_POSITION_SINCE_VERSION 1

/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_MOVE_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_MOVE_POINTER_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_SEND_BUTTON_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_SEND_AXIS_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_ACTIVATE_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_SEND_KEY_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_DEVICE_RELEASE_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_DEVICE_ADD_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_SEND_TOUCH_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test
 */
#define WESTON_TEST_CLIENT_BREAK_SINCE_VERSION 1

/**
 * @ingroup iface_weston_test
 * Sends an pointer_position event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
weston_test_send_pointer_position(struct wl_resource *resource_, wl_fixed_t x, wl_fixed_t y)
{
	wl_resource_post_event(resource_, WESTON_TEST_POINTER_POSITION, x, y);
}

#ifndef WESTON_TEST_RUNNER_ERROR_ENUM
#define WESTON_TEST_RUNNER_ERROR_ENUM
enum weston_test_runner_error {
	/**
	 * compositor test failed
	 */
	WESTON_TEST_RUNNER_ERROR_TEST_FAILED = 0,
	/**
	 * unrecognized test name
	 */
	WESTON_TEST_RUNNER_ERROR_UNKNOWN_TEST = 1,
};
/**
 * @ingroup iface_weston_test_runner
 * Validate a weston_test_runner error value.
 *
 * @return true on success, false on error.
 * @ref weston_test_runner_error
 */
static inline bool
weston_test_runner_error_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case WESTON_TEST_RUNNER_ERROR_TEST_FAILED:
		return version >= 1;
	case WESTON_TEST_RUNNER_ERROR_UNKNOWN_TEST:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* WESTON_TEST_RUNNER_ERROR_ENUM */

/**
 * @ingroup iface_weston_test_runner
 * @struct weston_test_runner_interface
 */
struct weston_test_runner_interface {
	/**
	 */
	void (*destroy)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 */
	void (*run)(struct wl_client *client,
		    struct wl_resource *resource,
		    const char *test_name);
};

#define WESTON_TEST_RUNNER_FINISHED 0

/**
 * @ingroup iface_weston_test_runner
 */
#define WESTON_TEST_RUNNER_FINISHED_SINCE_VERSION 1

/**
 * @ingroup iface_weston_test_runner
 */
#define WESTON_TEST_RUNNER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_weston_test_runner
 */
#define WESTON_TEST_RUNNER_RUN_SINCE_VERSION 1

/**
 * @ingroup iface_weston_test_runner
 * Sends an finished event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
weston_test_runner_send_finished(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, WESTON_TEST_RUNNER_FINISHED);
}

#ifdef  __cplusplus
}
#endif

#endif
