#!/bin/sh

# Path from build dir to source root
NESTED_LEVEL="${QNX_PROJECT_ROOT:-../../..}"

# Default prefix inside QNX target sysroot
BASIC_PREFIX="/usr/local"
EXEC_PREFIX="/${cpudir}${BASIC_PREFIX}"

function hook_preconfigure {
    echo "hook_preconfigure - running autoreconf in ${NESTED_LEVEL}"

    # Unset any conflicting autoconf tool variables
    unset AUTOMAKE AUTOCONF AUTOHEADER AUTORECONF ACLOCAL

    # Set DESTDIR for staged installs
    export DESTDIR="${INSTALL_ROOT_nto}"

    # Ensure pkg-config points to QNX target .pc files
    export PKG_CONFIG_LIBDIR="${INSTALL_ROOT_nto}/${cpudir}${BASIC_PREFIX}/lib/pkgconfig"

    # Ensure compiler flags can find QNX includes and libs
    export CPPFLAGS="-I${QNX_TARGET}/${cpudir}/usr/include \
                     -I${INSTALL_ROOT_nto}/${cpudir}${BASIC_PREFIX}/include ${CPPFLAGS}"

    export LDFLAGS="-L${INSTALL_ROOT_nto}/${cpudir}${BASIC_PREFIX}/lib \
                    -L${INSTALL_ROOT_nto}/${cpudir}/usr/lib ${LDFLAGS}"
    
    # Set CFLAGS that configure will use
    export CFLAGS="-O2 -Wall"

    # Optional: regenerate configure (only if missing)
    if [ ! -x "${NESTED_LEVEL}/configure" ]; then
        (cd "${NESTED_LEVEL}" && autoreconf -fiv)
    fi
}

function hook_configure {
    echo "hook_configure - running configure"

    "${NESTED_LEVEL}/configure" \
        --srcdir="${NESTED_LEVEL}" \
        --prefix="${BASIC_PREFIX}" \
        --exec-prefix="${EXEC_PREFIX}" \
        --host="${machine}" \
        --enable-public-key \
        --disable-openssl \
        --disable-fat \
        --disable-documentation     # disable doc as CI was failing to create documentation
}

function hook_make {
    echo "hook_make - running make ${make_cmds}"

    INSTALL_ROOT="${INSTALL_ROOT_nto}"

    if [ "${make_cmds}" = "install" ]; then
        make ${JLEVEL:+-j${JLEVEL}} install || exit 1
        # Clean up .la files
        find "${INSTALL_ROOT_nto}" -name "*.la" -exec rm -f {} \;
    else
        make ${JLEVEL:+-j${JLEVEL}} ${make_cmds} || exit 1
    fi
}
